\hypertarget{structprism_1_1_bitvector_data}{}\section{prism\+:\+:Bitvector\+Data Struct Reference}
\label{structprism_1_1_bitvector_data}\index{prism\+::\+Bitvector\+Data@{prism\+::\+Bitvector\+Data}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structprism_1_1_bitvector_data_1_1memory}{memory}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
const int \hyperlink{structprism_1_1_bitvector_data_a64584940a3ca3556048e95b22ac4d5dd}{num\+Chunks} (const int n\+Bits) const 
\item 
const bool \hyperlink{structprism_1_1_bitvector_data_a0d6a154da2f0734439a21694119834fa}{range\+Check} (const int n) const 
\item 
void \hyperlink{structprism_1_1_bitvector_data_ae40f25a068b90247edcbd4f34fa2a18f}{reserve} (const int n\+Chunks)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structprism_1_1_bitvector_data_1_1memory}{memory} \hyperlink{structprism_1_1_bitvector_data_abcf70b2679d4c52bf398a1a308aca5c2}{storage}
\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\index{prism\+::\+Bitvector\+Data@{prism\+::\+Bitvector\+Data}!num\+Chunks@{num\+Chunks}}
\index{num\+Chunks@{num\+Chunks}!prism\+::\+Bitvector\+Data@{prism\+::\+Bitvector\+Data}}
\subsubsection[{\texorpdfstring{num\+Chunks(const int n\+Bits) const }{numChunks(const int nBits) const }}]{\setlength{\rightskip}{0pt plus 5cm}const int prism\+::\+Bitvector\+Data\+::num\+Chunks (
\begin{DoxyParamCaption}
\item[{const int}]{n\+Bits}
\end{DoxyParamCaption}
) const}\hypertarget{structprism_1_1_bitvector_data_a64584940a3ca3556048e95b22ac4d5dd}{}\label{structprism_1_1_bitvector_data_a64584940a3ca3556048e95b22ac4d5dd}
Method that returns the number of chunks needed to hold {\itshape n\+Bits}. \index{prism\+::\+Bitvector\+Data@{prism\+::\+Bitvector\+Data}!range\+Check@{range\+Check}}
\index{range\+Check@{range\+Check}!prism\+::\+Bitvector\+Data@{prism\+::\+Bitvector\+Data}}
\subsubsection[{\texorpdfstring{range\+Check(const int n) const }{rangeCheck(const int n) const }}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::\+Bitvector\+Data\+::range\+Check (
\begin{DoxyParamCaption}
\item[{const int}]{n}
\end{DoxyParamCaption}
) const}\hypertarget{structprism_1_1_bitvector_data_a0d6a154da2f0734439a21694119834fa}{}\label{structprism_1_1_bitvector_data_a0d6a154da2f0734439a21694119834fa}
Method that performs a bounds check on the index {\itshape n}. Returns true if {\itshape n} is is within bounds and false if not. \index{prism\+::\+Bitvector\+Data@{prism\+::\+Bitvector\+Data}!reserve@{reserve}}
\index{reserve@{reserve}!prism\+::\+Bitvector\+Data@{prism\+::\+Bitvector\+Data}}
\subsubsection[{\texorpdfstring{reserve(const int n\+Chunks)}{reserve(const int nChunks)}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::\+Bitvector\+Data\+::reserve (
\begin{DoxyParamCaption}
\item[{const int}]{n\+Chunks}
\end{DoxyParamCaption}
)}\hypertarget{structprism_1_1_bitvector_data_ae40f25a068b90247edcbd4f34fa2a18f}{}\label{structprism_1_1_bitvector_data_ae40f25a068b90247edcbd4f34fa2a18f}
Method that reserves enough memory to contain the bits required. 

\subsection{Member Data Documentation}
\index{prism\+::\+Bitvector\+Data@{prism\+::\+Bitvector\+Data}!storage@{storage}}
\index{storage@{storage}!prism\+::\+Bitvector\+Data@{prism\+::\+Bitvector\+Data}}
\subsubsection[{\texorpdfstring{storage}{storage}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf memory} prism\+::\+Bitvector\+Data\+::storage}\hypertarget{structprism_1_1_bitvector_data_abcf70b2679d4c52bf398a1a308aca5c2}{}\label{structprism_1_1_bitvector_data_abcf70b2679d4c52bf398a1a308aca5c2}


The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{_bitvector_8cpp}{Bitvector.\+cpp}\end{DoxyCompactItemize}
