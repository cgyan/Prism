\hypertarget{class_unique_pointer}{}\section{Unique\+Pointer$<$ T, D $>$ Class Template Reference}
\label{class_unique_pointer}\index{Unique\+Pointer$<$ T, D $>$@{Unique\+Pointer$<$ T, D $>$}}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{class_unique_pointer_a3894408ba9899edc0388aeb018833414}{pointer} = T $\ast$
\item 
using \hyperlink{class_unique_pointer_a0ccc3b99b9fef0fb9a8d738793535fc2}{element\+\_\+type} = T
\item 
using \hyperlink{class_unique_pointer_aea5e9d2fa26d0acca416a9e9451e08c3}{deleter\+\_\+type} = D
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_unique_pointer_a9982920bcf97bed211fab425f22bfc34}{Unique\+Pointer} (\hyperlink{class_unique_pointer_a3894408ba9899edc0388aeb018833414}{pointer} p=nullptr)
\item 
\hyperlink{class_unique_pointer_aa8b0142eaf5583737be10113f1560a76}{Unique\+Pointer} (const \hyperlink{class_unique_pointer}{Unique\+Pointer} \&copy)=delete
\item 
\hyperlink{class_unique_pointer}{Unique\+Pointer} \& \hyperlink{class_unique_pointer_a976ee7dcfde743ee180864fef7e330c9}{operator=} (const \hyperlink{class_unique_pointer}{Unique\+Pointer} \&rhs)=delete
\item 
\hyperlink{class_unique_pointer_a34d23b09547c438f3c6c3a57abc50e15}{$\sim$\+Unique\+Pointer} ()
\item 
\hyperlink{class_unique_pointer_a3894408ba9899edc0388aeb018833414}{pointer} \hyperlink{class_unique_pointer_ab07e87f9fcbe6cee2f9f2a0e22ce181e}{data} () const 
\item 
\hyperlink{class_unique_pointer_aea5e9d2fa26d0acca416a9e9451e08c3}{deleter\+\_\+type} \hyperlink{class_unique_pointer_a8e383d41c2499077dca341c6dbe080f9}{get\+Deleter} () const 
\item 
const bool \hyperlink{class_unique_pointer_abce5b65a179dfd63ff572706512aaabb}{is\+Null} () const 
\item 
\hyperlink{class_unique_pointer_a3894408ba9899edc0388aeb018833414}{pointer} \hyperlink{class_unique_pointer_aa2cef6b7af64bf1b83e897ace29a43c7}{release} ()
\item 
void \hyperlink{class_unique_pointer_a03be417a8b93e6655888f812322194b0}{reset} (\hyperlink{class_unique_pointer_a3894408ba9899edc0388aeb018833414}{pointer} p=nullptr)
\item 
void \hyperlink{class_unique_pointer_a1ffb282471b339cbcd7cf3329d3e0af6}{swap} (\hyperlink{class_unique_pointer}{Unique\+Pointer} \&other)
\item 
\hyperlink{class_unique_pointer_a0ccc3b99b9fef0fb9a8d738793535fc2}{element\+\_\+type} \hyperlink{class_unique_pointer_a11af6c570adeb70ac357c2789c5070ab}{operator$\ast$} ()
\item 
\hyperlink{class_unique_pointer_a3894408ba9899edc0388aeb018833414}{pointer} \hyperlink{class_unique_pointer_ae978bbeec35cc36f8298ab083d0f68f4}{operator-\/$>$} ()
\item 
\hyperlink{class_unique_pointer_ace903f0cc5fa47eaf3b65e7dc3cc75e2}{operator bool} () const 
\end{DoxyCompactItemize}


\subsection{Member Typedef Documentation}
\index{Unique\+Pointer@{Unique\+Pointer}!deleter\+\_\+type@{deleter\+\_\+type}}
\index{deleter\+\_\+type@{deleter\+\_\+type}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{deleter\+\_\+type}{deleter_type}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ using {\bf Unique\+Pointer}$<$ T, D $>$\+::{\bf deleter\+\_\+type} =  D}\hypertarget{class_unique_pointer_aea5e9d2fa26d0acca416a9e9451e08c3}{}\label{class_unique_pointer_aea5e9d2fa26d0acca416a9e9451e08c3}
\index{Unique\+Pointer@{Unique\+Pointer}!element\+\_\+type@{element\+\_\+type}}
\index{element\+\_\+type@{element\+\_\+type}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{element\+\_\+type}{element_type}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ using {\bf Unique\+Pointer}$<$ T, D $>$\+::{\bf element\+\_\+type} =  T}\hypertarget{class_unique_pointer_a0ccc3b99b9fef0fb9a8d738793535fc2}{}\label{class_unique_pointer_a0ccc3b99b9fef0fb9a8d738793535fc2}
\index{Unique\+Pointer@{Unique\+Pointer}!pointer@{pointer}}
\index{pointer@{pointer}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{pointer}{pointer}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ using {\bf Unique\+Pointer}$<$ T, D $>$\+::{\bf pointer} =  T$\ast$}\hypertarget{class_unique_pointer_a3894408ba9899edc0388aeb018833414}{}\label{class_unique_pointer_a3894408ba9899edc0388aeb018833414}


\subsection{Constructor \& Destructor Documentation}
\index{Unique\+Pointer@{Unique\+Pointer}!Unique\+Pointer@{Unique\+Pointer}}
\index{Unique\+Pointer@{Unique\+Pointer}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{Unique\+Pointer(pointer p=nullptr)}{UniquePointer(pointer p=nullptr)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ {\bf Unique\+Pointer}$<$ T, D $>$\+::{\bf Unique\+Pointer} (
\begin{DoxyParamCaption}
\item[{{\bf pointer}}]{p = {\ttfamily nullptr}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [explicit]}}\hypertarget{class_unique_pointer_a9982920bcf97bed211fab425f22bfc34}{}\label{class_unique_pointer_a9982920bcf97bed211fab425f22bfc34}
Creates a \hyperlink{class_unique_pointer}{Unique\+Pointer} that will manage the lifetime of a raw pointer (if supplied). If no pointer is supplied then the the \hyperlink{class_unique_pointer}{Unique\+Pointer} is in a null state (empty but still valid). If a pointer is supplied then it is stored internally by the \hyperlink{class_unique_pointer}{Unique\+Pointer}.


\begin{DoxyParams}{Parameters}
{\em p} & A raw pointer that the \hyperlink{class_unique_pointer}{Unique\+Pointer} will take ownership of and will manage the deallocation of.\\
\hline
\end{DoxyParams}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{Unique\+Pointer@{Unique\+Pointer}!Unique\+Pointer@{Unique\+Pointer}}
\index{Unique\+Pointer@{Unique\+Pointer}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{Unique\+Pointer(const Unique\+Pointer \&copy)=delete}{UniquePointer(const UniquePointer &copy)=delete}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ {\bf Unique\+Pointer}$<$ T, D $>$\+::{\bf Unique\+Pointer} (
\begin{DoxyParamCaption}
\item[{const {\bf Unique\+Pointer}$<$ T, D $>$ \&}]{copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [delete]}}\hypertarget{class_unique_pointer_aa8b0142eaf5583737be10113f1560a76}{}\label{class_unique_pointer_aa8b0142eaf5583737be10113f1560a76}
Explicitly disabled as a \hyperlink{class_unique_pointer}{Unique\+Pointer} cannot be unique if it is allowable to be copyable

\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{Unique\+Pointer@{Unique\+Pointer}!````~Unique\+Pointer@{$\sim$\+Unique\+Pointer}}
\index{````~Unique\+Pointer@{$\sim$\+Unique\+Pointer}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{$\sim$\+Unique\+Pointer()}{~UniquePointer()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ {\bf Unique\+Pointer}$<$ T, D $>$\+::$\sim${\bf Unique\+Pointer} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_unique_pointer_a34d23b09547c438f3c6c3a57abc50e15}{}\label{class_unique_pointer_a34d23b09547c438f3c6c3a57abc50e15}
Destroys the \hyperlink{class_unique_pointer}{Unique\+Pointer} and if it was managing a raw pointer then that pointer is deallocated too. \begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}


\subsection{Member Function Documentation}
\index{Unique\+Pointer@{Unique\+Pointer}!data@{data}}
\index{data@{data}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{data() const }{data() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ {\bf pointer} {\bf Unique\+Pointer}$<$ T, D $>$\+::data (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_unique_pointer_ab07e87f9fcbe6cee2f9f2a0e22ce181e}{}\label{class_unique_pointer_ab07e87f9fcbe6cee2f9f2a0e22ce181e}
Access the underlying raw pointer

\begin{DoxyReturn}{Returns}
Returns the underlying raw pointer if one is being managed or a nullptr if not.
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{Unique\+Pointer@{Unique\+Pointer}!get\+Deleter@{get\+Deleter}}
\index{get\+Deleter@{get\+Deleter}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{get\+Deleter() const }{getDeleter() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ {\bf deleter\+\_\+type} {\bf Unique\+Pointer}$<$ T, D $>$\+::get\+Deleter (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_unique_pointer_a8e383d41c2499077dca341c6dbe080f9}{}\label{class_unique_pointer_a8e383d41c2499077dca341c6dbe080f9}
\index{Unique\+Pointer@{Unique\+Pointer}!is\+Null@{is\+Null}}
\index{is\+Null@{is\+Null}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{is\+Null() const }{isNull() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ const bool {\bf Unique\+Pointer}$<$ T, D $>$\+::is\+Null (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_unique_pointer_abce5b65a179dfd63ff572706512aaabb}{}\label{class_unique_pointer_abce5b65a179dfd63ff572706512aaabb}
Checks if a raw pointer is being managed or not

\begin{DoxyReturn}{Returns}
Returns true if a pointer is being managed and false otherwise
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{Unique\+Pointer@{Unique\+Pointer}!operator bool@{operator bool}}
\index{operator bool@{operator bool}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{operator bool() const }{operator bool() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ {\bf Unique\+Pointer}$<$ T, D $>$\+::operator bool (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [explicit]}}\hypertarget{class_unique_pointer_ace903f0cc5fa47eaf3b65e7dc3cc75e2}{}\label{class_unique_pointer_ace903f0cc5fa47eaf3b65e7dc3cc75e2}
\begin{DoxyReturn}{Returns}
Returns true if the \hyperlink{class_unique_pointer}{Unique\+Pointer} is managing a raw pointer and false otherwise. This is useful in \textquotesingle{}if\textquotesingle{} statements. 
\end{DoxyReturn}
\index{Unique\+Pointer@{Unique\+Pointer}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{operator$\ast$()}{operator*()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ {\bf element\+\_\+type} {\bf Unique\+Pointer}$<$ T, D $>$\+::operator$\ast$ (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_unique_pointer_a11af6c570adeb70ac357c2789c5070ab}{}\label{class_unique_pointer_a11af6c570adeb70ac357c2789c5070ab}
Accesses the \hyperlink{class_unique_pointer}{Unique\+Pointer}\textquotesingle{}s managed object

\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{Unique\+Pointer@{Unique\+Pointer}!operator-\/$>$@{operator-\/$>$}}
\index{operator-\/$>$@{operator-\/$>$}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{operator-\/$>$()}{operator->()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ {\bf pointer} {\bf Unique\+Pointer}$<$ T, D $>$\+::operator-\/$>$ (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_unique_pointer_ae978bbeec35cc36f8298ab083d0f68f4}{}\label{class_unique_pointer_ae978bbeec35cc36f8298ab083d0f68f4}
Accesses the \hyperlink{class_unique_pointer}{Unique\+Pointer}\textquotesingle{}s managed object\textquotesingle{}s members

\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{Unique\+Pointer@{Unique\+Pointer}!operator=@{operator=}}
\index{operator=@{operator=}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{operator=(const Unique\+Pointer \&rhs)=delete}{operator=(const UniquePointer &rhs)=delete}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ {\bf Unique\+Pointer}\& {\bf Unique\+Pointer}$<$ T, D $>$\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Unique\+Pointer}$<$ T, D $>$ \&}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [delete]}}\hypertarget{class_unique_pointer_a976ee7dcfde743ee180864fef7e330c9}{}\label{class_unique_pointer_a976ee7dcfde743ee180864fef7e330c9}
Explicitly disabled as a \hyperlink{class_unique_pointer}{Unique\+Pointer} cannot be unique if it is allowable to be assignable

1.\+0.\+0 \index{Unique\+Pointer@{Unique\+Pointer}!release@{release}}
\index{release@{release}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{release()}{release()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ {\bf pointer} {\bf Unique\+Pointer}$<$ T, D $>$\+::release (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_unique_pointer_aa2cef6b7af64bf1b83e897ace29a43c7}{}\label{class_unique_pointer_aa2cef6b7af64bf1b83e897ace29a43c7}
Releases ownership of the underlying raw pointer and returns it. The \hyperlink{class_unique_pointer}{Unique\+Pointer} is now no longer managing the pointer and responsibility for it must be taken by some other entity. The \hyperlink{class_unique_pointer}{Unique\+Pointer} becomes null but is still valid to be used again.

\begin{DoxyReturn}{Returns}
The underlying raw pointer
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{class_unique_pointer_a03be417a8b93e6655888f812322194b0}{reset()}
\end{DoxySeeAlso}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{Unique\+Pointer@{Unique\+Pointer}!reset@{reset}}
\index{reset@{reset}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{reset(pointer p=nullptr)}{reset(pointer p=nullptr)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ void {\bf Unique\+Pointer}$<$ T, D $>$\+::reset (
\begin{DoxyParamCaption}
\item[{{\bf pointer}}]{p = {\ttfamily nullptr}}
\end{DoxyParamCaption}
)}\hypertarget{class_unique_pointer_a03be417a8b93e6655888f812322194b0}{}\label{class_unique_pointer_a03be417a8b93e6655888f812322194b0}
The \hyperlink{class_unique_pointer}{Unique\+Pointer} takes ownership of a new raw pointer deallocating any old pointer that is was previously managing.


\begin{DoxyParams}{Parameters}
{\em p} & The new raw pointer to be managed\\
\hline
\end{DoxyParams}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{Unique\+Pointer@{Unique\+Pointer}!swap@{swap}}
\index{swap@{swap}!Unique\+Pointer@{Unique\+Pointer}}
\subsubsection[{\texorpdfstring{swap(\+Unique\+Pointer \&other)}{swap(UniquePointer &other)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename D = prism\+::\+Unique\+Pointer\+Deleter$<$\+T$>$$>$ void {\bf Unique\+Pointer}$<$ T, D $>$\+::swap (
\begin{DoxyParamCaption}
\item[{{\bf Unique\+Pointer}$<$ T, D $>$ \&}]{other}
\end{DoxyParamCaption}
)}\hypertarget{class_unique_pointer_a1ffb282471b339cbcd7cf3329d3e0af6}{}\label{class_unique_pointer_a1ffb282471b339cbcd7cf3329d3e0af6}
Swaps the contents of two Unique\+Pointers. After the swap, the first \hyperlink{class_unique_pointer}{Unique\+Pointer} will manage the pointer from the second \hyperlink{class_unique_pointer}{Unique\+Pointer} and vice versa.


\begin{DoxyParams}{Parameters}
{\em other} & Another \hyperlink{class_unique_pointer}{Unique\+Pointer} to swap with this \hyperlink{class_unique_pointer}{Unique\+Pointer}\\
\hline
\end{DoxyParams}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{_unique_pointer_8h}{Unique\+Pointer.\+h}\end{DoxyCompactItemize}
