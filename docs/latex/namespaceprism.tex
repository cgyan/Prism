\hypertarget{namespaceprism}{}\section{prism Namespace Reference}
\label{namespaceprism}\index{prism@{prism}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classprism_1_1_array}{Array}
\item 
struct \hyperlink{structprism_1_1bidirectional__iterator__tag}{bidirectional\+\_\+iterator\+\_\+tag}
\item 
class \hyperlink{classprism_1_1_bidirectional_const_iterator}{Bidirectional\+Const\+Iterator}
\item 
class \hyperlink{classprism_1_1_bidirectional_iterator}{Bidirectional\+Iterator}
\item 
class \hyperlink{classprism_1_1_circle}{Circle}
\item 
class \hyperlink{classprism_1_1_exception}{Exception}
\item 
class \hyperlink{classprism_1_1_flag}{Flag}
\item 
class \hyperlink{classprism_1_1_flags}{Flags}
\item 
struct \hyperlink{structprism_1_1forward__iterator__tag}{forward\+\_\+iterator\+\_\+tag}
\item 
class \hyperlink{classprism_1_1_forward_const_iterator}{Forward\+Const\+Iterator}
\item 
class \hyperlink{classprism_1_1_forward_iterator}{Forward\+Iterator}
\item 
class \hyperlink{classprism_1_1_fraction}{Fraction}
\item 
struct \hyperlink{structprism_1_1input__iterator__tag}{input\+\_\+iterator\+\_\+tag}
\item 
struct \hyperlink{structprism_1_1iterator__traits}{iterator\+\_\+traits}
\item 
class \hyperlink{classprism_1_1_list}{List}
\item 
struct \hyperlink{structprism_1_1_list_const_iterator}{List\+Const\+Iterator}
\item 
struct \hyperlink{structprism_1_1_list_iterator}{List\+Iterator}
\item 
class \hyperlink{classprism_1_1_mathf}{Mathf}
\item 
class \hyperlink{classprism_1_1_matrix4}{Matrix4}
\item 
class \hyperlink{classprism_1_1_out_of_bounds_exception}{Out\+Of\+Bounds\+Exception}
\item 
struct \hyperlink{structprism_1_1output__iterator__tag}{output\+\_\+iterator\+\_\+tag}
\item 
class \hyperlink{classprism_1_1_point}{Point}
\item 
class \hyperlink{classprism_1_1_pointf}{Pointf}
\item 
class \hyperlink{classprism_1_1_quaternion}{Quaternion}
\item 
class \hyperlink{classprism_1_1_queue}{Queue}
\item 
struct \hyperlink{structprism_1_1random__access__iterator__tag}{random\+\_\+access\+\_\+iterator\+\_\+tag}
\item 
class \hyperlink{classprism_1_1_random_access_const_iterator}{Random\+Access\+Const\+Iterator}
\item 
class \hyperlink{classprism_1_1_random_access_iterator}{Random\+Access\+Iterator}
\item 
class \hyperlink{classprism_1_1_rect}{Rect}
\item 
class \hyperlink{classprism_1_1_reference_counter}{Reference\+Counter}
\item 
class \hyperlink{classprism_1_1_shared_data}{Shared\+Data}
\item 
class \hyperlink{classprism_1_1_shared_data_pointer}{Shared\+Data\+Pointer}
\item 
class \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}
\item 
class \hyperlink{classprism_1_1_size}{Size}
\item 
class \hyperlink{classprism_1_1_stack}{Stack}
\item 
class \hyperlink{classprism_1_1_string}{String}
\item 
struct \hyperlink{structprism_1_1_string_data}{String\+Data}
\item 
class \hyperlink{classprism_1_1_vector}{Vector}
\item 
class \hyperlink{classprism_1_1_vector2}{Vector2}
\item 
class \hyperlink{classprism_1_1_vector3}{Vector3}
\item 
class \hyperlink{classprism_1_1_vector4}{Vector4}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\bool \hyperlink{namespaceprism_aba366b328f3b6161e6115c16b7153c6d}{all\+\_\+of} (Input\+Iterator first, Input\+Iterator last, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\bool \hyperlink{namespaceprism_a5d0e3ddb9f698759635572f1220ec0ca}{any\+\_\+of} (Input\+Iterator first, Input\+Iterator last, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator $>$ }\\Output\+Iterator \hyperlink{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}{copy} (Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class Predicate $>$ }\\Output\+Iterator \hyperlink{namespaceprism_afbed55ae6769c2d88c125aedc2f3846e}{copy\+\_\+if} (Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator , class T $>$ }\\int \hyperlink{namespaceprism_a024117fc3639cdf6598509edf22f034a}{count} (Input\+Iterator first, Input\+Iterator last, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\int \hyperlink{namespaceprism_af0007d361beae18a930b6249752e509e}{count\+\_\+if} (Input\+Iterator first, Input\+Iterator last, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator1 , class Input\+Iterator2 $>$ }\\bool \hyperlink{namespaceprism_ad3bede9a0f2c648e93677b14c45b1b7b}{equal} (Input\+Iterator1 first, Input\+Iterator1 last, Input\+Iterator2 other\+First)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{fill} (\hyperlink{classprism_1_1_forward_iterator}{Forward\+Iterator} first, \hyperlink{classprism_1_1_forward_iterator}{Forward\+Iterator} last, const T \&value)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_aceb4b9c511a5edb706296b457427b226}{fill\+\_\+n} (\hyperlink{classprism_1_1_forward_iterator}{Forward\+Iterator} first, int size, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class T $>$ }\\Input\+Iterator \hyperlink{namespaceprism_a1b543d9c2862a539cc8b770abda87561}{find} (Input\+Iterator first, Input\+Iterator last, const T \&value)
\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{namespaceprism_a6430516ab4f2e2a7f43323acb6b559d8}{swap} (T \&a, T \&b)
\item 
{\footnotesize template$<$class T $>$ }\\std\+::ostream \& \hyperlink{namespaceprism_a403ca8f79c481a89132691c0fd8c3a06}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_array}{Array}$<$ T $>$ \&array)
\item 
{\footnotesize template$<$class T $>$ }\\std\+::ostream \& \hyperlink{namespaceprism_a50da64555d454821545fe0311fde6a62}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_list}{List}$<$ T $>$ \&list)
\item 
{\footnotesize template$<$typename T $>$ }\\const T \& \hyperlink{namespaceprism_a812456273adfa37979e79f07e731d412}{max} (const T \&a, const T \&b)
\item 
{\footnotesize template$<$typename T $>$ }\\const T \& \hyperlink{namespaceprism_a10aff0aca673fb1837069dd8967e4738}{min} (const T \&a, const T \&b)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_a9df924e4deb059bf1200701c8235410a}{operator!=} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_ad6391c124e006b0e3a3ec67f55e208b0}{operator!=} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const U $\ast$p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_ab8792dbd5cac5678390843bacdb69daa}{operator!=} (const U $\ast$p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_ae53d52e8a36ec7ca58ea1731cc18f1d8}{operator==} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_a2b73e87f080646696ed6b595a3900119}{operator==} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const U $\ast$p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_a1f29b22985dc0ec1fc548a551ce313ed}{operator==} (const U $\ast$p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a0a166bbf645cc854542cc0fc50324670}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_string}{String} \&s)
\item 
const bool \hyperlink{namespaceprism_a0ce1ad6e6392618212d5ab3bebb8e585}{operator==} (const \hyperlink{classprism_1_1_circle}{Circle} \&c1, const \hyperlink{classprism_1_1_circle}{Circle} \&c2)
\item 
const bool \hyperlink{namespaceprism_a58cbf7ef406800002b446a0f1e917745}{operator!=} (const \hyperlink{classprism_1_1_circle}{Circle} \&c1, const \hyperlink{classprism_1_1_circle}{Circle} \&c2)
\item 
const bool \hyperlink{namespaceprism_a8e662d15b162ca76912c491798caefd3}{operator$<$} (const \hyperlink{classprism_1_1_circle}{Circle} \&c1, const \hyperlink{classprism_1_1_circle}{Circle} \&c2)
\item 
const bool \hyperlink{namespaceprism_a671739ac8567654dba563c34af92213f}{operator$>$} (const \hyperlink{classprism_1_1_circle}{Circle} \&c1, const \hyperlink{classprism_1_1_circle}{Circle} \&c2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_aa63d3d39d3fad8fa5c5966cc4f306324}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_circle}{Circle} \&c)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a33537d30f01f996f8a05fc5b1b49ba3b}{operator+} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a34a2f64f209065f753bed62a880b75b6}{operator-\/} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a879d3410d690b5722a9af17297f38fbb}{operator-\/} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a9ae44fb46bb709a5c8f4d592baf65522}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_ab3639f7bd46a54726522dfe406841ea9}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a4073983f089695c40b6fd20d892175f9}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m, const float factor)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_aa2859acb8e8dd6fea8678e14249e561d}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const float $\ast$m2)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a5e83bcd69595728106bed838aeb32f70}{operator$\ast$} (const float $\ast$m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a95ceb3342a808c88d0bb7c1f7e0ef82b}{operator$\ast$} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&v, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a04f1e6e0f84169fce23b236e0312d6a0}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m, const \hyperlink{classprism_1_1_vector3}{Vector3} \&v)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_a5a10d8ea1e63b19d02bd294e4ebabb1b}{operator$\ast$} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&v, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_ad125bd8304d577b6f879fb973f774eb8}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m, const \hyperlink{classprism_1_1_vector4}{Vector4} \&v)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a44373b8bda7131a90d04eef7e455ea6f}{operator$\ast$} (const \hyperlink{classprism_1_1_point}{Point} \&p, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a82522932359d2381607cf1fe0c898011}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m, const \hyperlink{classprism_1_1_point}{Point} \&p)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a517b4bc9b0ccc23f79b744d93b540fa6}{operator/} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m, const float divisor)
\item 
const bool \hyperlink{namespaceprism_a8804ec2ab8dda9441d64e947f05e293c}{operator==} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
const bool \hyperlink{namespaceprism_a4d184994eec61a1511fc936a9facb69a}{operator!=} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_ab65e15b3e601e0570beb49a11610c671}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&matrix)
\item 
std\+::ostream \& \hyperlink{namespaceprism_acb9fe7ab8ef5f1ee0338e3b057624393}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_point}{Point} \&p)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a49e983b5c32c93114583309eda19dc2b}{operator+} (const \hyperlink{classprism_1_1_point}{Point} \&p1, const \hyperlink{classprism_1_1_point}{Point} \&p2)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a505cbd94f024ad80136afe0b751da08a}{operator-\/} (const \hyperlink{classprism_1_1_point}{Point} \&p1, const \hyperlink{classprism_1_1_point}{Point} \&p2)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a40976ce143923309d4c737bb8288d9e5}{operator$\ast$} (const \hyperlink{classprism_1_1_point}{Point} \&p, const int factor)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a96e41c0858ff4149eafa1bc878dabb7c}{operator$\ast$} (const \hyperlink{classprism_1_1_point}{Point} \&p, const float factor)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_aa46a547ddc48425588986b0840d026a4}{operator$\ast$} (const int factor, const \hyperlink{classprism_1_1_point}{Point} \&p)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a1ec2671f1e6c155a79740a8556baecc0}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_point}{Point} \&p)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a5f73aee33931e5b9977da32e50d47c0e}{operator/} (const \hyperlink{classprism_1_1_point}{Point} \&p, const float divisor)
\item 
bool \hyperlink{namespaceprism_a739baa4e75c1ca83624d486eec1d45e9}{operator==} (const \hyperlink{classprism_1_1_point}{Point} \&p1, const \hyperlink{classprism_1_1_point}{Point} \&p2)
\item 
bool \hyperlink{namespaceprism_a75cab41d882d24ca064927f2390ef3a6}{operator!=} (const \hyperlink{classprism_1_1_point}{Point} \&p1, const \hyperlink{classprism_1_1_point}{Point} \&p2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_acad408bf2576dfc62a573cb44aa895fb}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p)
\item 
\hyperlink{classprism_1_1_pointf}{Pointf} \hyperlink{namespaceprism_a64243aa2d4cf6ddb70526aaeda396f82}{operator+} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p1, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p2)
\item 
\hyperlink{classprism_1_1_pointf}{Pointf} \hyperlink{namespaceprism_a435d5c45d873875f2c5092d102eddb78}{operator-\/} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p1, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p2)
\item 
\hyperlink{classprism_1_1_pointf}{Pointf} \hyperlink{namespaceprism_ade1984e58679ef4d8fcdd37726ee6483}{operator$\ast$} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p, const float factor)
\item 
\hyperlink{classprism_1_1_pointf}{Pointf} \hyperlink{namespaceprism_a409aa6b61b79f029d78f6d4c3aba2df5}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p)
\item 
\hyperlink{classprism_1_1_pointf}{Pointf} \hyperlink{namespaceprism_a71504f6dd299e8bc788e07d11d29dc5e}{operator/} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p, const float divisor)
\item 
bool \hyperlink{namespaceprism_a13ab889958edc08eea9a5bea056cd9c1}{operator==} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p1, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p2)
\item 
bool \hyperlink{namespaceprism_ae010d5880eb7bcf5119f006e26bf473f}{operator!=} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p1, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p2)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_ad81bceaddc25922e571b4bf427ffe296}{operator+} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q1, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q2)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_a5eae37b5dc73c544572686f215cea89d}{operator-\/} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q1, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q2)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_ae04c2e5eae2242c58a967086ecad8ff4}{operator-\/} (\hyperlink{classprism_1_1_quaternion}{Quaternion} \&q)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_a74c3eeec91c3a178711b6f05a5487d70}{operator$\ast$} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q1, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q2)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_a45806b1a58ec5aae0db87d399d4d832b}{operator$\ast$} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q, const float factor)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_ad9f03413053b1efa6851344eb39a5982}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_a8aebd3615ba448915f37140515a37b05}{operator$\ast$} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q, const \hyperlink{classprism_1_1_vector3}{Vector3} \&v)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_a2c4c5e120d8c4de9891f2261a50f100e}{operator$\ast$} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q, const \hyperlink{classprism_1_1_vector4}{Vector4} \&v)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_aec648937a53338bcd9879670877d0425}{operator/} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q, const float divisor)
\item 
const bool \hyperlink{namespaceprism_ac4ae112433b9ab32c801cccc9c3f74f0}{operator==} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q1, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q2)
\item 
const bool \hyperlink{namespaceprism_a9e32551f997ae19dc52df146482405c1}{operator!=} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q1, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_ad2beaed7a837821f0abc608cf6ac6c0f}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q)
\item 
const bool \hyperlink{namespaceprism_abe409fa2ef458a2d477ed7845cf4b6a6}{operator==} (const \hyperlink{classprism_1_1_rect}{Rect} \&r1, const \hyperlink{classprism_1_1_rect}{Rect} \&r2)
\item 
const bool \hyperlink{namespaceprism_ad9f46c5ebd3cec844925173aaacbed9f}{operator!=} (const \hyperlink{classprism_1_1_rect}{Rect} \&r1, const \hyperlink{classprism_1_1_rect}{Rect} \&r2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a52fd2a97b66b06ba6e451e1890136ff4}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_rect}{Rect} \&rect)
\item 
const bool \hyperlink{namespaceprism_a2a7baeb09cd2ee29251667ad18a2bd00}{operator==} (const \hyperlink{classprism_1_1_size}{Size} \&s1, const \hyperlink{classprism_1_1_size}{Size} \&s2)
\item 
const bool \hyperlink{namespaceprism_a63ab3c18ecc73e21e7281dbe180e07e8}{operator!=} (const \hyperlink{classprism_1_1_size}{Size} \&s1, const \hyperlink{classprism_1_1_size}{Size} \&s2)
\item 
\hyperlink{classprism_1_1_size}{Size} \hyperlink{namespaceprism_a7141aeb35db81548155e44d60c05530e}{operator+} (const \hyperlink{classprism_1_1_size}{Size} \&s1, const \hyperlink{classprism_1_1_size}{Size} \&s2)
\item 
\hyperlink{classprism_1_1_size}{Size} \hyperlink{namespaceprism_ab170e3ca42d85a6766cbc7950ddfb0c4}{operator-\/} (const \hyperlink{classprism_1_1_size}{Size} \&s1, const \hyperlink{classprism_1_1_size}{Size} \&s2)
\item 
\hyperlink{classprism_1_1_size}{Size} \hyperlink{namespaceprism_a3d8e53ee3208e09e8736a77be3f485c9}{operator$\ast$} (const \hyperlink{classprism_1_1_size}{Size} \&size, const int factor)
\item 
\hyperlink{classprism_1_1_size}{Size} \hyperlink{namespaceprism_acd79758984cccce0dddfb459af65f6e1}{operator$\ast$} (const int factor, const \hyperlink{classprism_1_1_size}{Size} \&size)
\item 
\hyperlink{classprism_1_1_size}{Size} \hyperlink{namespaceprism_ad7e100bd6b1730deaab53d1218e29a67}{operator/} (const \hyperlink{classprism_1_1_size}{Size} \&size, const int factor)
\item 
std\+::ostream \& \hyperlink{namespaceprism_ad6335168e27f481d86ae42da444006d1}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_size}{Size} \&size)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_ae482804c32b466401a9ecdf26bc1e6de}{operator+} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&a, const \hyperlink{classprism_1_1_vector2}{Vector2} \&b)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_a86359a88dc5245847de48575a1f969e8}{operator-\/} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&a, const \hyperlink{classprism_1_1_vector2}{Vector2} \&b)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_a124f1081b3a9bbc441dac9927f8a0fc5}{operator-\/} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&v)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_a6528ec4496096e8ccde186bb01fbeed3}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_vector2}{Vector2} \&v)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_a1de3bc1dbc3fd33f26d580bce3520854}{operator$\ast$} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&v, const float factor)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_aea1ab02785c9d4d5ea560face252b75e}{operator/} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&v, const float divisor)
\item 
const bool \hyperlink{namespaceprism_a311fc983ec89876189643e840d781974}{operator==} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&a, const \hyperlink{classprism_1_1_vector2}{Vector2} \&b)
\item 
const bool \hyperlink{namespaceprism_a7e9d0b027a9e7d9e313affe5af91dabc}{operator!=} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&a, const \hyperlink{classprism_1_1_vector2}{Vector2} \&b)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a4616180b97f4288a3b3e28304efee020}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_vector2}{Vector2} \&v)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a7ac90b31f235390d6feb818e3f88ecf0}{operator+} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&a, const \hyperlink{classprism_1_1_vector3}{Vector3} \&b)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a3beb56b334423e027f1ab185785695f8}{operator-\/} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&a, const \hyperlink{classprism_1_1_vector3}{Vector3} \&b)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a8f7cf835ff415e187e6881169803f502}{operator-\/} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&v)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a429cccc5eee454ba019045afb4a01e93}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_vector3}{Vector3} \&v)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_aa1f2f6de8bf1b584cbb82062a607e167}{operator$\ast$} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&v, const float factor)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a87e022748076586917c38e83430df284}{operator/} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&v, const float divisor)
\item 
const bool \hyperlink{namespaceprism_a2fc2a483f2e3ec622ad2c0ac9699fbcb}{operator==} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&a, const \hyperlink{classprism_1_1_vector3}{Vector3} \&b)
\item 
const bool \hyperlink{namespaceprism_aa752c5d0210902dece31c2fcfc98a824}{operator!=} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&a, const \hyperlink{classprism_1_1_vector3}{Vector3} \&b)
\item 
std\+::ostream \& \hyperlink{namespaceprism_aa7b9367a483153af865552ba486f1196}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_vector3}{Vector3} \&v)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_a4ac9ebc0ce1449793eb8f521c64929a9}{operator+} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&a, const \hyperlink{classprism_1_1_vector4}{Vector4} \&b)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_a038a64f530d1c50bf72cf1a23886ecca}{operator-\/} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&a, const \hyperlink{classprism_1_1_vector4}{Vector4} \&b)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_a147712ae50c37618cbc61f20efe6729f}{operator-\/} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&v)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_aa652a61fe96302693aa0279e832360c7}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_vector4}{Vector4} \&v)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_ab3b4a59d9247143b49db3c2778838895}{operator$\ast$} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&v, const float factor)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_a4aa2b9a75c3d5134fc80cc6afc1be443}{operator/} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&v, const float divisor)
\item 
const bool \hyperlink{namespaceprism_a80bdef743a64c754bf1a2b217c82f60a}{operator==} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&a, const \hyperlink{classprism_1_1_vector4}{Vector4} \&b)
\item 
const bool \hyperlink{namespaceprism_a1ffa413af039c2bff07202dcfce55f05}{operator!=} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&a, const \hyperlink{classprism_1_1_vector4}{Vector4} \&b)
\item 
std\+::ostream \& \hyperlink{namespaceprism_aeb86919d9ba71747d21fbd6e28671692}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_vector4}{Vector4} \&v)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_ac1b5b2765c314b2baa2dba5c57419829}{operator+} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_a2daf470e5f35f8450447deb2634c22c1}{operator-\/} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_ac4f48e3429a86bafcc7c21a2bd6a7ae1}{operator$\ast$} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_a1f5007702b28b447f62c3b9df62f2aa4}{operator$\ast$} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&fraction, const int i)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_af1ff5871f65565a84b886c5013bcd50a}{operator$\ast$} (const int i, const \hyperlink{classprism_1_1_fraction}{Fraction} \&fraction)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_a7ba7b5cc9750f0d6cda50f0cb874da6f}{operator/} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
const bool \hyperlink{namespaceprism_a105ac9995ade66ebb2a039ef90751c7a}{operator$<$} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
const bool \hyperlink{namespaceprism_a7122a7ff43fc6aba9cef9d31fe8c7559}{operator$>$} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
const bool \hyperlink{namespaceprism_a5b9e84008b9eaa99d29d4b74cd150cd8}{operator==} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
const bool \hyperlink{namespaceprism_aea72179b12983e614f72acd2b3cbf0e0}{operator!=} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a9c2d182a77a92e6cba7917dbd58f9d87}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Completely and shamelessly lifted from Qt\textquotesingle{}s Q\+Flag/\+Q\+Flags classes and macros and just renamed without the prepended \textquotesingle{}Q\textquotesingle{}. These classes allow enums to be treated as datatypes when passed to methods. They are also type-\/safe so that the receiving method is expecting the enum and not the basic int equivalent. So print\+Flag(\+Label\+::\+Align\+Left) works whilst print\+Flag(2) doesn\textquotesingle{}t.

For example,

class Label \{ private\+: enum Alignment \{ Align\+Left = 0x1, Align\+Right = 0x2 \} \hyperlink{_flags_8h_aa5aa2c9827ab949836e20999b9a068ec}{P\+R\+I\+S\+M\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+F\+L\+A\+G\+S(\+Align\+Flags, Alignment)} \}

// outside class def \hyperlink{_flags_8h_ae8aabb683a18b872a4449769b82e8e15}{P\+R\+I\+S\+M\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+O\+P\+E\+R\+A\+T\+O\+R\+S\+\_\+\+F\+O\+R\+\_\+\+F\+L\+A\+G\+S(\+Label\+::\+Align\+Flags)}

void print\+Flag(\+Label\+::\+Align\+Flags f) \{ if (f == Label\+::\+Align\+Left) std\+::cout $<$$<$ \char`\"{}\+Align\+Left\char`\"{} $<$$<$ std\+::endl; else if (f == Label\+::\+Align\+Right) std\+::cout $<$$<$ \char`\"{}\+Align\+Right\char`\"{} $<$$<$ std\+::endl; else std\+::cout $<$$<$ f $<$$<$ std\+::endl; \}

int main(int argc, char$\ast$$\ast$ argv) \{ print\+Flag(\+Label\+::\+Align\+Left); \}

A \hyperlink{classprism_1_1_quaternion}{Quaternion} is made up of four components (w, x, y and z) which are a scalar (w) and a 3d vector (x, y and z). It does not suffer from gimbal lock and yet can represent any orientation possible.

Some interesting properties of quaternion multiplication\+: a) it is associative but not commutitive -\/ (ab)c = a(bc) ab != ba

b) the magnitude of a quaternion product equals the product of the individual magnitudes. This is an important concept because when quaternions are of unit length and are multiplied, this guarentees us that the result will itself be a unit quaternion -\/ $\vert$$\vert$ab$\vert$$\vert$ = $\vert$$\vert$a$\vert$$\vert$$\vert$$\vert$b$\vert$$\vert$

c) the inverse of a quaternion product is equal to the product of the individual quaternion inverses in reverse order -\/ (ab).inverse = (b.\+inverse) $\ast$ (a.\+inverse)

Rotating vectors\+: When rotating with a quaternion it is important that the quaternion be normalised i.\+e. be of unit length. This is because otherwise scaling will occur and since we only require rotations from our quaternions this won\textquotesingle{}t do. Rotating a vector using quaternions is done with the following equation\+: v\textquotesingle{} = q $\ast$ v $\ast$ q.\+inverse where vector v is represented as a quaternion.

Concatenating rotational transforms together\+: Multiple quaternion rotations can be applied to a vector in one single action by concatenating the rotational quaternions together and then applying them to the vector using the above equation. For example, to rotate the vector v by quaternion a and then rotating that result by quaternion b would be as follows\+: v\textquotesingle{} = b $\ast$ (a $\ast$ v $\ast$ a.\+inverse) $\ast$ b.\+inverse = (b $\ast$ a) $\ast$ v $\ast$ (b.\+inverse $\ast$ a.\+inverse) = (b $\ast$ a) $\ast$ v $\ast$ (b $\ast$ a).inverse So, rotating by a and then by b is equivalent to the single rotation of the product of ba. 

\subsection{Function Documentation}
\index{prism@{prism}!all\+\_\+of@{all\+\_\+of}}
\index{all\+\_\+of@{all\+\_\+of}!prism@{prism}}
\subsubsection[{\texorpdfstring{all\+\_\+of(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{all_of(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ bool prism\+::all\+\_\+of (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aba366b328f3b6161e6115c16b7153c6d}{}\label{namespaceprism_aba366b328f3b6161e6115c16b7153c6d}
Returns true if {\itshape pred} returns true for all the elements in the range {\itshape }\mbox{[}first,last) or if the range is empty, and false otherwise. \index{prism@{prism}!any\+\_\+of@{any\+\_\+of}}
\index{any\+\_\+of@{any\+\_\+of}!prism@{prism}}
\subsubsection[{\texorpdfstring{any\+\_\+of(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{any_of(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ bool prism\+::any\+\_\+of (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5d0e3ddb9f698759635572f1220ec0ca}{}\label{namespaceprism_a5d0e3ddb9f698759635572f1220ec0ca}
Returns true if {\itshape pred} returns true for any of the elements in the range {\itshape }\mbox{[}first, last\mbox{]}. \index{prism@{prism}!copy@{copy}}
\index{copy@{copy}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First)}{copy(InputIterator first, InputIterator last, OutputIterator otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator $>$ Output\+Iterator prism\+::copy (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}{}\label{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}
Copies the elements in the range {\itshape }\mbox{[}first,last) into the range beginning at {\itshape other\+First}. \index{prism@{prism}!copy\+\_\+if@{copy\+\_\+if}}
\index{copy\+\_\+if@{copy\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Predicate pred)}{copy_if(InputIterator first, InputIterator last, OutputIterator otherFirst, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class Predicate $>$ Output\+Iterator prism\+::copy\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_afbed55ae6769c2d88c125aedc2f3846e}{}\label{namespaceprism_afbed55ae6769c2d88c125aedc2f3846e}
Copies the elements in the range {\itshape }\mbox{[}first,last) for which {\itshape pred} returns true to the range beginning at {\itshape other\+First}. \index{prism@{prism}!count@{count}}
\index{count@{count}!prism@{prism}}
\subsubsection[{\texorpdfstring{count(\+Input\+Iterator first, Input\+Iterator last, const T \&value)}{count(InputIterator first, InputIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class T $>$ int prism\+::count (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a024117fc3639cdf6598509edf22f034a}{}\label{namespaceprism_a024117fc3639cdf6598509edf22f034a}
Returns the number of elements in the range {\itshape }\mbox{[}first,last) that compare equal to {\itshape value}. \index{prism@{prism}!count\+\_\+if@{count\+\_\+if}}
\index{count\+\_\+if@{count\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{count\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{count_if(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ int prism\+::count\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af0007d361beae18a930b6249752e509e}{}\label{namespaceprism_af0007d361beae18a930b6249752e509e}
Returns the number of elements in the range {\itshape }\mbox{[}first,last) for which {\itshape pred} is true. \index{prism@{prism}!equal@{equal}}
\index{equal@{equal}!prism@{prism}}
\subsubsection[{\texorpdfstring{equal(\+Input\+Iterator1 first, Input\+Iterator1 last, Input\+Iterator2 other\+First)}{equal(InputIterator1 first, InputIterator1 last, InputIterator2 otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator1 , class Input\+Iterator2 $>$ bool prism\+::equal (
\begin{DoxyParamCaption}
\item[{Input\+Iterator1}]{first, }
\item[{Input\+Iterator1}]{last, }
\item[{Input\+Iterator2}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad3bede9a0f2c648e93677b14c45b1b7b}{}\label{namespaceprism_ad3bede9a0f2c648e93677b14c45b1b7b}
Compares the elements in the range {\itshape }\mbox{[}first1,last1) with those in the range beginning at {\itshape first2}, and returns true if all of the elements in both ranges match. ~\newline
The elements are compared using operator==. \index{prism@{prism}!fill@{fill}}
\index{fill@{fill}!prism@{prism}}
\subsubsection[{\texorpdfstring{fill(\+Forward\+Iterator first, Forward\+Iterator last, const T \&value)}{fill(ForwardIterator first, ForwardIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::fill (
\begin{DoxyParamCaption}
\item[{{\bf Forward\+Iterator}}]{first, }
\item[{{\bf Forward\+Iterator}}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{}\label{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}
Assigns {\itshape value} to all the elements in the range {\itshape }\mbox{[}first,last). \index{prism@{prism}!fill\+\_\+n@{fill\+\_\+n}}
\index{fill\+\_\+n@{fill\+\_\+n}!prism@{prism}}
\subsubsection[{\texorpdfstring{fill\+\_\+n(\+Forward\+Iterator first, int size, const T \&value)}{fill_n(ForwardIterator first, int size, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::fill\+\_\+n (
\begin{DoxyParamCaption}
\item[{{\bf Forward\+Iterator}}]{first, }
\item[{int}]{size, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aceb4b9c511a5edb706296b457427b226}{}\label{namespaceprism_aceb4b9c511a5edb706296b457427b226}
Assigns {\itshape value} to the first {\itshape n} elements of the sequence pointed by {\itshape first}. \index{prism@{prism}!find@{find}}
\index{find@{find}!prism@{prism}}
\subsubsection[{\texorpdfstring{find(\+Input\+Iterator first, Input\+Iterator last, const T \&value)}{find(InputIterator first, InputIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class T $>$ Input\+Iterator prism\+::find (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1b543d9c2862a539cc8b770abda87561}{}\label{namespaceprism_a1b543d9c2862a539cc8b770abda87561}
Returns an iterator to the first element in the range {\itshape }\mbox{[}first,last) that compares equal to {\itshape value}. If no such element is found, the function returns {\itshape last}. \index{prism@{prism}!max@{max}}
\index{max@{max}!prism@{prism}}
\subsubsection[{\texorpdfstring{max(const T \&a, const T \&b)}{max(const T &a, const T &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ const T\& prism\+::max (
\begin{DoxyParamCaption}
\item[{const T \&}]{a, }
\item[{const T \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a812456273adfa37979e79f07e731d412}{}\label{namespaceprism_a812456273adfa37979e79f07e731d412}
\index{prism@{prism}!min@{min}}
\index{min@{min}!prism@{prism}}
\subsubsection[{\texorpdfstring{min(const T \&a, const T \&b)}{min(const T &a, const T &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ const T\& prism\+::min (
\begin{DoxyParamCaption}
\item[{const T \&}]{a, }
\item[{const T \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a10aff0aca673fb1837069dd8967e4738}{}\label{namespaceprism_a10aff0aca673fb1837069dd8967e4738}
\index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Shared\+Pointer$<$ U $>$ \&p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator!=(const SharedPointer< U > &p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9df924e4deb059bf1200701c8235410a}{}\label{namespaceprism_a9df924e4deb059bf1200701c8235410a}
Returns true if the managed pointers of p1 and p2 do not point to the same data, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Shared\+Pointer$<$ U $>$ \&p1, const U $\ast$p2)}{operator!=(const SharedPointer< U > &p1, const U *p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const U $\ast$}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad6391c124e006b0e3a3ec67f55e208b0}{}\label{namespaceprism_ad6391c124e006b0e3a3ec67f55e208b0}
Returns true if the managed pointer of p1 and the raw pointer p2 do not point to the same data, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const U $\ast$p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator!=(const U *p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const U $\ast$}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab8792dbd5cac5678390843bacdb69daa}{}\label{namespaceprism_ab8792dbd5cac5678390843bacdb69daa}
Returns true if the raw pointer p1 and the managed pointer of p2 do not point to the same data, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Pointf \&p1, const Pointf \&p2)}{operator!=(const Pointf &p1, const Pointf &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p1, }
\item[{const {\bf Pointf} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae010d5880eb7bcf5119f006e26bf473f}{}\label{namespaceprism_ae010d5880eb7bcf5119f006e26bf473f}
Returns true if x or y of p1 and p2 are not equal, false if not \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Size \&s1, const Size \&s2)}{operator!=(const Size &s1, const Size &s2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{s1, }
\item[{const {\bf Size} \&}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a63ab3c18ecc73e21e7281dbe180e07e8}{}\label{namespaceprism_a63ab3c18ecc73e21e7281dbe180e07e8}
Returns true if the widths are equal and the heights are not equal of both \hyperlink{classprism_1_1_size}{Size} objects. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Fraction \&f1, const Fraction \&f2)}{operator!=(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aea72179b12983e614f72acd2b3cbf0e0}{}\label{namespaceprism_aea72179b12983e614f72acd2b3cbf0e0}
Returns true if /em f1 does not equal /em f2 in value, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Point \&p1, const Point \&p2)}{operator!=(const Point &p1, const Point &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p1, }
\item[{const {\bf Point} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a75cab41d882d24ca064927f2390ef3a6}{}\label{namespaceprism_a75cab41d882d24ca064927f2390ef3a6}
Returns true if x or y of p1 and p2 are not equal, false if not \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Vector2 \&a, const Vector2 \&b)}{operator!=(const Vector2 &a, const Vector2 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{a, }
\item[{const {\bf Vector2} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7e9d0b027a9e7d9e313affe5af91dabc}{}\label{namespaceprism_a7e9d0b027a9e7d9e313affe5af91dabc}
Compares the vectors and returns true if a and b are not equal, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Vector4 \&a, const Vector4 \&b)}{operator!=(const Vector4 &a, const Vector4 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{a, }
\item[{const {\bf Vector4} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1ffa413af039c2bff07202dcfce55f05}{}\label{namespaceprism_a1ffa413af039c2bff07202dcfce55f05}
Compares the vectors and returns true if a and b are not equal, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Vector3 \&a, const Vector3 \&b)}{operator!=(const Vector3 &a, const Vector3 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{a, }
\item[{const {\bf Vector3} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa752c5d0210902dece31c2fcfc98a824}{}\label{namespaceprism_aa752c5d0210902dece31c2fcfc98a824}
Compares the vectors and returns true if a and b are not equal, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Quaternion \&q1, const Quaternion \&q2)}{operator!=(const Quaternion &q1, const Quaternion &q2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q1, }
\item[{const {\bf Quaternion} \&}]{q2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9e32551f997ae19dc52df146482405c1}{}\label{namespaceprism_a9e32551f997ae19dc52df146482405c1}
Compares q1 and q2 and returns true if they are not equal, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Circle \&c1, const Circle \&c2)}{operator!=(const Circle &c1, const Circle &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Circle} \&}]{c1, }
\item[{const {\bf Circle} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a58cbf7ef406800002b446a0f1e917745}{}\label{namespaceprism_a58cbf7ef406800002b446a0f1e917745}
\begin{DoxyReturn}{Returns}
Returns true if both circles are not equal, false otherwsie. 
\end{DoxyReturn}
\index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Rect \&r1, const Rect \&r2)}{operator!=(const Rect &r1, const Rect &r2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Rect} \&}]{r1, }
\item[{const {\bf Rect} \&}]{r2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad9f46c5ebd3cec844925173aaacbed9f}{}\label{namespaceprism_ad9f46c5ebd3cec844925173aaacbed9f}
Returns true if the rectangles {\itshape r1} and {\itshape r2} are not equal, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Matrix4 \&m1, const Matrix4 \&m2)}{operator!=(const Matrix4 &m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4d184994eec61a1511fc936a9facb69a}{}\label{namespaceprism_a4d184994eec61a1511fc936a9facb69a}
Compares the elements of the two matrices and returns true if they don\textquotesingle{}t contain the same data, false otherwise. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Fraction \&f1, const Fraction \&f2)}{operator*(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ac4f48e3429a86bafcc7c21a2bd6a7ae1}{}\label{namespaceprism_ac4f48e3429a86bafcc7c21a2bd6a7ae1}
Multiplies /em f1 and /em f2 together and returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. \hyperlink{classprism_1_1_fraction}{Fraction} multiplication is the easiest arithmetical operation. Simply multiply the two numerators together to form the new numerator and multiply the two denominators together to form the new denominator. e.\+g. 2 8 2x8 16 4 --- x --- = --- = --- = --- 5 4 5x4 20 5 \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Fraction \&fraction, const int i)}{operator*(const Fraction &fraction, const int i)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{fraction, }
\item[{const int}]{i}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1f5007702b28b447f62c3b9df62f2aa4}{}\label{namespaceprism_a1f5007702b28b447f62c3b9df62f2aa4}
Multiplies the \hyperlink{classprism_1_1_fraction}{Fraction} /em fraction by the whole number /em i. Returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Pointf \&p, const float factor)}{operator*(const Pointf &p, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pointf} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ade1984e58679ef4d8fcdd37726ee6483}{}\label{namespaceprism_ade1984e58679ef4d8fcdd37726ee6483}
Returns a \hyperlink{classprism_1_1_pointf}{Pointf} object that is formed by multiplying the components of p by the float factor \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Pointf \&p)}{operator*(const float factor, const Pointf &p)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pointf} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Pointf} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a409aa6b61b79f029d78f6d4c3aba2df5}{}\label{namespaceprism_a409aa6b61b79f029d78f6d4c3aba2df5}
\index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const int i, const Fraction \&fraction)}{operator*(const int i, const Fraction &fraction)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const int}]{i, }
\item[{const {\bf Fraction} \&}]{fraction}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af1ff5871f65565a84b886c5013bcd50a}{}\label{namespaceprism_af1ff5871f65565a84b886c5013bcd50a}
Multiplies the whole number /em i by the \hyperlink{classprism_1_1_fraction}{Fraction} /em fraction. Returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Point \&p, const int factor)}{operator*(const Point &p, const int factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p, }
\item[{const int}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a40976ce143923309d4c737bb8288d9e5}{}\label{namespaceprism_a40976ce143923309d4c737bb8288d9e5}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by multiplying the components of p by the int factor \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Point \&p, const float factor)}{operator*(const Point &p, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a96e41c0858ff4149eafa1bc878dabb7c}{}\label{namespaceprism_a96e41c0858ff4149eafa1bc878dabb7c}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by multiplying the components of p by the float factor Note\+: the x and y components are rounded to the nearest integer as they are stored as ints internally. Use \hyperlink{classprism_1_1_pointf}{Pointf} for floating point accuracy instead. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const int factor, const Point \&p)}{operator*(const int factor, const Point &p)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const int}]{factor, }
\item[{const {\bf Point} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa46a547ddc48425588986b0840d026a4}{}\label{namespaceprism_aa46a547ddc48425588986b0840d026a4}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by multiplying the components of p by the int factor \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Point \&p)}{operator*(const float factor, const Point &p)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Point} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1ec2671f1e6c155a79740a8556baecc0}{}\label{namespaceprism_a1ec2671f1e6c155a79740a8556baecc0}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by multiplying the components of p by the float factor Note\+: the x and y components are rounded to the nearest integer as they are stored as ints internally. Use \hyperlink{classprism_1_1_pointf}{Pointf} for floating point accuracy instead. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Size \&size, const int factor)}{operator*(const Size &size, const int factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Size} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{size, }
\item[{const int}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a3d8e53ee3208e09e8736a77be3f485c9}{}\label{namespaceprism_a3d8e53ee3208e09e8736a77be3f485c9}
Multiplies {\itshape size} by {\itshape factor} and returns a new \hyperlink{classprism_1_1_size}{Size} object. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const int factor, const Size \&size)}{operator*(const int factor, const Size &size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Size} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const int}]{factor, }
\item[{const {\bf Size} \&}]{size}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_acd79758984cccce0dddfb459af65f6e1}{}\label{namespaceprism_acd79758984cccce0dddfb459af65f6e1}
Multiplies {\itshape size} by {\itshape factor} and returns a new \hyperlink{classprism_1_1_size}{Size} object. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Vector2 \&v)}{operator*(const float factor, const Vector2 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Vector2} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6528ec4496096e8ccde186bb01fbeed3}{}\label{namespaceprism_a6528ec4496096e8ccde186bb01fbeed3}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Vector2 \&v, const float factor)}{operator*(const Vector2 &v, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{v, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1de3bc1dbc3fd33f26d580bce3520854}{}\label{namespaceprism_a1de3bc1dbc3fd33f26d580bce3520854}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Quaternion \&q1, const Quaternion \&q2)}{operator*(const Quaternion &q1, const Quaternion &q2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q1, }
\item[{const {\bf Quaternion} \&}]{q2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a74c3eeec91c3a178711b6f05a5487d70}{}\label{namespaceprism_a74c3eeec91c3a178711b6f05a5487d70}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the product of q1 and q2. Note\+: quaternion multiplication is associative so a(bc) = (ab)c but is not commutitive so q1q2 does not always equal q2q1. Order matters! \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Vector4 \&v)}{operator*(const float factor, const Vector4 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Vector4} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa652a61fe96302693aa0279e832360c7}{}\label{namespaceprism_aa652a61fe96302693aa0279e832360c7}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Vector4 \&v, const float factor)}{operator*(const Vector4 &v, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{v, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab3b4a59d9247143b49db3c2778838895}{}\label{namespaceprism_ab3b4a59d9247143b49db3c2778838895}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Vector3 \&v)}{operator*(const float factor, const Vector3 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Vector3} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a429cccc5eee454ba019045afb4a01e93}{}\label{namespaceprism_a429cccc5eee454ba019045afb4a01e93}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Quaternion \&q, const float factor)}{operator*(const Quaternion &q, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a45806b1a58ec5aae0db87d399d4d832b}{}\label{namespaceprism_a45806b1a58ec5aae0db87d399d4d832b}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the result of multiplying each component of q by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Vector3 \&v, const float factor)}{operator*(const Vector3 &v, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{v, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa1f2f6de8bf1b584cbb82062a607e167}{}\label{namespaceprism_aa1f2f6de8bf1b584cbb82062a607e167}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Quaternion \&q)}{operator*(const float factor, const Quaternion &q)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Quaternion} \&}]{q}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad9f03413053b1efa6851344eb39a5982}{}\label{namespaceprism_ad9f03413053b1efa6851344eb39a5982}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the result of multiplying each component of q by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Quaternion \&q, const Vector3 \&v)}{operator*(const Quaternion &q, const Vector3 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q, }
\item[{const {\bf Vector3} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8aebd3615ba448915f37140515a37b05}{}\label{namespaceprism_a8aebd3615ba448915f37140515a37b05}
Multiplies a quaternion and vector3 together and returns a quaternion as a result. The vector is just transformed into a quaternion (setting w = 0) and then the two quaternions are multiplied. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Quaternion \&q, const Vector4 \&v)}{operator*(const Quaternion &q, const Vector4 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q, }
\item[{const {\bf Vector4} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2c4c5e120d8c4de9891f2261a50f100e}{}\label{namespaceprism_a2c4c5e120d8c4de9891f2261a50f100e}
Multiplies a quaternion and \hyperlink{classprism_1_1_vector4}{Vector4} together and returns a quaternion as a result. The vector is just transformed into a quaternion and then the two quaternions are multiplied. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m1, const Matrix4 \&m2)}{operator*(const Matrix4 &m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9ae44fb46bb709a5c8f4d592baf65522}{}\label{namespaceprism_a9ae44fb46bb709a5c8f4d592baf65522}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} that is the product of m1 and m2 i.\+e. m1m2 \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Matrix4 \&m)}{operator*(const float factor, const Matrix4 &m)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Matrix4} \&}]{m}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab3639f7bd46a54726522dfe406841ea9}{}\label{namespaceprism_ab3639f7bd46a54726522dfe406841ea9}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} where each component of m is multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m, const float factor)}{operator*(const Matrix4 &m, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4073983f089695c40b6fd20d892175f9}{}\label{namespaceprism_a4073983f089695c40b6fd20d892175f9}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} where each component of m is multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m1, const float $\ast$m2)}{operator*(const Matrix4 &m1, const float *m2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const float $\ast$}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa2859acb8e8dd6fea8678e14249e561d}{}\label{namespaceprism_aa2859acb8e8dd6fea8678e14249e561d}
Returns a \hyperlink{classprism_1_1_matrix4}{Matrix4} that is the result of multiplying a \hyperlink{classprism_1_1_matrix4}{Matrix4} with a float array. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float $\ast$m1, const Matrix4 \&m2)}{operator*(const float *m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float $\ast$}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5e83bcd69595728106bed838aeb32f70}{}\label{namespaceprism_a5e83bcd69595728106bed838aeb32f70}
Returns a \hyperlink{classprism_1_1_matrix4}{Matrix4} that is the result of multiplying a \hyperlink{classprism_1_1_matrix4}{Matrix4} with a float array. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Vector3 \&v, const Matrix4 \&m)}{operator*(const Vector3 &v, const Matrix4 &m)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{v, }
\item[{const {\bf Matrix4} \&}]{m}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a95ceb3342a808c88d0bb7c1f7e0ef82b}{}\label{namespaceprism_a95ceb3342a808c88d0bb7c1f7e0ef82b}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} which has been transformed by the matrix M in the order of vM. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m, const Vector3 \&v)}{operator*(const Matrix4 &m, const Vector3 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m, }
\item[{const {\bf Vector3} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a04f1e6e0f84169fce23b236e0312d6a0}{}\label{namespaceprism_a04f1e6e0f84169fce23b236e0312d6a0}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} which has been transformed by the matrix M in the order of Mv. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Vector4 \&v, const Matrix4 \&m)}{operator*(const Vector4 &v, const Matrix4 &m)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{v, }
\item[{const {\bf Matrix4} \&}]{m}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5a10d8ea1e63b19d02bd294e4ebabb1b}{}\label{namespaceprism_a5a10d8ea1e63b19d02bd294e4ebabb1b}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} which has been transformed by the matrix M in the order of vM. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m, const Vector4 \&v)}{operator*(const Matrix4 &m, const Vector4 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m, }
\item[{const {\bf Vector4} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad125bd8304d577b6f879fb973f774eb8}{}\label{namespaceprism_ad125bd8304d577b6f879fb973f774eb8}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} which has been transformed by the matrix M in the order of Mv. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Point \&p, const Matrix4 \&m)}{operator*(const Point &p, const Matrix4 &m)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p, }
\item[{const {\bf Matrix4} \&}]{m}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a44373b8bda7131a90d04eef7e455ea6f}{}\label{namespaceprism_a44373b8bda7131a90d04eef7e455ea6f}
Returns a \hyperlink{classprism_1_1_point}{Point} which has been transformed by the matrix m in the order of pM \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m, const Point \&p)}{operator*(const Matrix4 &m, const Point &p)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m, }
\item[{const {\bf Point} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a82522932359d2381607cf1fe0c898011}{}\label{namespaceprism_a82522932359d2381607cf1fe0c898011}
Returns a \hyperlink{classprism_1_1_point}{Point} which has been transformed by the matrix M in the order of Mp \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Fraction \&f1, const Fraction \&f2)}{operator+(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ac1b5b2765c314b2baa2dba5c57419829}{}\label{namespaceprism_ac1b5b2765c314b2baa2dba5c57419829}
Adds the fractions /em f1 and /em f2 together and returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. If the two denominators are the same then the two numerators are added together to form the new numerator and the original denominator is kept the same. e.\+g. 1 1 2 --- + --- = --- 4 4 4 If the denominators are different then we alter the fractions in order to make both denominators the same value. We make a whole fraction out of the second fraction\textquotesingle{}s denominator and multiply it by the first fraction. Then make a whole fraction from the first fraction\textquotesingle{}s denominator and multiply it by the second fraction. Now we can simply add together the two numerators and keep the denominator the same. 1 1 $\vert$ 4 1 $\vert$ $\vert$ 1 2 $\vert$ 4 2 6 3 --- + --- = $\vert$--- x ---$\vert$ + $\vert$--- x ---$\vert$ = --- + --- = --- = --- 2 4 $\vert$ 4 2 $\vert$ $\vert$ 4 2 $\vert$ 8 8 8 4 \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Pointf \&p1, const Pointf \&p2)}{operator+(const Pointf &p1, const Pointf &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pointf} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p1, }
\item[{const {\bf Pointf} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a64243aa2d4cf6ddb70526aaeda396f82}{}\label{namespaceprism_a64243aa2d4cf6ddb70526aaeda396f82}
Returns a \hyperlink{classprism_1_1_pointf}{Pointf} object that is the sum of the components of p1 and p2 \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Point \&p1, const Point \&p2)}{operator+(const Point &p1, const Point &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p1, }
\item[{const {\bf Point} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a49e983b5c32c93114583309eda19dc2b}{}\label{namespaceprism_a49e983b5c32c93114583309eda19dc2b}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is the sum of the components of p1 and p2 \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Size \&s1, const Size \&s2)}{operator+(const Size &s1, const Size &s2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Size} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{s1, }
\item[{const {\bf Size} \&}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7141aeb35db81548155e44d60c05530e}{}\label{namespaceprism_a7141aeb35db81548155e44d60c05530e}
Adds {\itshape s1} and {\itshape s2} together and returns a new \hyperlink{classprism_1_1_size}{Size} object. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Vector2 \&a, const Vector2 \&b)}{operator+(const Vector2 &a, const Vector2 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{a, }
\item[{const {\bf Vector2} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae482804c32b466401a9ecdf26bc1e6de}{}\label{namespaceprism_ae482804c32b466401a9ecdf26bc1e6de}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} that is the result of adding the components of vector a and vector b. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Quaternion \&q1, const Quaternion \&q2)}{operator+(const Quaternion &q1, const Quaternion &q2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q1, }
\item[{const {\bf Quaternion} \&}]{q2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad81bceaddc25922e571b4bf427ffe296}{}\label{namespaceprism_ad81bceaddc25922e571b4bf427ffe296}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the sum of q1 and q2 i.\+e. each component of q1 is added to the corresponding component of q2. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Vector4 \&a, const Vector4 \&b)}{operator+(const Vector4 &a, const Vector4 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{a, }
\item[{const {\bf Vector4} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4ac9ebc0ce1449793eb8f521c64929a9}{}\label{namespaceprism_a4ac9ebc0ce1449793eb8f521c64929a9}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} that is the result of adding the components of vector a and vector b. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Vector3 \&a, const Vector3 \&b)}{operator+(const Vector3 &a, const Vector3 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{a, }
\item[{const {\bf Vector3} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7ac90b31f235390d6feb818e3f88ecf0}{}\label{namespaceprism_a7ac90b31f235390d6feb818e3f88ecf0}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} that is the result of adding the components of vector a and vector b. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Matrix4 \&m1, const Matrix4 \&m2)}{operator+(const Matrix4 &m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a33537d30f01f996f8a05fc5b1b49ba3b}{}\label{namespaceprism_a33537d30f01f996f8a05fc5b1b49ba3b}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} which is the sum of m1 and m2. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Fraction \&f1, const Fraction \&f2)}{operator-(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2daf470e5f35f8450447deb2634c22c1}{}\label{namespaceprism_a2daf470e5f35f8450447deb2634c22c1}
Subtracts the fractions /em f1 and /em f2 and returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. If the two denominators are the same then the two numerators are subtracted to form the new numerator and the original denominator is kept the same. e.\+g. 3 1 2 --- -\/ --- = --- 4 4 4 If the denominators are different then we alter the fractions in order to make both denominators the same value. We make a whole fraction out of the second fraction\textquotesingle{}s denominator and multiply it by the first fraction. Then make a whole fraction from the first fraction\textquotesingle{}s denominator and multiply it by the second fraction. Now we can simply subtract the two numerators and keep the denominator the same. 3 1 $\vert$ 2 3 $\vert$ $\vert$ 1 4 $\vert$ 6 4 2 1 --- -\/ --- = $\vert$--- x ---$\vert$ -\/ $\vert$--- x ---$\vert$ = --- -\/ --- = --- = --- 4 2 $\vert$ 2 4 $\vert$ $\vert$ 2 4 $\vert$ 8 8 8 4 \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Pointf \&p1, const Pointf \&p2)}{operator-(const Pointf &p1, const Pointf &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pointf} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p1, }
\item[{const {\bf Pointf} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a435d5c45d873875f2c5092d102eddb78}{}\label{namespaceprism_a435d5c45d873875f2c5092d102eddb78}
Returns a \hyperlink{classprism_1_1_pointf}{Pointf} object that is formed by subtracting the components of p2 from p1 \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Point \&p1, const Point \&p2)}{operator-(const Point &p1, const Point &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p1, }
\item[{const {\bf Point} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a505cbd94f024ad80136afe0b751da08a}{}\label{namespaceprism_a505cbd94f024ad80136afe0b751da08a}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by subtracting the components of p2 from p1 \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Size \&s1, const Size \&s2)}{operator-(const Size &s1, const Size &s2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Size} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{s1, }
\item[{const {\bf Size} \&}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab170e3ca42d85a6766cbc7950ddfb0c4}{}\label{namespaceprism_ab170e3ca42d85a6766cbc7950ddfb0c4}
Subtracts {\itshape s2} from {\itshape s1} and returns a new \hyperlink{classprism_1_1_size}{Size} object. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector2 \&a, const Vector2 \&b)}{operator-(const Vector2 &a, const Vector2 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{a, }
\item[{const {\bf Vector2} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a86359a88dc5245847de48575a1f969e8}{}\label{namespaceprism_a86359a88dc5245847de48575a1f969e8}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} that is the result of subtracting the components of vector b from vector a. Note\+: vector subtraction is not commutitive so a-\/b does not always equal b-\/a \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector2 \&v)}{operator-(const Vector2 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a124f1081b3a9bbc441dac9927f8a0fc5}{}\label{namespaceprism_a124f1081b3a9bbc441dac9927f8a0fc5}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} object where each vector component of v has been negated. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Quaternion \&q1, const Quaternion \&q2)}{operator-(const Quaternion &q1, const Quaternion &q2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q1, }
\item[{const {\bf Quaternion} \&}]{q2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5eae37b5dc73c544572686f215cea89d}{}\label{namespaceprism_a5eae37b5dc73c544572686f215cea89d}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the result of subtracting q2 from q1 i.\+e. each component of q2 is subtracted from the corresponding component of q1. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector4 \&a, const Vector4 \&b)}{operator-(const Vector4 &a, const Vector4 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{a, }
\item[{const {\bf Vector4} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a038a64f530d1c50bf72cf1a23886ecca}{}\label{namespaceprism_a038a64f530d1c50bf72cf1a23886ecca}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} that is the result of subtracting the components of vector b from vector a. Note\+: vector subtraction is not commutitive so a-\/b does not always equal b-\/a \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(\+Quaternion \&q)}{operator-(Quaternion &q)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{{\bf Quaternion} \&}]{q}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae04c2e5eae2242c58a967086ecad8ff4}{}\label{namespaceprism_ae04c2e5eae2242c58a967086ecad8ff4}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} which has had each component of q negated. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector4 \&v)}{operator-(const Vector4 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a147712ae50c37618cbc61f20efe6729f}{}\label{namespaceprism_a147712ae50c37618cbc61f20efe6729f}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} object where each vector component of v has been negated. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector3 \&a, const Vector3 \&b)}{operator-(const Vector3 &a, const Vector3 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{a, }
\item[{const {\bf Vector3} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a3beb56b334423e027f1ab185785695f8}{}\label{namespaceprism_a3beb56b334423e027f1ab185785695f8}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} that is the result of subtracting the components of vector b from vector a. Note\+: vector subtraction is not commutitive so a-\/b does not always equal b-\/a \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector3 \&v)}{operator-(const Vector3 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8f7cf835ff415e187e6881169803f502}{}\label{namespaceprism_a8f7cf835ff415e187e6881169803f502}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} object where each vector component of v has been negated. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Matrix4 \&m1, const Matrix4 \&m2)}{operator-(const Matrix4 &m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a34a2f64f209065f753bed62a880b75b6}{}\label{namespaceprism_a34a2f64f209065f753bed62a880b75b6}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} which is the result of subtracting m2 from m1. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Matrix4 \&m)}{operator-(const Matrix4 &m)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a879d3410d690b5722a9af17297f38fbb}{}\label{namespaceprism_a879d3410d690b5722a9af17297f38fbb}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} where each component of matrix m has been negated (multiplyed by -\/1). \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Pointf \&p, const float divisor)}{operator/(const Pointf &p, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pointf} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a71504f6dd299e8bc788e07d11d29dc5e}{}\label{namespaceprism_a71504f6dd299e8bc788e07d11d29dc5e}
Returns a \hyperlink{classprism_1_1_pointf}{Pointf} object that is formed by dividing the components of p by divisor \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Fraction \&f1, const Fraction \&f2)}{operator/(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7ba7b5cc9750f0d6cda50f0cb874da6f}{}\label{namespaceprism_a7ba7b5cc9750f0d6cda50f0cb874da6f}
Divides /em f1 by /em f2 and returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. \hyperlink{classprism_1_1_fraction}{Fraction} division is achieved by taking the reciprocal of the second fraction and multiplying it against the first fraction. See /em \hyperlink{classprism_1_1_fraction_aab12f13967ca16e8956618f9d0641c31}{Fraction\+::reciprocal()} for more information. 3 2 3 7 21 --- / --- = --- $\ast$ --- = --- 4 7 4 2 8 \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Point \&p, const float divisor)}{operator/(const Point &p, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5f73aee33931e5b9977da32e50d47c0e}{}\label{namespaceprism_a5f73aee33931e5b9977da32e50d47c0e}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by dividing the components of p1 by the components of p2 \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Size \&size, const int factor)}{operator/(const Size &size, const int factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Size} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{size, }
\item[{const int}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad7e100bd6b1730deaab53d1218e29a67}{}\label{namespaceprism_ad7e100bd6b1730deaab53d1218e29a67}
Divides {\itshape size} by {\itshape factor} rounding to integer precision and returns a new \hyperlink{classprism_1_1_size}{Size} object. \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Vector2 \&v, const float divisor)}{operator/(const Vector2 &v, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{v, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aea1ab02785c9d4d5ea560face252b75e}{}\label{namespaceprism_aea1ab02785c9d4d5ea560face252b75e}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} where each component of vector v has been divided by divisor. If divisor is 0 then a zero vector is returned instead. \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Vector4 \&v, const float divisor)}{operator/(const Vector4 &v, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{v, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4aa2b9a75c3d5134fc80cc6afc1be443}{}\label{namespaceprism_a4aa2b9a75c3d5134fc80cc6afc1be443}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} where each component of vector v has been divided by divisor. If divisor is 0 then a zero vector is returned instead. \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Vector3 \&v, const float divisor)}{operator/(const Vector3 &v, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{v, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a87e022748076586917c38e83430df284}{}\label{namespaceprism_a87e022748076586917c38e83430df284}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} where each component of vector v has been divided by divisor. If divisor is 0 then a zero vector is returned instead. \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Quaternion \&q, const float divisor)}{operator/(const Quaternion &q, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aec648937a53338bcd9879670877d0425}{}\label{namespaceprism_aec648937a53338bcd9879670877d0425}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the result of dividing each component of q by divisor. If divisor is 0 then a identity quaternion is returned instead. \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Matrix4 \&m, const float divisor)}{operator/(const Matrix4 &m, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a517b4bc9b0ccc23f79b744d93b540fa6}{}\label{namespaceprism_a517b4bc9b0ccc23f79b744d93b540fa6}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} where each component of matrix m is divided by divisor. If divisor is 0 a new \hyperlink{classprism_1_1_matrix4}{Matrix4} is returned set to the identity matrix instead. \index{prism@{prism}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$(const Fraction \&f1, const Fraction \&f2)}{operator<(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a105ac9995ade66ebb2a039ef90751c7a}{}\label{namespaceprism_a105ac9995ade66ebb2a039ef90751c7a}
Returns true if /em f1 is less than /em f2, false otherwise. \index{prism@{prism}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$(const Circle \&c1, const Circle \&c2)}{operator<(const Circle &c1, const Circle &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Circle} \&}]{c1, }
\item[{const {\bf Circle} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8e662d15b162ca76912c491798caefd3}{}\label{namespaceprism_a8e662d15b162ca76912c491798caefd3}
\begin{DoxyReturn}{Returns}
Returns true if {\itshape c1} has a smaller radius than {\itshape c2}, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Pointf \&p)}{operator<<(std::ostream &out, const Pointf &p)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Pointf} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_acad408bf2576dfc62a573cb44aa895fb}{}\label{namespaceprism_acad408bf2576dfc62a573cb44aa895fb}
Returns an ostream object that allows this object to printed with std\+::cout \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Point \&p)}{operator<<(std::ostream &out, const Point &p)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Point} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_acb9fe7ab8ef5f1ee0338e3b057624393}{}\label{namespaceprism_acb9fe7ab8ef5f1ee0338e3b057624393}
Returns an ostream object that allows this object to printed with std\+::cout \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const String \&s)}{operator<<(std::ostream &out, const String &s)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf String} \&}]{s}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a0a166bbf645cc854542cc0fc50324670}{}\label{namespaceprism_a0a166bbf645cc854542cc0fc50324670}
Allows an instance of \hyperlink{classprism_1_1_string}{String} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Fraction \&f)}{operator<<(std::ostream &out, const Fraction &f)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Fraction} \&}]{f}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9c2d182a77a92e6cba7917dbd58f9d87}{}\label{namespaceprism_a9c2d182a77a92e6cba7917dbd58f9d87}
Allows an instance of \hyperlink{classprism_1_1_fraction}{Fraction} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Size \&size)}{operator<<(std::ostream &out, const Size &size)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Size} \&}]{size}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad6335168e27f481d86ae42da444006d1}{}\label{namespaceprism_ad6335168e27f481d86ae42da444006d1}
Allows an instance of \hyperlink{classprism_1_1_size}{Size} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Vector2 \&v)}{operator<<(std::ostream &out, const Vector2 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Vector2} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4616180b97f4288a3b3e28304efee020}{}\label{namespaceprism_a4616180b97f4288a3b3e28304efee020}
Allows an instance of \hyperlink{classprism_1_1_vector2}{Vector2} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Vector4 \&v)}{operator<<(std::ostream &out, const Vector4 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Vector4} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aeb86919d9ba71747d21fbd6e28671692}{}\label{namespaceprism_aeb86919d9ba71747d21fbd6e28671692}
Allows an instance of \hyperlink{classprism_1_1_vector4}{Vector4} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Vector3 \&v)}{operator<<(std::ostream &out, const Vector3 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Vector3} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa7b9367a483153af865552ba486f1196}{}\label{namespaceprism_aa7b9367a483153af865552ba486f1196}
Allows an instance of \hyperlink{classprism_1_1_vector3}{Vector3} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Quaternion \&q)}{operator<<(std::ostream &out, const Quaternion &q)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Quaternion} \&}]{q}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad2beaed7a837821f0abc608cf6ac6c0f}{}\label{namespaceprism_ad2beaed7a837821f0abc608cf6ac6c0f}
Returns a reference to a stream which allows an instance of \hyperlink{classprism_1_1_quaternion}{Quaternion} to be written to the stream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Array$<$ T $>$ \&array)}{operator<<(std::ostream &out, const Array< T > &array)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Array}$<$ T $>$ \&}]{array}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a403ca8f79c481a89132691c0fd8c3a06}{}\label{namespaceprism_a403ca8f79c481a89132691c0fd8c3a06}
\index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Circle \&c)}{operator<<(std::ostream &out, const Circle &c)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Circle} \&}]{c}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa63d3d39d3fad8fa5c5966cc4f306324}{}\label{namespaceprism_aa63d3d39d3fad8fa5c5966cc4f306324}
Allows an instance of \hyperlink{classprism_1_1_circle}{Circle} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const List$<$ T $>$ \&list)}{operator<<(std::ostream &out, const List< T > &list)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf List}$<$ T $>$ \&}]{list}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a50da64555d454821545fe0311fde6a62}{}\label{namespaceprism_a50da64555d454821545fe0311fde6a62}
Outputs a human-\/friendly summary of {\itshape list} to the stream {\itshape out}. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Rect \&rect)}{operator<<(std::ostream &out, const Rect &rect)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Rect} \&}]{rect}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a52fd2a97b66b06ba6e451e1890136ff4}{}\label{namespaceprism_a52fd2a97b66b06ba6e451e1890136ff4}
Allows an instance of \hyperlink{classprism_1_1_rect}{Rect} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Matrix4 \&matrix)}{operator<<(std::ostream &out, const Matrix4 &matrix)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Matrix4} \&}]{matrix}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab65e15b3e601e0570beb49a11610c671}{}\label{namespaceprism_ab65e15b3e601e0570beb49a11610c671}
Allows an instance of Matrx4x4 to be written to the ostream out and returns a reference to the ostream. i.\+e. std\+::cout $<$$<$ matrix $<$$<$ std\+::endl; \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Pointf \&p1, const Pointf \&p2)}{operator==(const Pointf &p1, const Pointf &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p1, }
\item[{const {\bf Pointf} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a13ab889958edc08eea9a5bea056cd9c1}{}\label{namespaceprism_a13ab889958edc08eea9a5bea056cd9c1}
Returns true if x and y of p1 and p2 are equal, false if not \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Size \&s1, const Size \&s2)}{operator==(const Size &s1, const Size &s2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{s1, }
\item[{const {\bf Size} \&}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2a7baeb09cd2ee29251667ad18a2bd00}{}\label{namespaceprism_a2a7baeb09cd2ee29251667ad18a2bd00}
========================================================== \subsection*{Related non-\/members }

Returns true if the widths are equal and the heights are equal of both \hyperlink{classprism_1_1_size}{Size} objects. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Shared\+Pointer$<$ U $>$ \&p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator==(const SharedPointer< U > &p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae53d52e8a36ec7ca58ea1731cc18f1d8}{}\label{namespaceprism_ae53d52e8a36ec7ca58ea1731cc18f1d8}
Returns true if the managed pointers of p1 and p2 point to the same data, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Shared\+Pointer$<$ U $>$ \&p1, const U $\ast$p2)}{operator==(const SharedPointer< U > &p1, const U *p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const U $\ast$}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2b73e87f080646696ed6b595a3900119}{}\label{namespaceprism_a2b73e87f080646696ed6b595a3900119}
Returns true if the managed pointer of p1 and the raw pointer p2 point to the same data, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Fraction \&f1, const Fraction \&f2)}{operator==(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5b9e84008b9eaa99d29d4b74cd150cd8}{}\label{namespaceprism_a5b9e84008b9eaa99d29d4b74cd150cd8}
Returns true if /em f1 and /em f2 are equal in value. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const U $\ast$p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator==(const U *p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const U $\ast$}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1f29b22985dc0ec1fc548a551ce313ed}{}\label{namespaceprism_a1f29b22985dc0ec1fc548a551ce313ed}
Returns true if the raw pointer p1 and the managed pointer of p2 point to the same data, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Point \&p1, const Point \&p2)}{operator==(const Point &p1, const Point &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p1, }
\item[{const {\bf Point} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a739baa4e75c1ca83624d486eec1d45e9}{}\label{namespaceprism_a739baa4e75c1ca83624d486eec1d45e9}
Returns true if x and y of p1 and p2 are equal, false if not \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Vector2 \&a, const Vector2 \&b)}{operator==(const Vector2 &a, const Vector2 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{a, }
\item[{const {\bf Vector2} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a311fc983ec89876189643e840d781974}{}\label{namespaceprism_a311fc983ec89876189643e840d781974}
Compares the two vectors and if each of the corresponding components are equal in value then true is returned, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Vector4 \&a, const Vector4 \&b)}{operator==(const Vector4 &a, const Vector4 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{a, }
\item[{const {\bf Vector4} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a80bdef743a64c754bf1a2b217c82f60a}{}\label{namespaceprism_a80bdef743a64c754bf1a2b217c82f60a}
Compares the two vectors and if each of the corresponding components are equal in value then true is returned, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Vector3 \&a, const Vector3 \&b)}{operator==(const Vector3 &a, const Vector3 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{a, }
\item[{const {\bf Vector3} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2fc2a483f2e3ec622ad2c0ac9699fbcb}{}\label{namespaceprism_a2fc2a483f2e3ec622ad2c0ac9699fbcb}
Compares the two vectors and if each of the corresponding components are equal in value then true is returned, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Quaternion \&q1, const Quaternion \&q2)}{operator==(const Quaternion &q1, const Quaternion &q2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q1, }
\item[{const {\bf Quaternion} \&}]{q2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ac4ae112433b9ab32c801cccc9c3f74f0}{}\label{namespaceprism_ac4ae112433b9ab32c801cccc9c3f74f0}
Compares q1 and q2 and returns true if they are equal, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Circle \&c1, const Circle \&c2)}{operator==(const Circle &c1, const Circle &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Circle} \&}]{c1, }
\item[{const {\bf Circle} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a0ce1ad6e6392618212d5ab3bebb8e585}{}\label{namespaceprism_a0ce1ad6e6392618212d5ab3bebb8e585}
\begin{DoxyReturn}{Returns}
Returns true if both circles have the same radius and (x,y) centre point, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Rect \&r1, const Rect \&r2)}{operator==(const Rect &r1, const Rect &r2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Rect} \&}]{r1, }
\item[{const {\bf Rect} \&}]{r2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_abe409fa2ef458a2d477ed7845cf4b6a6}{}\label{namespaceprism_abe409fa2ef458a2d477ed7845cf4b6a6}
===================================================================== \subsection*{Related non-\/members }

Returns true if the rectangles {\itshape r1} and {\itshape r2} are equal, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Matrix4 \&m1, const Matrix4 \&m2)}{operator==(const Matrix4 &m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8804ec2ab8dda9441d64e947f05e293c}{}\label{namespaceprism_a8804ec2ab8dda9441d64e947f05e293c}
Compares the elements of the two matrices and returns true if they contain the same data, false otherwise. \index{prism@{prism}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$>$(const Fraction \&f1, const Fraction \&f2)}{operator>(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7122a7ff43fc6aba9cef9d31fe8c7559}{}\label{namespaceprism_a7122a7ff43fc6aba9cef9d31fe8c7559}
Returns true if /em f1 is less than /em f2, false otherwise. \index{prism@{prism}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$>$(const Circle \&c1, const Circle \&c2)}{operator>(const Circle &c1, const Circle &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{const {\bf Circle} \&}]{c1, }
\item[{const {\bf Circle} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a671739ac8567654dba563c34af92213f}{}\label{namespaceprism_a671739ac8567654dba563c34af92213f}
\begin{DoxyReturn}{Returns}
Returns true if {\itshape c1} has a greater radius than {\itshape c2}, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!swap@{swap}}
\index{swap@{swap}!prism@{prism}}
\subsubsection[{\texorpdfstring{swap(\+T \&a, T \&b)}{swap(T &a, T &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ void prism\+::swap (
\begin{DoxyParamCaption}
\item[{T \&}]{a, }
\item[{T \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6430516ab4f2e2a7f43323acb6b559d8}{}\label{namespaceprism_a6430516ab4f2e2a7f43323acb6b559d8}
Exchanges the values of {\itshape a} and {\itshape b}. 