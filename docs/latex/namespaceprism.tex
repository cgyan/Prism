\hypertarget{namespaceprism}{}\section{prism Namespace Reference}
\label{namespaceprism}\index{prism@{prism}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classprism_1_1_abstract_tree}{Abstract\+Tree}
\item 
class \hyperlink{classprism_1_1_allocator}{Allocator}
\item 
struct \hyperlink{structprism_1_1_allocator_traits}{Allocator\+Traits}
\item 
class \hyperlink{classprism_1_1_array}{Array}
\begin{DoxyCompactList}\small\item\em A fixed size sequence based container. \end{DoxyCompactList}\item 
struct \hyperlink{structprism_1_1_associative_iterator}{Associative\+Iterator}
\item 
struct \hyperlink{structprism_1_1bidirectional__iterator__tag}{bidirectional\+\_\+iterator\+\_\+tag}
\item 
class \hyperlink{classprism_1_1_binary_search_tree}{Binary\+Search\+Tree}
\item 
class \hyperlink{classprism_1_1_bitvector}{Bitvector}
\item 
struct \hyperlink{structprism_1_1_b_s_t_data}{B\+S\+T\+Data}
\item 
struct \hyperlink{structprism_1_1_b_s_t_memory}{B\+S\+T\+Memory}
\item 
struct \hyperlink{structprism_1_1_b_s_t_node}{B\+S\+T\+Node}
\item 
class \hyperlink{classprism_1_1_char}{Char}
\item 
class \hyperlink{classprism_1_1_circle}{Circle}
\begin{DoxyCompactList}\small\item\em A class that represents a circle. \end{DoxyCompactList}\item 
struct \hyperlink{structprism_1_1conditional__type}{conditional\+\_\+type}
\item 
struct \hyperlink{structprism_1_1conditional__type_3_01false_00_01_type1_00_01_type2_01_4}{conditional\+\_\+type$<$ false, Type1, Type2 $>$}
\item 
class \hyperlink{classprism_1_1_deque}{Deque}
\item 
struct \hyperlink{structprism_1_1_deque_data}{Deque\+Data}
\item 
struct \hyperlink{structprism_1_1even}{even}
\item 
class \hyperlink{classprism_1_1_exception}{Exception}
\item 
class \hyperlink{classprism_1_1_flag}{Flag}
\item 
class \hyperlink{classprism_1_1_flags}{Flags}
\item 
struct \hyperlink{structprism_1_1forward__iterator__tag}{forward\+\_\+iterator\+\_\+tag}
\item 
class \hyperlink{classprism_1_1_fraction}{Fraction}
\item 
struct \hyperlink{structprism_1_1greater}{greater}
\item 
struct \hyperlink{structprism_1_1input__iterator__tag}{input\+\_\+iterator\+\_\+tag}
\item 
struct \hyperlink{structprism_1_1iterator__traits}{iterator\+\_\+traits}
\item 
struct \hyperlink{structprism_1_1iterator__traits_3_01_t_01_5_01_4}{iterator\+\_\+traits$<$ T $\ast$ $>$}
\item 
struct \hyperlink{structprism_1_1less}{less}
\item 
class \hyperlink{classprism_1_1_list}{List}
\begin{DoxyCompactList}\small\item\em A node-\/based container. \end{DoxyCompactList}\item 
class \hyperlink{classprism_1_1_log_allocator}{Log\+Allocator}
\item 
class \hyperlink{classprism_1_1_map}{Map}
\item 
class \hyperlink{classprism_1_1_mathf}{Mathf}
\item 
class \hyperlink{classprism_1_1_matrix4}{Matrix4}
\item 
class \hyperlink{classprism_1_1_obj}{Obj}
\item 
struct \hyperlink{structprism_1_1odd}{odd}
\item 
class \hyperlink{classprism_1_1_out_of_bounds_exception}{Out\+Of\+Bounds\+Exception}
\item 
struct \hyperlink{structprism_1_1output__iterator__tag}{output\+\_\+iterator\+\_\+tag}
\item 
class \hyperlink{classprism_1_1_overflow_exception}{Overflow\+Exception}
\item 
struct \hyperlink{structprism_1_1pair}{pair}
\item 
class \hyperlink{classprism_1_1_point}{Point}
\item 
class \hyperlink{classprism_1_1_pointf}{Pointf}
\item 
class \hyperlink{classprism_1_1_prism_version}{Prism\+Version}
\item 
class \hyperlink{classprism_1_1_quaternion}{Quaternion}
\item 
class \hyperlink{classprism_1_1_queue}{Queue}
\item 
struct \hyperlink{structprism_1_1random__access__iterator__tag}{random\+\_\+access\+\_\+iterator\+\_\+tag}
\item 
class \hyperlink{classprism_1_1_rect}{Rect}
\item 
class \hyperlink{classprism_1_1_reference_counter}{Reference\+Counter}
\item 
struct \hyperlink{structprism_1_1_sequence_iterator}{Sequence\+Iterator}
\item 
class \hyperlink{classprism_1_1_shared_data}{Shared\+Data}
\item 
class \hyperlink{classprism_1_1_shared_data_pointer}{Shared\+Data\+Pointer}
\item 
class \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}
\item 
class \hyperlink{classprism_1_1_size}{Size}
\item 
class \hyperlink{classprism_1_1_stack}{Stack}
\item 
class \hyperlink{classprism_1_1_string}{String}
\item 
class \hyperlink{classprism_1_1_time}{Time}
\item 
class \hyperlink{classprism_1_1_unequal_size_exception}{Unequal\+Size\+Exception}
\item 
class \hyperlink{classprism_1_1_vector}{Vector}
\item 
class \hyperlink{classprism_1_1_vector2}{Vector2}
\item 
class \hyperlink{classprism_1_1_vector3}{Vector3}
\item 
class \hyperlink{classprism_1_1_vector4}{Vector4}
\item 
struct \hyperlink{structprism_1_1_vector_data}{Vector\+Data}
\item 
class \hyperlink{classprism_1_1_version}{Version}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\Forward\+Iterator \hyperlink{namespaceprism_a82052418345794a13044c15d8e32dd89}{adjacent\+\_\+find} (Forward\+Iterator first, Forward\+Iterator last)
\begin{DoxyCompactList}\small\item\em Finds two consecutive matching elements in a range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class Unary\+Predicate $>$ }\\bool \hyperlink{namespaceprism_ad2de9cb16507b1e1b73597c308cafa6c}{all\+\_\+of} (Input\+Iterator first, Input\+Iterator last, Unary\+Predicate pred)
\begin{DoxyCompactList}\small\item\em Checks if all the elements match a condition in a range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class Unary\+Predicate $>$ }\\bool \hyperlink{namespaceprism_ab06451218f60335b732769b55b683321}{any\+\_\+of} (Input\+Iterator first, Input\+Iterator last, Unary\+Predicate pred)
\begin{DoxyCompactList}\small\item\em Checks if any elements match a condition in a range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator $>$ }\\Output\+Iterator \hyperlink{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}{copy} (Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First)
\begin{DoxyCompactList}\small\item\em Copies the elements from one range to another range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Bidirectional\+Iterator1 , class Bidirectional\+Iterator2 $>$ }\\Bidirectional\+Iterator2 \hyperlink{namespaceprism_a2564c63b76369cc81ff725a56e818046}{copy\+\_\+backward} (Bidirectional\+Iterator1 first, Bidirectional\+Iterator1 last, Bidirectional\+Iterator2 other\+Last)
\begin{DoxyCompactList}\small\item\em Copies a range to another range backwards. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class Unary\+Predicate $>$ }\\Output\+Iterator \hyperlink{namespaceprism_adcd8d05b64877fd3c6d1af2cfe3d3e81}{copy\+\_\+if} (Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Unary\+Predicate pred)
\begin{DoxyCompactList}\small\item\em Copies elements from a range to another range only if they meet a condition. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class Size , class Output\+Iterator $>$ }\\Output\+Iterator \hyperlink{namespaceprism_af907f3f5637d4ec056e9b833b6272953}{copy\+\_\+n} (Input\+Iterator first, \hyperlink{classprism_1_1_size}{Size} n, Output\+Iterator other\+First)
\begin{DoxyCompactList}\small\item\em Copies a specified number of elements from one range to another range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class T $>$ }\\int \hyperlink{namespaceprism_a024117fc3639cdf6598509edf22f034a}{count} (Input\+Iterator first, Input\+Iterator last, const T \&value)
\begin{DoxyCompactList}\small\item\em Counts the number of occurrences of a value in a range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class Unary\+Predicate $>$ }\\int \hyperlink{namespaceprism_a124ac016ee2a8ab3844c9af6daf5b4a6}{count\+\_\+if} (Input\+Iterator first, Input\+Iterator last, Unary\+Predicate pred)
\begin{DoxyCompactList}\small\item\em Counts the number of occurrences of a value that meets a condition in a range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator1 , class Input\+Iterator2 $>$ }\\bool \hyperlink{namespaceprism_ad3bede9a0f2c648e93677b14c45b1b7b}{equal} (Input\+Iterator1 first, Input\+Iterator1 last, Input\+Iterator2 other\+First)
\begin{DoxyCompactList}\small\item\em Compares two ranges for equality. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{fill} (Forward\+Iterator first, Forward\+Iterator last, const T \&value)
\begin{DoxyCompactList}\small\item\em Fills a range with a value. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_aceb4b9c511a5edb706296b457427b226}{fill\+\_\+n} (Forward\+Iterator first, int size, const T \&value)
\begin{DoxyCompactList}\small\item\em Assigns a value to a specified number of elements in a range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class T $>$ }\\Input\+Iterator \hyperlink{namespaceprism_a1b543d9c2862a539cc8b770abda87561}{find} (Input\+Iterator first, Input\+Iterator last, const T \&value)
\begin{DoxyCompactList}\small\item\em Finds a value in a range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class Unary\+Predicate $>$ }\\Input\+Iterator \hyperlink{namespaceprism_a411641547f43e750a186c89bf0dd5a59}{find\+\_\+if} (Input\+Iterator first, Input\+Iterator last, Unary\+Predicate pred)
\begin{DoxyCompactList}\small\item\em Finds the first value in a range for which a predicate returns true. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class T $>$ }\\Input\+Iterator \hyperlink{namespaceprism_a3189014b9fa31e0ef0d1933c6f616618}{find\+\_\+last} (Input\+Iterator first, Input\+Iterator last, const T \&value)
\begin{DoxyCompactList}\small\item\em Finds the last value in a range that matches a specified value. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class Unary\+Function $>$ }\\Unary\+Function \hyperlink{namespaceprism_a9f65de889707907c02a325d8a4ff4aec}{for\+\_\+each} (Input\+Iterator first, Input\+Iterator last, Unary\+Function func)
\begin{DoxyCompactList}\small\item\em Calls a function for each element in a range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\const bool \hyperlink{namespaceprism_acf5efbeb096446c47690b9e8bd2cc01a}{is\+\_\+sorted} (Forward\+Iterator first, Forward\+Iterator last)
\begin{DoxyCompactList}\small\item\em Checks if a range is sorted in ascending order. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Random\+Access\+Iterator $>$ }\\void \hyperlink{namespaceprism_af8e36230e6cb92a41aaca282772a9e6e}{make\+\_\+heap} (Random\+Access\+Iterator first, Random\+Access\+Iterator last)
\begin{DoxyCompactList}\small\item\em Rearranges a range into a heap order. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\const T \& \hyperlink{namespaceprism_a812456273adfa37979e79f07e731d412}{max} (const T \&a, const T \&b)
\begin{DoxyCompactList}\small\item\em Determines which value is greater. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\const T \& \hyperlink{namespaceprism_a10aff0aca673fb1837069dd8967e4738}{min} (const T \&a, const T \&b)
\begin{DoxyCompactList}\small\item\em Determines which value is lesser. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class Unary\+Predicate $>$ }\\bool \hyperlink{namespaceprism_a3c43dafd5926d3dc6ce698ae8938810d}{none\+\_\+of} (Input\+Iterator first, Input\+Iterator last, Unary\+Predicate pred)
\begin{DoxyCompactList}\small\item\em Checks elements in a range to see if they don\textquotesingle{}t match a condition. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\Forward\+Iterator \hyperlink{namespaceprism_aeddd21943bcf811c56f7d9d1bd4784f6}{remove} (Forward\+Iterator first, Forward\+Iterator last, const T \&value)
\begin{DoxyCompactList}\small\item\em Removes all elements that equal a value in a range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ }\\Output\+Iterator \hyperlink{namespaceprism_ab7b6fb407340e51749169560b48fb20c}{remove\+\_\+copy} (Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, const T \&value)
\begin{DoxyCompactList}\small\item\em Copies elements from a range that don\textquotesingle{}t match a value into another range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class Unary\+Predicate $>$ }\\Output\+Iterator \hyperlink{namespaceprism_abfc7da1f951e480a26d58fc098b78844}{remove\+\_\+copy\+\_\+if} (Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Unary\+Predicate pred)
\begin{DoxyCompactList}\small\item\em Copies elements from a range for which a predicate returns false into another range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Forward\+Iterator , class Unary\+Predicate $>$ }\\Forward\+Iterator \hyperlink{namespaceprism_a252483ee5c3c08a0b99b67510371583d}{remove\+\_\+if} (Forward\+Iterator first, Forward\+Iterator last, Unary\+Predicate pred)
\begin{DoxyCompactList}\small\item\em Removes all elements from a range for which a predicate returns true. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_a6156070b98de7130b8c912ae3a6d333f}{replace} (Forward\+Iterator first, Forward\+Iterator last, const T \&old\+Value, const T \&new\+Value)
\begin{DoxyCompactList}\small\item\em Replaces all occurrences of a value with a new value in a range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ }\\Output\+Iterator \hyperlink{namespaceprism_a16d85ecb70d2f216714a0146a057a105}{replace\+\_\+copy} (Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, const T \&old\+Value, const T \&new\+Value)
\begin{DoxyCompactList}\small\item\em Copies the elements from one range to another range replacing one value with another value. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class Unary\+Predicate , class T $>$ }\\Output\+Iterator \hyperlink{namespaceprism_ac48a460cd28a7965f460dfb98e68fa39}{replace\+\_\+copy\+\_\+if} (Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Unary\+Predicate pred, const T \&new\+Value)
\begin{DoxyCompactList}\small\item\em Copies the elements from one range to another range replacing each element that a predicate returns true for with a new value. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Forward\+Iterator , class Unary\+Predicate , class T $>$ }\\void \hyperlink{namespaceprism_a7742cad186e8ce8764ee48ff1fbfd4cf}{replace\+\_\+if} (Forward\+Iterator first, Forward\+Iterator last, Unary\+Predicate pred, const T \&new\+Value)
\begin{DoxyCompactList}\small\item\em Assigns a new value to all elements for which a predicate returns true. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ }\\Forward\+Iterator1 \hyperlink{namespaceprism_a03dbb806369b062fd90909fd826c2ee4}{search} (Forward\+Iterator1 first, Forward\+Iterator1 last, Forward\+Iterator2 other\+First, Forward\+Iterator2 other\+Last)
\begin{DoxyCompactList}\small\item\em Searches a range for a sub-\/range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Bidirectional\+Iterator $>$ }\\void \hyperlink{namespaceprism_aa2955433bd872919cf59580c1a464c93}{sort\+\_\+bubble} (Bidirectional\+Iterator first, Bidirectional\+Iterator last)
\begin{DoxyCompactList}\small\item\em Sorts the elements in a range in ascending order. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Random\+Access\+Iterator $>$ }\\void \hyperlink{namespaceprism_a1e9fe74c5dcee70bf5dd5c89f1234a02}{sort\+\_\+heap} (Random\+Access\+Iterator first, Random\+Access\+Iterator last)
\begin{DoxyCompactList}\small\item\em Sorts the elements in a range in ascending order. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Bidirectional\+Iterator $>$ }\\void \hyperlink{namespaceprism_ad8cbe49b782032932d0da83860e7b368}{sort\+\_\+quicksort} (Bidirectional\+Iterator first, Bidirectional\+Iterator last)
\begin{DoxyCompactList}\small\item\em Sorts the elements in a range in ascending order. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Bidirectional\+Iterator $>$ }\\void \hyperlink{namespaceprism_addfe9ea0146b59b2b16adee4cd2220b9}{sort} (Bidirectional\+Iterator first, Bidirectional\+Iterator last)
\begin{DoxyCompactList}\small\item\em Sorts the elements in a range in ascending order. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{namespaceprism_a6430516ab4f2e2a7f43323acb6b559d8}{swap} (T \&a, T \&b)
\begin{DoxyCompactList}\small\item\em Swaps the values of two variables. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ }\\Forward\+Iterator2 \hyperlink{namespaceprism_a4661f2c0c4dca098c137179b4d93f3dc}{swap\+\_\+ranges} (Forward\+Iterator1 first, Forward\+Iterator1 last, Forward\+Iterator2 other\+First)
\begin{DoxyCompactList}\small\item\em Swaps the elements in two ranges. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_a8234c2c7917f750db94bb068d6fd554e}{uninitialized\+\_\+fill} (Forward\+Iterator first, Forward\+Iterator last, const T \&value)
\begin{DoxyCompactList}\small\item\em Fills an uninitialized range with a value. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_a5485ae7bad862f6ff0ab363ed4697b61}{uninitialized\+\_\+fill\+\_\+n} (Forward\+Iterator first, const int size, const T \&value)
\begin{DoxyCompactList}\small\item\em Fills the first number of elements in an uninitialized range with a value. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ }\\Forward\+Iterator2 \hyperlink{namespaceprism_a5ff56f151fea6e709350a0e9fbdb70a8}{uninitialized\+\_\+copy} (Forward\+Iterator1 first, Forward\+Iterator1 last, Forward\+Iterator2 other\+First)
\begin{DoxyCompactList}\small\item\em Copies a range into an uninitialized range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ }\\Forward\+Iterator2 \hyperlink{namespaceprism_ad1c7d8eb38174ba66d98321b68047e6e}{uninitialized\+\_\+copy\+\_\+n} (Forward\+Iterator1 first, const int size, Forward\+Iterator2 other\+First)
\begin{DoxyCompactList}\small\item\em Copies a number of elements from a range into an uninitialized range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\bool \hyperlink{namespaceprism_a1faf99d35e2cbb2b8c0644aa0b777e9b}{operator==} (const \hyperlink{classprism_1_1_allocator}{Allocator}$<$ T $>$ \&a1, const \hyperlink{classprism_1_1_allocator}{Allocator}$<$ T $>$ \&a2)
\item 
{\footnotesize template$<$typename T , size\+\_\+t size$>$ }\\const bool \hyperlink{namespaceprism_a23cc68e19002deb7797ff9eaa10523db}{operator==} (const \hyperlink{classprism_1_1_array}{Array}$<$ T, size $>$ \&lhs, const \hyperlink{classprism_1_1_array}{Array}$<$ T, size $>$ \&rhs)
\begin{DoxyCompactList}\small\item\em Compares two arrays for equality. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t Size$>$ }\\void \hyperlink{namespaceprism_aff86329b54a13cb753f2c79156f68bb4}{swap} (\hyperlink{classprism_1_1_array}{Array}$<$ T, \hyperlink{classprism_1_1_size}{Size} $>$ \&a, \hyperlink{classprism_1_1_array}{Array}$<$ T, \hyperlink{classprism_1_1_size}{Size} $>$ \&b)
\item 
{\footnotesize template$<$class Node\+Pointer $>$ }\\void \hyperlink{namespaceprism_a3ec96a679831176af1c6f2b7480226e1}{print\+Tree} (Node\+Pointer p, int indent=0)
\item 
{\footnotesize template$<$class Input\+Iterator $>$ }\\void \hyperlink{namespaceprism_a667eee76b54258f4f3530eaa7ef44d69}{advance} (Input\+Iterator \&iterator, const int num\+Steps)
\item 
{\footnotesize template$<$class Container $>$ }\\auto \hyperlink{namespaceprism_a6d7a987672303bcc2aad6eedfa3c97c5}{begin} (Container \&con) -\/$>$ decltype(con.\+begin())
\item 
{\footnotesize template$<$class Container $>$ }\\auto \hyperlink{namespaceprism_a1d797e0ebd535413f23ff6c378bce541}{begin} (const Container \&con) -\/$>$ decltype(con.\+begin())
\item 
{\footnotesize template$<$class T , int Size$>$ }\\T $\ast$ \hyperlink{namespaceprism_a1fa3ae5087a69ca4b87cd0142dd7f4f4}{begin} (T(\&array)\mbox{[}\hyperlink{classprism_1_1_size}{Size}\mbox{]})
\item 
{\footnotesize template$<$class Input\+Iterator $>$ }\\\hyperlink{structprism_1_1iterator__traits}{prism\+::iterator\+\_\+traits}$<$ Input\+Iterator $>$\+::difference\+\_\+type \hyperlink{namespaceprism_ad9a8b01383d77bc9bcd878901af6f8bb}{distance} (Input\+Iterator first, Input\+Iterator last)
\item 
{\footnotesize template$<$class Container $>$ }\\auto \hyperlink{namespaceprism_acd1f6ce5ed6fe400694b77f49270ea36}{end} (Container \&con) -\/$>$ decltype(con.\+end())
\item 
{\footnotesize template$<$class Container $>$ }\\auto \hyperlink{namespaceprism_a81b99f9ade4f7bd30ab1c5a64a20d539}{end} (const Container \&con) -\/$>$ decltype(con.\+end())
\item 
{\footnotesize template$<$class T , int Size$>$ }\\T $\ast$ \hyperlink{namespaceprism_a9b7ee229aa856b527057b2abdf6cf144}{end} (T(\&array)\mbox{[}\hyperlink{classprism_1_1_size}{Size}\mbox{]})
\item 
{\footnotesize template$<$class Input\+Iterator , class Container $>$ }\\const bool \hyperlink{namespaceprism_ad56900cb33be6d15ac27a7c61bad2ce6}{has\+\_\+next} (Input\+Iterator \&it, Container \&con)
\item 
{\footnotesize template$<$class Input\+Iterator , class Container $>$ }\\const bool \hyperlink{namespaceprism_af20b814018d65b46e6d08eb450c176c9}{has\+\_\+previous} (Input\+Iterator \&it, Container \&con)
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\Forward\+Iterator \hyperlink{namespaceprism_a16771cef03b7354150e188f4ce10f6b1}{next} (Forward\+Iterator it, int num\+Steps=1)
\item 
{\footnotesize template$<$class Bidirectional\+Iterator $>$ }\\Bidirectional\+Iterator \hyperlink{namespaceprism_a8370841f58d9898247afa42c49a7658d}{previous} (Bidirectional\+Iterator it, int num\+Steps=1)
\item 
{\footnotesize template$<$class Node\+Pointer $>$ }\\Node\+Pointer \hyperlink{namespaceprism_a8aab2862319b55b02ddcb6b9659b3699}{minimum\+Node\+In\+Sub\+Tree} (Node\+Pointer node)
\item 
{\footnotesize template$<$class Node\+Pointer $>$ }\\Node\+Pointer \hyperlink{namespaceprism_a6db5694fde99b39da76f51463f300c4a}{maximum\+Node\+In\+Sub\+Tree} (Node\+Pointer node)
\item 
{\footnotesize template$<$class T $>$ }\\bool \hyperlink{namespaceprism_a7f163cf0ef281768da60b400045aa8d8}{operator==} (const \hyperlink{classprism_1_1_log_allocator}{Log\+Allocator}$<$ T $>$ \&a1, const \hyperlink{classprism_1_1_log_allocator}{Log\+Allocator}$<$ T $>$ \&a2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_a9df924e4deb059bf1200701c8235410a}{operator!=} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_ad6391c124e006b0e3a3ec67f55e208b0}{operator!=} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const U $\ast$p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_ab8792dbd5cac5678390843bacdb69daa}{operator!=} (const U $\ast$p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_ae53d52e8a36ec7ca58ea1731cc18f1d8}{operator==} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_a2b73e87f080646696ed6b595a3900119}{operator==} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const U $\ast$p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_a1f29b22985dc0ec1fc548a551ce313ed}{operator==} (const U $\ast$p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Completely and shamefully lifted from Qt\textquotesingle{}s Q\+Flag/\+Q\+Flags classes and macros and just renamed without the prepended \textquotesingle{}Q\textquotesingle{}. These classes allow enums to be treated as datatypes when passed to methods. They are also type-\/safe so that the receiving method is expecting the enum and not the basic int equivalent. So print\+Flag(\+Label\+::\+Align\+Left) works whilst print\+Flag(2) doesn\textquotesingle{}t.

For example,

class Label \{ private\+: enum Alignment \{ Align\+Left = 0x1, Align\+Right = 0x2 \} \hyperlink{_flags_8h_aa5aa2c9827ab949836e20999b9a068ec}{P\+R\+I\+S\+M\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+F\+L\+A\+G\+S(\+Align\+Flags, Alignment)} \}

// outside class def \hyperlink{_flags_8h_ae8aabb683a18b872a4449769b82e8e15}{P\+R\+I\+S\+M\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+O\+P\+E\+R\+A\+T\+O\+R\+S\+\_\+\+F\+O\+R\+\_\+\+F\+L\+A\+G\+S(\+Label\+::\+Align\+Flags)}

void print\+Flag(\+Label\+::\+Align\+Flags f) \{ if (f == Label\+::\+Align\+Left) std\+::cout $<$$<$ \char`\"{}\+Align\+Left\char`\"{} $<$$<$ std\+::endl; else if (f == Label\+::\+Align\+Right) std\+::cout $<$$<$ \char`\"{}\+Align\+Right\char`\"{} $<$$<$ std\+::endl; else std\+::cout $<$$<$ f $<$$<$ std\+::endl; \}

int main(int argc, char$\ast$$\ast$ argv) \{ print\+Flag(\+Label\+::\+Align\+Left); \}

todo

functions to add\+: -- move constructor and move assignment operator -- T\+Allocator allocator(); -- \hyperlink{namespaceprism_addfe9ea0146b59b2b16adee4cd2220b9}{prism\+::sort()} needs a specialization for \hyperlink{classprism_1_1_list}{List}

This simple class extends the \hyperlink{classprism_1_1_allocator}{Allocator} class by logging each memory allocation and deallocation by storing the newly allocated pointer in a \hyperlink{classprism_1_1_vector}{Vector} on allocation and removes it when the pointer is deallocated. In theory, at the end of the Logger\+Allocator\textquotesingle{}s lifetime the \hyperlink{classprism_1_1_vector}{Vector} should be empty as all pointers should be deallocated. If there are still pointers in the vector then an error message is printed to the console.

A \hyperlink{classprism_1_1_quaternion}{Quaternion} is made up of four components (w, x, y and z) which are a scalar (w) and a 3d vector (x, y and z). It does not suffer from gimbal lock and yet can represent any orientation possible.

Some interesting properties of quaternion multiplication\+: a) it is associative but not commutitive -\/ (ab)c = a(bc) ab != ba

b) the magnitude of a quaternion product equals the product of the individual magnitudes. This is an important concept because when quaternions are of unit length and are multiplied, this guarentees us that the result will itself be a unit quaternion -\/ $\vert$$\vert$ab$\vert$$\vert$ = $\vert$$\vert$a$\vert$$\vert$$\vert$$\vert$b$\vert$$\vert$

c) the inverse of a quaternion product is equal to the product of the individual quaternion inverses in reverse order -\/ (ab).inverse = (b.\+inverse) $\ast$ (a.\+inverse)

Rotating vectors\+: When rotating with a quaternion it is important that the quaternion be normalised i.\+e. be of unit length. This is because otherwise scaling will occur and since we only require rotations from our quaternions this won\textquotesingle{}t do. Rotating a vector using quaternions is done with the following equation\+: v\textquotesingle{} = q $\ast$ v $\ast$ q.\+inverse where vector v is represented as a quaternion.

Concatenating rotational transforms together\+: Multiple quaternion rotations can be applied to a vector in one single action by concatenating the rotational quaternions together and then applying them to the vector using the above equation. For example, to rotate the vector v by quaternion a and then rotating that result by quaternion b would be as follows\+: v\textquotesingle{} = b $\ast$ (a $\ast$ v $\ast$ a.\+inverse) $\ast$ b.\+inverse = (b $\ast$ a) $\ast$ v $\ast$ (b.\+inverse $\ast$ a.\+inverse) = (b $\ast$ a) $\ast$ v $\ast$ (b $\ast$ a).inverse So, rotating by a and then by b is equivalent to the single rotation of the product of ba. 

\subsection{Function Documentation}
\index{prism@{prism}!adjacent\+\_\+find@{adjacent\+\_\+find}}
\index{adjacent\+\_\+find@{adjacent\+\_\+find}!prism@{prism}}
\subsubsection[{\texorpdfstring{adjacent\+\_\+find(\+Forward\+Iterator first, Forward\+Iterator last)}{adjacent_find(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ Forward\+Iterator prism\+::adjacent\+\_\+find (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a82052418345794a13044c15d8e32dd89}{}\label{namespaceprism_a82052418345794a13044c15d8e32dd89}


Finds two consecutive matching elements in a range. 

Searches the range {\itshape }\mbox{[}first,last\mbox{]} for the first occurrence of two consecutive elements that match.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & The iterator pointing to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & The iterator pointing to the end of the range\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns an iterator to the first of these two elements, or {\itshape last} if no such pair is found.
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!advance@{advance}}
\index{advance@{advance}!prism@{prism}}
\subsubsection[{\texorpdfstring{advance(\+Input\+Iterator \&iterator, const int num\+Steps)}{advance(InputIterator &iterator, const int numSteps)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator $>$ void prism\+::advance (
\begin{DoxyParamCaption}
\item[{Input\+Iterator \&}]{iterator, }
\item[{const int}]{num\+Steps}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a667eee76b54258f4f3530eaa7ef44d69}{}\label{namespaceprism_a667eee76b54258f4f3530eaa7ef44d69}
Moves the iterator forwards by num\+Steps (or backwards if num\+Steps is negative). \index{prism@{prism}!all\+\_\+of@{all\+\_\+of}}
\index{all\+\_\+of@{all\+\_\+of}!prism@{prism}}
\subsubsection[{\texorpdfstring{all\+\_\+of(\+Input\+Iterator first, Input\+Iterator last, Unary\+Predicate pred)}{all_of(InputIterator first, InputIterator last, UnaryPredicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Unary\+Predicate $>$ bool prism\+::all\+\_\+of (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Unary\+Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad2de9cb16507b1e1b73597c308cafa6c}{}\label{namespaceprism_ad2de9cb16507b1e1b73597c308cafa6c}


Checks if all the elements match a condition in a range. 

Each element in the range {\itshape }\mbox{[}first,last\mbox{]} is matched against the condition in {\itshape pred}.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator pointing to the first element in the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator pointing to the position after the last element in the range \\
\hline
\mbox{\tt in}  & {\em pred} & A unary function that returns true or false\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns true if the predicate returns true for all of the elements in the range or false otherwise.
\end{DoxyReturn}
Example usage 
\begin{DoxyCode}
\textcolor{keywordtype}{bool} isEven(\textcolor{keyword}{const} \textcolor{keywordtype}{int} n) \{ \textcolor{keywordflow}{return} n % 2 == 0; \}

\textcolor{keywordtype}{int} a[5] = \{2,4,6,8,10\};
\textcolor{keywordtype}{bool} allEven = \hyperlink{namespaceprism_ad2de9cb16507b1e1b73597c308cafa6c}{prism::all\_of}(a, a+5, isEven);
cout << allEven;

output: 1
\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\hyperlink{namespaceprism_ab06451218f60335b732769b55b683321}{any\+\_\+of()}
\end{DoxySeeAlso}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!any\+\_\+of@{any\+\_\+of}}
\index{any\+\_\+of@{any\+\_\+of}!prism@{prism}}
\subsubsection[{\texorpdfstring{any\+\_\+of(\+Input\+Iterator first, Input\+Iterator last, Unary\+Predicate pred)}{any_of(InputIterator first, InputIterator last, UnaryPredicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Unary\+Predicate $>$ bool prism\+::any\+\_\+of (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Unary\+Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab06451218f60335b732769b55b683321}{}\label{namespaceprism_ab06451218f60335b732769b55b683321}


Checks if any elements match a condition in a range. 

Each element in the range {\itshape }\mbox{[}first,last\mbox{]} is checked against the condition in {\itshape {\bfseries pred}} until one of them matches.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator pointing to the first element in the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator pointing to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em pred} & A unary function that returns true or false\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns true if any of the elements match the condition in {\itshape pred} or false otherwise
\end{DoxyReturn}
Example usage 
\begin{DoxyCode}
\textcolor{keywordtype}{bool} isEven(\textcolor{keyword}{const} \textcolor{keywordtype}{int} n) \{ \textcolor{keywordflow}{return} n % 2 == 0; \}

\textcolor{keywordtype}{int} a[5] = \{1,3,5,8,9\};
\textcolor{keywordtype}{bool} anyEven = \hyperlink{namespaceprism_ab06451218f60335b732769b55b683321}{prism::any\_of}(a, a+5, isEven);
cout << anyEven;

output: 1
\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\hyperlink{namespaceprism_ad2de9cb16507b1e1b73597c308cafa6c}{all\+\_\+of()}
\end{DoxySeeAlso}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!begin@{begin}}
\index{begin@{begin}!prism@{prism}}
\subsubsection[{\texorpdfstring{begin(\+Container \&con) -\/$>$ decltype(con.\+begin())}{begin(Container &con) -> decltype(con.begin())}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Container $>$ auto prism\+::begin (
\begin{DoxyParamCaption}
\item[{Container \&}]{con}
\end{DoxyParamCaption}
) -\/$>$  decltype(con.\+begin())}\hypertarget{namespaceprism_a6d7a987672303bcc2aad6eedfa3c97c5}{}\label{namespaceprism_a6d7a987672303bcc2aad6eedfa3c97c5}
Returns an iterator pointing to the beginning of {\itshape con}. \index{prism@{prism}!begin@{begin}}
\index{begin@{begin}!prism@{prism}}
\subsubsection[{\texorpdfstring{begin(const Container \&con) -\/$>$ decltype(con.\+begin())}{begin(const Container &con) -> decltype(con.begin())}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Container $>$ auto prism\+::begin (
\begin{DoxyParamCaption}
\item[{const Container \&}]{con}
\end{DoxyParamCaption}
) -\/$>$  decltype(con.\+begin())}\hypertarget{namespaceprism_a1d797e0ebd535413f23ff6c378bce541}{}\label{namespaceprism_a1d797e0ebd535413f23ff6c378bce541}
Returns a const iterator pointing to the beginning of {\itshape con}. \index{prism@{prism}!begin@{begin}}
\index{begin@{begin}!prism@{prism}}
\subsubsection[{\texorpdfstring{begin(\+T(\&array)[Size])}{begin(T(&array)[Size])}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , int Size$>$ T$\ast$ prism\+::begin (
\begin{DoxyParamCaption}
\item[{T(\&)}]{array\mbox{[}\+Size\mbox{]}}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1fa3ae5087a69ca4b87cd0142dd7f4f4}{}\label{namespaceprism_a1fa3ae5087a69ca4b87cd0142dd7f4f4}
\hyperlink{classprism_1_1_array}{Array} specialization. \index{prism@{prism}!copy@{copy}}
\index{copy@{copy}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First)}{copy(InputIterator first, InputIterator last, OutputIterator otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator $>$ Output\+Iterator prism\+::copy (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}{}\label{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}


Copies the elements from one range to another range. 

Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} and places them at the range beginning from {\itshape other\+First} 

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator pointing to the first element in the range to be copied \\
\hline
\mbox{\tt in}  & {\em last} & An iterator pointing to the position after the last element in the range to be copied \\
\hline
\mbox{\tt in}  & {\em other\+First} & An iterator pointing to the start of the range where the copies will be placed.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator pointing to the end of the destination range
\end{DoxyReturn}

\begin{DoxyCode}
\textcolor{keywordtype}{int} a[5] = \{1,2,3,4,5\};
\textcolor{keywordtype}{int} b[5];

\hyperlink{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}{prism::copy}(a, a+5, b);
\textcolor{comment}{// b == [1,2,3,4,5]}
\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\hyperlink{namespaceprism_a2564c63b76369cc81ff725a56e818046}{copy\+\_\+backward()}, \hyperlink{namespaceprism_adcd8d05b64877fd3c6d1af2cfe3d3e81}{copy\+\_\+if()}, \hyperlink{namespaceprism_af907f3f5637d4ec056e9b833b6272953}{copy\+\_\+n()}
\end{DoxySeeAlso}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!copy\+\_\+backward@{copy\+\_\+backward}}
\index{copy\+\_\+backward@{copy\+\_\+backward}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy\+\_\+backward(\+Bidirectional\+Iterator1 first, Bidirectional\+Iterator1 last, Bidirectional\+Iterator2 other\+Last)}{copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 otherLast)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Bidirectional\+Iterator1 , class Bidirectional\+Iterator2 $>$ Bidirectional\+Iterator2 prism\+::copy\+\_\+backward (
\begin{DoxyParamCaption}
\item[{Bidirectional\+Iterator1}]{first, }
\item[{Bidirectional\+Iterator1}]{last, }
\item[{Bidirectional\+Iterator2}]{other\+Last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2564c63b76369cc81ff725a56e818046}{}\label{namespaceprism_a2564c63b76369cc81ff725a56e818046}


Copies a range to another range backwards. 

Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} starting from {\itshape last} to the range ending at {\itshape other\+Last}. The elements copied are between {\itshape first} and {\itshape last}, including {\itshape first} but not {\itshape last}. {\itshape other\+Last} should point to the past-\/the-\/end position of the destination range.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range to be copied \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position after the last element to be copied \\
\hline
\mbox{\tt in}  & {\em other\+Last} & An iterator that points to the position after where the copied range should finish\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the first element of the copied range in the destination range
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!copy\+\_\+if@{copy\+\_\+if}}
\index{copy\+\_\+if@{copy\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Unary\+Predicate pred)}{copy_if(InputIterator first, InputIterator last, OutputIterator otherFirst, UnaryPredicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class Unary\+Predicate $>$ Output\+Iterator prism\+::copy\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{Unary\+Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_adcd8d05b64877fd3c6d1af2cfe3d3e81}{}\label{namespaceprism_adcd8d05b64877fd3c6d1af2cfe3d3e81}


Copies elements from a range to another range only if they meet a condition. 

Each element from the range {\itshape }\mbox{[}first,last\mbox{]} is matched against the condition in {\itshape pred} which if true the element is copied across to the range beginning at {\itshape other\+First}.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the first element in the range to be copied from \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position after the last element in the range to be copied from \\
\hline
\mbox{\tt in}  & {\em other\+First} & An iterator that points to the start of the destination range \\
\hline
\mbox{\tt in}  & {\em pred} & A unary function that returns true or false\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that is one position past the last inserted element in the destination range
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!copy\+\_\+n@{copy\+\_\+n}}
\index{copy\+\_\+n@{copy\+\_\+n}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy\+\_\+n(\+Input\+Iterator first, Size n, Output\+Iterator other\+First)}{copy_n(InputIterator first, Size n, OutputIterator otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Size , class Output\+Iterator $>$ Output\+Iterator prism\+::copy\+\_\+n (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{{\bf Size}}]{n, }
\item[{Output\+Iterator}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af907f3f5637d4ec056e9b833b6272953}{}\label{namespaceprism_af907f3f5637d4ec056e9b833b6272953}


Copies a specified number of elements from one range to another range. 

Copies {\itshape n} amount of elements from the range beginning at {\itshape first} to the range beginning at {\itshape other\+First} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the first element in the range to be copied \\
\hline
\mbox{\tt in}  & {\em n} & The number of elements to be copied \\
\hline
\mbox{\tt in}  & {\em other\+First} & An iterator that points to the start of the destination range\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that is one position past the last inserted element in the destination range
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!count@{count}}
\index{count@{count}!prism@{prism}}
\subsubsection[{\texorpdfstring{count(\+Input\+Iterator first, Input\+Iterator last, const T \&value)}{count(InputIterator first, InputIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class T $>$ int prism\+::count (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a024117fc3639cdf6598509edf22f034a}{}\label{namespaceprism_a024117fc3639cdf6598509edf22f034a}


Counts the number of occurrences of a value in a range. 

Searches the range {\itshape }\mbox{[}first,last\mbox{]} and counts the number of occurrences of elements matching {\itshape value}.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range to be searched \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position after the last element to be searched \\
\hline
\mbox{\tt in}  & {\em value} & The value that each element will be compared to\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of times that {\itshape value} appears in the range
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!count\+\_\+if@{count\+\_\+if}}
\index{count\+\_\+if@{count\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{count\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Unary\+Predicate pred)}{count_if(InputIterator first, InputIterator last, UnaryPredicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Unary\+Predicate $>$ int prism\+::count\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Unary\+Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a124ac016ee2a8ab3844c9af6daf5b4a6}{}\label{namespaceprism_a124ac016ee2a8ab3844c9af6daf5b4a6}


Counts the number of occurrences of a value that meets a condition in a range. 

Iterates through the range {\itshape }\mbox{[}first,last\mbox{]} and compares each element to the predicate {\itshape pred}. If {\itshape pred} returns true for that element then it will be counted.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range to be counted \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position after the last element of the range to be counted \\
\hline
\mbox{\tt in}  & {\em pred} & A unary function that returns true or false\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of elements that match the condition in {\itshape pred} 
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!distance@{distance}}
\index{distance@{distance}!prism@{prism}}
\subsubsection[{\texorpdfstring{distance(\+Input\+Iterator first, Input\+Iterator last)}{distance(InputIterator first, InputIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator $>$ {\bf prism\+::iterator\+\_\+traits}$<$Input\+Iterator$>$\+::difference\+\_\+type prism\+::distance (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad9a8b01383d77bc9bcd878901af6f8bb}{}\label{namespaceprism_ad9a8b01383d77bc9bcd878901af6f8bb}
Returns the distance between two iterators. \index{prism@{prism}!end@{end}}
\index{end@{end}!prism@{prism}}
\subsubsection[{\texorpdfstring{end(\+Container \&con) -\/$>$ decltype(con.\+end())}{end(Container &con) -> decltype(con.end())}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Container $>$ auto prism\+::end (
\begin{DoxyParamCaption}
\item[{Container \&}]{con}
\end{DoxyParamCaption}
) -\/$>$  decltype(con.\+end())}\hypertarget{namespaceprism_acd1f6ce5ed6fe400694b77f49270ea36}{}\label{namespaceprism_acd1f6ce5ed6fe400694b77f49270ea36}
Returns an iterator pointing to the end of {\itshape con}. \index{prism@{prism}!end@{end}}
\index{end@{end}!prism@{prism}}
\subsubsection[{\texorpdfstring{end(const Container \&con) -\/$>$ decltype(con.\+end())}{end(const Container &con) -> decltype(con.end())}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Container $>$ auto prism\+::end (
\begin{DoxyParamCaption}
\item[{const Container \&}]{con}
\end{DoxyParamCaption}
) -\/$>$  decltype(con.\+end())}\hypertarget{namespaceprism_a81b99f9ade4f7bd30ab1c5a64a20d539}{}\label{namespaceprism_a81b99f9ade4f7bd30ab1c5a64a20d539}
Returns a const iterator pointing to the end of {\itshape con}. \index{prism@{prism}!end@{end}}
\index{end@{end}!prism@{prism}}
\subsubsection[{\texorpdfstring{end(\+T(\&array)[Size])}{end(T(&array)[Size])}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , int Size$>$ T$\ast$ prism\+::end (
\begin{DoxyParamCaption}
\item[{T(\&)}]{array\mbox{[}\+Size\mbox{]}}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9b7ee229aa856b527057b2abdf6cf144}{}\label{namespaceprism_a9b7ee229aa856b527057b2abdf6cf144}
\hyperlink{classprism_1_1_array}{Array} specialization. \index{prism@{prism}!equal@{equal}}
\index{equal@{equal}!prism@{prism}}
\subsubsection[{\texorpdfstring{equal(\+Input\+Iterator1 first, Input\+Iterator1 last, Input\+Iterator2 other\+First)}{equal(InputIterator1 first, InputIterator1 last, InputIterator2 otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator1 , class Input\+Iterator2 $>$ bool prism\+::equal (
\begin{DoxyParamCaption}
\item[{Input\+Iterator1}]{first, }
\item[{Input\+Iterator1}]{last, }
\item[{Input\+Iterator2}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad3bede9a0f2c648e93677b14c45b1b7b}{}\label{namespaceprism_ad3bede9a0f2c648e93677b14c45b1b7b}


Compares two ranges for equality. 

Compares all the elements in the range \mbox{[}first,last\mbox{]} against the elements in the range beginning from {\itshape other\+First}. Comparison is made using \hyperlink{namespaceprism_a1faf99d35e2cbb2b8c0644aa0b777e9b}{operator==()} so the element must support that operator.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the first range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position after the last element of the first range \\
\hline
\mbox{\tt in}  & {\em other\+First} & An iterator that points to the start of the second range\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If each element from the first range matches the corresponding element in the second range then {\itshape true} is returned and {\itshape false} otherwise.
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!fill@{fill}}
\index{fill@{fill}!prism@{prism}}
\subsubsection[{\texorpdfstring{fill(\+Forward\+Iterator first, Forward\+Iterator last, const T \&value)}{fill(ForwardIterator first, ForwardIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::fill (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{}\label{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}


Fills a range with a value. 

Assigns {\itshape value} to each element in the range \mbox{[}first,last\mbox{]}.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to one position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em value} & The value to be assigned\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!fill\+\_\+n@{fill\+\_\+n}}
\index{fill\+\_\+n@{fill\+\_\+n}!prism@{prism}}
\subsubsection[{\texorpdfstring{fill\+\_\+n(\+Forward\+Iterator first, int size, const T \&value)}{fill_n(ForwardIterator first, int size, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::fill\+\_\+n (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{int}]{size, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aceb4b9c511a5edb706296b457427b226}{}\label{namespaceprism_aceb4b9c511a5edb706296b457427b226}


Assigns a value to a specified number of elements in a range. 

Assigns {\itshape value} to the first  elements starting from {\itshape first} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em size} & The number of assignments to take place \\
\hline
\mbox{\tt in}  & {\em value} & The value to be assigned\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!find@{find}}
\index{find@{find}!prism@{prism}}
\subsubsection[{\texorpdfstring{find(\+Input\+Iterator first, Input\+Iterator last, const T \&value)}{find(InputIterator first, InputIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class T $>$ Input\+Iterator prism\+::find (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1b543d9c2862a539cc8b770abda87561}{}\label{namespaceprism_a1b543d9c2862a539cc8b770abda87561}


Finds a value in a range. 

Searches the range \mbox{[}first,last\mbox{]} for the first value equal to {\itshape value}. Comparison is made using \hyperlink{namespaceprism_a1faf99d35e2cbb2b8c0644aa0b777e9b}{operator==()} so the element must support that operator.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position after the last element in the range \\
\hline
\mbox{\tt in}  & {\em value} & The value to be found\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the found value or {\itshape last} if no element is found.
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!find\+\_\+if@{find\+\_\+if}}
\index{find\+\_\+if@{find\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{find\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Unary\+Predicate pred)}{find_if(InputIterator first, InputIterator last, UnaryPredicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Unary\+Predicate $>$ Input\+Iterator prism\+::find\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Unary\+Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a411641547f43e750a186c89bf0dd5a59}{}\label{namespaceprism_a411641547f43e750a186c89bf0dd5a59}


Finds the first value in a range for which a predicate returns true. 

Searches the range \mbox{[}first,last\mbox{]} to find the first element for which {\itshape pred} returns true.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the first element in the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position after the last element of the range \\
\hline
\mbox{\tt in}  & {\em pred} & A unary function that returns true or false\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the first found element for which {\itshape pred} return true or {\itshape last} if no element is found
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!find\+\_\+last@{find\+\_\+last}}
\index{find\+\_\+last@{find\+\_\+last}!prism@{prism}}
\subsubsection[{\texorpdfstring{find\+\_\+last(\+Input\+Iterator first, Input\+Iterator last, const T \&value)}{find_last(InputIterator first, InputIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class T $>$ Input\+Iterator prism\+::find\+\_\+last (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a3189014b9fa31e0ef0d1933c6f616618}{}\label{namespaceprism_a3189014b9fa31e0ef0d1933c6f616618}


Finds the last value in a range that matches a specified value. 

Searches the range \mbox{[}first,last\mbox{]} for the last occurrence of {\itshape value} 

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element of the range \\
\hline
\mbox{\tt in}  & {\em value} & The value to be found\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the found element or {\itshape last} if no element is found
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!for\+\_\+each@{for\+\_\+each}}
\index{for\+\_\+each@{for\+\_\+each}!prism@{prism}}
\subsubsection[{\texorpdfstring{for\+\_\+each(\+Input\+Iterator first, Input\+Iterator last, Unary\+Function func)}{for_each(InputIterator first, InputIterator last, UnaryFunction func)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Unary\+Function $>$ Unary\+Function prism\+::for\+\_\+each (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Unary\+Function}]{func}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9f65de889707907c02a325d8a4ff4aec}{}\label{namespaceprism_a9f65de889707907c02a325d8a4ff4aec}


Calls a function for each element in a range. 

For all elements in a range \mbox{[}first,last\mbox{]} a function {\itshape func} is called where each element is passed into the function as an argument.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em func} & The function to be called for each element\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The function {\itshape func} 
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!has\+\_\+next@{has\+\_\+next}}
\index{has\+\_\+next@{has\+\_\+next}!prism@{prism}}
\subsubsection[{\texorpdfstring{has\+\_\+next(\+Input\+Iterator \&it, Container \&con)}{has_next(InputIterator &it, Container &con)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Container $>$ const bool prism\+::has\+\_\+next (
\begin{DoxyParamCaption}
\item[{Input\+Iterator \&}]{it, }
\item[{Container \&}]{con}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad56900cb33be6d15ac27a7c61bad2ce6}{}\label{namespaceprism_ad56900cb33be6d15ac27a7c61bad2ce6}
\index{prism@{prism}!has\+\_\+previous@{has\+\_\+previous}}
\index{has\+\_\+previous@{has\+\_\+previous}!prism@{prism}}
\subsubsection[{\texorpdfstring{has\+\_\+previous(\+Input\+Iterator \&it, Container \&con)}{has_previous(InputIterator &it, Container &con)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Container $>$ const bool prism\+::has\+\_\+previous (
\begin{DoxyParamCaption}
\item[{Input\+Iterator \&}]{it, }
\item[{Container \&}]{con}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af20b814018d65b46e6d08eb450c176c9}{}\label{namespaceprism_af20b814018d65b46e6d08eb450c176c9}
\index{prism@{prism}!is\+\_\+sorted@{is\+\_\+sorted}}
\index{is\+\_\+sorted@{is\+\_\+sorted}!prism@{prism}}
\subsubsection[{\texorpdfstring{is\+\_\+sorted(\+Forward\+Iterator first, Forward\+Iterator last)}{is_sorted(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ const bool prism\+::is\+\_\+sorted (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_acf5efbeb096446c47690b9e8bd2cc01a}{}\label{namespaceprism_acf5efbeb096446c47690b9e8bd2cc01a}


Checks if a range is sorted in ascending order. 

Checks the elements in a range \mbox{[}first,last\mbox{]} to see if they are arranged in ascending order. The element type must support operator$<$().

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em func} & A unary function that takes an argument from the range \mbox{[}frst,last\mbox{]}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the range is sorted in ascending order or false otherwise
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!make\+\_\+heap@{make\+\_\+heap}}
\index{make\+\_\+heap@{make\+\_\+heap}!prism@{prism}}
\subsubsection[{\texorpdfstring{make\+\_\+heap(\+Random\+Access\+Iterator first, Random\+Access\+Iterator last)}{make_heap(RandomAccessIterator first, RandomAccessIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Random\+Access\+Iterator $>$ void prism\+::make\+\_\+heap (
\begin{DoxyParamCaption}
\item[{Random\+Access\+Iterator}]{first, }
\item[{Random\+Access\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af8e36230e6cb92a41aaca282772a9e6e}{}\label{namespaceprism_af8e36230e6cb92a41aaca282772a9e6e}


Rearranges a range into a heap order. 

todo W\+R\+I\+TE A B\+E\+T\+T\+ER E\+X\+P\+L\+A\+N\+A\+T\+I\+ON OF W\+H\+AT A H\+E\+AP IS Transforms a range \mbox{[}first,last\mbox{]} in such a way that it forms a heap. This makes retrieving the element with the highest value very fast.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!max@{max}}
\index{max@{max}!prism@{prism}}
\subsubsection[{\texorpdfstring{max(const T \&a, const T \&b)}{max(const T &a, const T &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ const T\& prism\+::max (
\begin{DoxyParamCaption}
\item[{const T \&}]{a, }
\item[{const T \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a812456273adfa37979e79f07e731d412}{}\label{namespaceprism_a812456273adfa37979e79f07e731d412}


Determines which value is greater. 

Compares the values {\itshape a} and {\itshape b} to find out which one has the greater value


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em a} & The first value \\
\hline
\mbox{\tt in}  & {\em b} & The second value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\itshape a} or {\itshape b}, whichever is the greater value
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!maximum\+Node\+In\+Sub\+Tree@{maximum\+Node\+In\+Sub\+Tree}}
\index{maximum\+Node\+In\+Sub\+Tree@{maximum\+Node\+In\+Sub\+Tree}!prism@{prism}}
\subsubsection[{\texorpdfstring{maximum\+Node\+In\+Sub\+Tree(\+Node\+Pointer node)}{maximumNodeInSubTree(NodePointer node)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Node\+Pointer $>$ Node\+Pointer prism\+::maximum\+Node\+In\+Sub\+Tree (
\begin{DoxyParamCaption}
\item[{Node\+Pointer}]{node}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6db5694fde99b39da76f51463f300c4a}{}\label{namespaceprism_a6db5694fde99b39da76f51463f300c4a}
\index{prism@{prism}!min@{min}}
\index{min@{min}!prism@{prism}}
\subsubsection[{\texorpdfstring{min(const T \&a, const T \&b)}{min(const T &a, const T &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ const T\& prism\+::min (
\begin{DoxyParamCaption}
\item[{const T \&}]{a, }
\item[{const T \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a10aff0aca673fb1837069dd8967e4738}{}\label{namespaceprism_a10aff0aca673fb1837069dd8967e4738}


Determines which value is lesser. 

Compares the values {\itshape a} and {\itshape b} to find out which one has the lesser value


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em a} & The first value \\
\hline
\mbox{\tt in}  & {\em b} & The second value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\itshape a} or {\itshape b}, whichever is the lesser value
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!minimum\+Node\+In\+Sub\+Tree@{minimum\+Node\+In\+Sub\+Tree}}
\index{minimum\+Node\+In\+Sub\+Tree@{minimum\+Node\+In\+Sub\+Tree}!prism@{prism}}
\subsubsection[{\texorpdfstring{minimum\+Node\+In\+Sub\+Tree(\+Node\+Pointer node)}{minimumNodeInSubTree(NodePointer node)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Node\+Pointer $>$ Node\+Pointer prism\+::minimum\+Node\+In\+Sub\+Tree (
\begin{DoxyParamCaption}
\item[{Node\+Pointer}]{node}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8aab2862319b55b02ddcb6b9659b3699}{}\label{namespaceprism_a8aab2862319b55b02ddcb6b9659b3699}
\index{prism@{prism}!next@{next}}
\index{next@{next}!prism@{prism}}
\subsubsection[{\texorpdfstring{next(\+Forward\+Iterator it, int num\+Steps=1)}{next(ForwardIterator it, int numSteps=1)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ Forward\+Iterator prism\+::next (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{it, }
\item[{int}]{num\+Steps = {\ttfamily 1}}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a16771cef03b7354150e188f4ce10f6b1}{}\label{namespaceprism_a16771cef03b7354150e188f4ce10f6b1}
Advances the iterator {\itshape it} by {\itshape num\+Steps} (1 by default). Returns an iterator. \index{prism@{prism}!none\+\_\+of@{none\+\_\+of}}
\index{none\+\_\+of@{none\+\_\+of}!prism@{prism}}
\subsubsection[{\texorpdfstring{none\+\_\+of(\+Input\+Iterator first, Input\+Iterator last, Unary\+Predicate pred)}{none_of(InputIterator first, InputIterator last, UnaryPredicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Unary\+Predicate $>$ bool prism\+::none\+\_\+of (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Unary\+Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a3c43dafd5926d3dc6ce698ae8938810d}{}\label{namespaceprism_a3c43dafd5926d3dc6ce698ae8938810d}


Checks elements in a range to see if they don\textquotesingle{}t match a condition. 

Each element in the range \mbox{[}first,last\mbox{]} is checked to make sure it doesn\textquotesingle{}t match the condition in {\itshape pred}.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em pred} & A unary predicate that returns true or false \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if {\itshape pred} returns false for all elements or if the range is empty, false otherwise
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Shared\+Pointer$<$ U $>$ \&p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator!=(const SharedPointer< U > &p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9df924e4deb059bf1200701c8235410a}{}\label{namespaceprism_a9df924e4deb059bf1200701c8235410a}
Returns true if the managed pointers of p1 and p2 do not point to the same data, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Shared\+Pointer$<$ U $>$ \&p1, const U $\ast$p2)}{operator!=(const SharedPointer< U > &p1, const U *p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const U $\ast$}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad6391c124e006b0e3a3ec67f55e208b0}{}\label{namespaceprism_ad6391c124e006b0e3a3ec67f55e208b0}
Returns true if the managed pointer of p1 and the raw pointer p2 do not point to the same data, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const U $\ast$p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator!=(const U *p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const U $\ast$}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab8792dbd5cac5678390843bacdb69daa}{}\label{namespaceprism_ab8792dbd5cac5678390843bacdb69daa}
Returns true if the raw pointer p1 and the managed pointer of p2 do not point to the same data, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Allocator$<$ T $>$ \&a1, const Allocator$<$ T $>$ \&a2)}{operator==(const Allocator< T > &a1, const Allocator< T > &a2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Allocator}$<$ T $>$ \&}]{a1, }
\item[{const {\bf Allocator}$<$ T $>$ \&}]{a2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1faf99d35e2cbb2b8c0644aa0b777e9b}{}\label{namespaceprism_a1faf99d35e2cbb2b8c0644aa0b777e9b}
\index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Shared\+Pointer$<$ U $>$ \&p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator==(const SharedPointer< U > &p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae53d52e8a36ec7ca58ea1731cc18f1d8}{}\label{namespaceprism_ae53d52e8a36ec7ca58ea1731cc18f1d8}
Returns true if the managed pointers of p1 and p2 point to the same data, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Log\+Allocator$<$ T $>$ \&a1, const Log\+Allocator$<$ T $>$ \&a2)}{operator==(const LogAllocator< T > &a1, const LogAllocator< T > &a2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Log\+Allocator}$<$ T $>$ \&}]{a1, }
\item[{const {\bf Log\+Allocator}$<$ T $>$ \&}]{a2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7f163cf0ef281768da60b400045aa8d8}{}\label{namespaceprism_a7f163cf0ef281768da60b400045aa8d8}
\index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Shared\+Pointer$<$ U $>$ \&p1, const U $\ast$p2)}{operator==(const SharedPointer< U > &p1, const U *p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const U $\ast$}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2b73e87f080646696ed6b595a3900119}{}\label{namespaceprism_a2b73e87f080646696ed6b595a3900119}
Returns true if the managed pointer of p1 and the raw pointer p2 point to the same data, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const U $\ast$p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator==(const U *p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const U $\ast$}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1f29b22985dc0ec1fc548a551ce313ed}{}\label{namespaceprism_a1f29b22985dc0ec1fc548a551ce313ed}
Returns true if the raw pointer p1 and the managed pointer of p2 point to the same data, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Array$<$ T, size $>$ \&lhs, const Array$<$ T, size $>$ \&rhs)}{operator==(const Array< T, size > &lhs, const Array< T, size > &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , size\+\_\+t size$>$ const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Array}$<$ T, size $>$ \&}]{lhs, }
\item[{const {\bf Array}$<$ T, size $>$ \&}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a23cc68e19002deb7797ff9eaa10523db}{}\label{namespaceprism_a23cc68e19002deb7797ff9eaa10523db}


Compares two arrays for equality. 


\begin{DoxyParams}{Parameters}
{\em lhs} & The first array \\
\hline
{\em rhs} & The second array\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns true if the arrays are equal or false otherwise. Two arrays are equivalent if they have the same size and the same elements in the same order
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!previous@{previous}}
\index{previous@{previous}!prism@{prism}}
\subsubsection[{\texorpdfstring{previous(\+Bidirectional\+Iterator it, int num\+Steps=1)}{previous(BidirectionalIterator it, int numSteps=1)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Bidirectional\+Iterator $>$ Bidirectional\+Iterator prism\+::previous (
\begin{DoxyParamCaption}
\item[{Bidirectional\+Iterator}]{it, }
\item[{int}]{num\+Steps = {\ttfamily 1}}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8370841f58d9898247afa42c49a7658d}{}\label{namespaceprism_a8370841f58d9898247afa42c49a7658d}
Moves the iterator {\itshape it} back by {\itshape num\+Steps}. Returns an iterator. \index{prism@{prism}!print\+Tree@{print\+Tree}}
\index{print\+Tree@{print\+Tree}!prism@{prism}}
\subsubsection[{\texorpdfstring{print\+Tree(\+Node\+Pointer p, int indent=0)}{printTree(NodePointer p, int indent=0)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Node\+Pointer $>$ void prism\+::print\+Tree (
\begin{DoxyParamCaption}
\item[{Node\+Pointer}]{p, }
\item[{int}]{indent = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a3ec96a679831176af1c6f2b7480226e1}{}\label{namespaceprism_a3ec96a679831176af1c6f2b7480226e1}
\index{prism@{prism}!remove@{remove}}
\index{remove@{remove}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove(\+Forward\+Iterator first, Forward\+Iterator last, const T \&value)}{remove(ForwardIterator first, ForwardIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ Forward\+Iterator prism\+::remove (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aeddd21943bcf811c56f7d9d1bd4784f6}{}\label{namespaceprism_aeddd21943bcf811c56f7d9d1bd4784f6}


Removes all elements that equal a value in a range. 

Transforms a range \mbox{[}first,last\mbox{]} into a range where all elements that equal {\itshape value} are removed. The element type must support \hyperlink{namespaceprism_a1faf99d35e2cbb2b8c0644aa0b777e9b}{operator==()}.

The order of the elements not removed are preserved but note that any element between the returned iterator and {\itshape last} are still valid but in an unspecified state.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em value} & The value to be removed\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the position after the new end of the range
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!remove\+\_\+copy@{remove\+\_\+copy}}
\index{remove\+\_\+copy@{remove\+\_\+copy}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+\_\+copy(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, const T \&value)}{remove_copy(InputIterator first, InputIterator last, OutputIterator otherFirst, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ Output\+Iterator prism\+::remove\+\_\+copy (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab7b6fb407340e51749169560b48fb20c}{}\label{namespaceprism_ab7b6fb407340e51749169560b48fb20c}


Copies elements from a range that don\textquotesingle{}t match a value into another range. 

Iterates through a range \mbox{[}first,last\mbox{]} and copies each element that doesn\textquotesingle{}t match {\itshape value} into the range beginning at {\itshape other\+First}. The element type must support \hyperlink{namespaceprism_a1faf99d35e2cbb2b8c0644aa0b777e9b}{operator==()}.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em other\+First} & An iterator that points to the start of the destination range \\
\hline
\mbox{\tt in}  & {\em value} & The value for each element to be compared to\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the position after the last element copied into the destination range
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!remove\+\_\+copy\+\_\+if@{remove\+\_\+copy\+\_\+if}}
\index{remove\+\_\+copy\+\_\+if@{remove\+\_\+copy\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+\_\+copy\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Unary\+Predicate pred)}{remove_copy_if(InputIterator first, InputIterator last, OutputIterator otherFirst, UnaryPredicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class Unary\+Predicate $>$ Output\+Iterator prism\+::remove\+\_\+copy\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{Unary\+Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_abfc7da1f951e480a26d58fc098b78844}{}\label{namespaceprism_abfc7da1f951e480a26d58fc098b78844}


Copies elements from a range for which a predicate returns false into another range. 

Iterates through a range \mbox{[}first,last\mbox{]} and copies all elements (except those for which {\itshape pred} returns true) into the range beginning at {\itshape other\+First}. The element type must support \hyperlink{namespaceprism_a1faf99d35e2cbb2b8c0644aa0b777e9b}{operator==()}.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em other\+First} & An iterator that points to the start of the destination range \\
\hline
\mbox{\tt in}  & {\em pred} & A unary function that returns true or false\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the position after the last element copied into the destination range
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!remove\+\_\+if@{remove\+\_\+if}}
\index{remove\+\_\+if@{remove\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+\_\+if(\+Forward\+Iterator first, Forward\+Iterator last, Unary\+Predicate pred)}{remove_if(ForwardIterator first, ForwardIterator last, UnaryPredicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class Unary\+Predicate $>$ Forward\+Iterator prism\+::remove\+\_\+if (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{Unary\+Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a252483ee5c3c08a0b99b67510371583d}{}\label{namespaceprism_a252483ee5c3c08a0b99b67510371583d}


Removes all elements from a range for which a predicate returns true. 

Transforms the range \mbox{[}first,last\mbox{]} into a range where each element for which {\itshape pred} returns true is removed.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em pred} & A unary function that returns true or false\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the position after the new end of the range
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!replace@{replace}}
\index{replace@{replace}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace(\+Forward\+Iterator first, Forward\+Iterator last, const T \&old\+Value, const T \&new\+Value)}{replace(ForwardIterator first, ForwardIterator last, const T &oldValue, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::replace (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{const T \&}]{old\+Value, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6156070b98de7130b8c912ae3a6d333f}{}\label{namespaceprism_a6156070b98de7130b8c912ae3a6d333f}


Replaces all occurrences of a value with a new value in a range. 

Iterates through the range \mbox{[}first,last\mbox{]} and replaces each occurrence of {\itshape old\+Value} with {\itshape new\+Value}. The element type must support \hyperlink{namespaceprism_a1faf99d35e2cbb2b8c0644aa0b777e9b}{operator==()}.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em old\+Value} & The value to be replaced \\
\hline
\mbox{\tt in}  & {\em new\+Value} & The new value that replaces the old value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!replace\+\_\+copy@{replace\+\_\+copy}}
\index{replace\+\_\+copy@{replace\+\_\+copy}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace\+\_\+copy(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, const T \&old\+Value, const T \&new\+Value)}{replace_copy(InputIterator first, InputIterator last, OutputIterator otherFirst, const T &oldValue, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ Output\+Iterator prism\+::replace\+\_\+copy (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{const T \&}]{old\+Value, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a16d85ecb70d2f216714a0146a057a105}{}\label{namespaceprism_a16d85ecb70d2f216714a0146a057a105}


Copies the elements from one range to another range replacing one value with another value. 

Iterates through the range \mbox{[}first,last\mbox{]} and copies each element into the range beginning at {\itshape other\+First} whilst replacing all occurrences of {\itshape old\+Value} with {\itshape new\+Value} in the destination range. The element type must support \hyperlink{namespaceprism_a1faf99d35e2cbb2b8c0644aa0b777e9b}{operator==()}.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em other\+First} & An iterator that points to the start of the destination range \\
\hline
\mbox{\tt in}  & {\em old\+Value} & The value to be replaced \\
\hline
\mbox{\tt in}  & {\em new\+Value} & The new value that replaces the old value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the position after the last element copied into the destination range
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!replace\+\_\+copy\+\_\+if@{replace\+\_\+copy\+\_\+if}}
\index{replace\+\_\+copy\+\_\+if@{replace\+\_\+copy\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace\+\_\+copy\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Unary\+Predicate pred, const T \&new\+Value)}{replace_copy_if(InputIterator first, InputIterator last, OutputIterator otherFirst, UnaryPredicate pred, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class Unary\+Predicate , class T $>$ Output\+Iterator prism\+::replace\+\_\+copy\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{Unary\+Predicate}]{pred, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ac48a460cd28a7965f460dfb98e68fa39}{}\label{namespaceprism_ac48a460cd28a7965f460dfb98e68fa39}


Copies the elements from one range to another range replacing each element that a predicate returns true for with a new value. 

Iterates through the range \{first,last\mbox{]} and copies each element into the destination range beginning at {\itshape other\+First} replacing any value with {\itshape new\+Value} for which {\itshape pred} returns true.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em other\+First} & An iterator that points to the start of the destination range \\
\hline
\mbox{\tt in}  & {\em pred} & A unary function that returns true or false \\
\hline
\mbox{\tt in}  & {\em new\+Value} & The new value that replaces the old value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the position after the last element copied into the destination range
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!replace\+\_\+if@{replace\+\_\+if}}
\index{replace\+\_\+if@{replace\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace\+\_\+if(\+Forward\+Iterator first, Forward\+Iterator last, Unary\+Predicate pred, const T \&new\+Value)}{replace_if(ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class Unary\+Predicate , class T $>$ void prism\+::replace\+\_\+if (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{Unary\+Predicate}]{pred, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7742cad186e8ce8764ee48ff1fbfd4cf}{}\label{namespaceprism_a7742cad186e8ce8764ee48ff1fbfd4cf}


Assigns a new value to all elements for which a predicate returns true. 

Iterates through the range \mbox{[}first,last\mbox{]} and replaces any element for which the predicate {\itshape pred} returns true with {\itshape new\+Value}. The element type must support \hyperlink{namespaceprism_a1faf99d35e2cbb2b8c0644aa0b777e9b}{operator==()}.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em pred} & A unary function that returns true or false \\
\hline
\mbox{\tt in}  & {\em new\+Value} & The new value that replaces the old value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!search@{search}}
\index{search@{search}!prism@{prism}}
\subsubsection[{\texorpdfstring{search(\+Forward\+Iterator1 first, Forward\+Iterator1 last, Forward\+Iterator2 other\+First, Forward\+Iterator2 other\+Last)}{search(ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 otherFirst, ForwardIterator2 otherLast)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ Forward\+Iterator1 prism\+::search (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator1}]{first, }
\item[{Forward\+Iterator1}]{last, }
\item[{Forward\+Iterator2}]{other\+First, }
\item[{Forward\+Iterator2}]{other\+Last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a03dbb806369b062fd90909fd826c2ee4}{}\label{namespaceprism_a03dbb806369b062fd90909fd826c2ee4}


Searches a range for a sub-\/range. 

Iterates through the range \mbox{[}first,last\mbox{]} searching for the sub-\/range defined by the range \mbox{[}other\+First,other\+Last\mbox{]}. The element type must support \hyperlink{namespaceprism_a1faf99d35e2cbb2b8c0644aa0b777e9b}{operator==()}.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}. Likewise for the range \mbox{[}other\+First,other\+Last\mbox{]}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em other\+First} & An iterator that points to the start of the other range \\
\hline
\mbox{\tt in}  & {\em other\+Last} & An iterator that points to the position past the last element in the other range\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the first element of the matching sub-\/range in the source range or {\itshape last} if no sub-\/range is found
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!sort@{sort}}
\index{sort@{sort}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort(\+Bidirectional\+Iterator first, Bidirectional\+Iterator last)}{sort(BidirectionalIterator first, BidirectionalIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Bidirectional\+Iterator $>$ void prism\+::sort (
\begin{DoxyParamCaption}
\item[{Bidirectional\+Iterator}]{first, }
\item[{Bidirectional\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_addfe9ea0146b59b2b16adee4cd2220b9}{}\label{namespaceprism_addfe9ea0146b59b2b16adee4cd2220b9}


Sorts the elements in a range in ascending order. 

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!sort\+\_\+bubble@{sort\+\_\+bubble}}
\index{sort\+\_\+bubble@{sort\+\_\+bubble}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort\+\_\+bubble(\+Bidirectional\+Iterator first, Bidirectional\+Iterator last)}{sort_bubble(BidirectionalIterator first, BidirectionalIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Bidirectional\+Iterator $>$ void prism\+::sort\+\_\+bubble (
\begin{DoxyParamCaption}
\item[{Bidirectional\+Iterator}]{first, }
\item[{Bidirectional\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa2955433bd872919cf59580c1a464c93}{}\label{namespaceprism_aa2955433bd872919cf59580c1a464c93}


Sorts the elements in a range in ascending order. 

Sorts the elements in the range \mbox{[}first,last\mbox{]} in ascending order using the bubble sort algorithm. The element type must support operator$>$().

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!sort\+\_\+heap@{sort\+\_\+heap}}
\index{sort\+\_\+heap@{sort\+\_\+heap}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort\+\_\+heap(\+Random\+Access\+Iterator first, Random\+Access\+Iterator last)}{sort_heap(RandomAccessIterator first, RandomAccessIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Random\+Access\+Iterator $>$ void prism\+::sort\+\_\+heap (
\begin{DoxyParamCaption}
\item[{Random\+Access\+Iterator}]{first, }
\item[{Random\+Access\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1e9fe74c5dcee70bf5dd5c89f1234a02}{}\label{namespaceprism_a1e9fe74c5dcee70bf5dd5c89f1234a02}


Sorts the elements in a range in ascending order. 

Sorts the elements in the range \mbox{[}first,last\mbox{]} in ascending order using the heap sort algorithm. The element type must support operator$<$().

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!sort\+\_\+quicksort@{sort\+\_\+quicksort}}
\index{sort\+\_\+quicksort@{sort\+\_\+quicksort}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort\+\_\+quicksort(\+Bidirectional\+Iterator first, Bidirectional\+Iterator last)}{sort_quicksort(BidirectionalIterator first, BidirectionalIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Bidirectional\+Iterator $>$ void prism\+::sort\+\_\+quicksort (
\begin{DoxyParamCaption}
\item[{Bidirectional\+Iterator}]{first, }
\item[{Bidirectional\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad8cbe49b782032932d0da83860e7b368}{}\label{namespaceprism_ad8cbe49b782032932d0da83860e7b368}


Sorts the elements in a range in ascending order. 

Sorts the elements in the range \mbox{[}first,last\mbox{]} in ascending order using the quick sort algorithm. The element type must support operator$<$=().

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!swap@{swap}}
\index{swap@{swap}!prism@{prism}}
\subsubsection[{\texorpdfstring{swap(\+Array$<$ T, Size $>$ \&a, Array$<$ T, Size $>$ \&b)}{swap(Array< T, Size > &a, Array< T, Size > &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , size\+\_\+t Size$>$ void prism\+::swap (
\begin{DoxyParamCaption}
\item[{{\bf Array}$<$ T, {\bf Size} $>$ \&}]{a, }
\item[{{\bf Array}$<$ T, {\bf Size} $>$ \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aff86329b54a13cb753f2c79156f68bb4}{}\label{namespaceprism_aff86329b54a13cb753f2c79156f68bb4}
\index{prism@{prism}!swap@{swap}}
\index{swap@{swap}!prism@{prism}}
\subsubsection[{\texorpdfstring{swap(\+T \&a, T \&b)}{swap(T &a, T &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ void prism\+::swap (
\begin{DoxyParamCaption}
\item[{T \&}]{a, }
\item[{T \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6430516ab4f2e2a7f43323acb6b559d8}{}\label{namespaceprism_a6430516ab4f2e2a7f43323acb6b559d8}


Swaps the values of two variables. 

After running this function {\itshape a} will equal {\itshape b\textquotesingle{}s} old value and {\itshape b} will equal {\itshape a\textquotesingle{}s} old value. The element type must support operator=()


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em a} & The first value \\
\hline
\mbox{\tt in}  & {\em b} & The second value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!swap\+\_\+ranges@{swap\+\_\+ranges}}
\index{swap\+\_\+ranges@{swap\+\_\+ranges}!prism@{prism}}
\subsubsection[{\texorpdfstring{swap\+\_\+ranges(\+Forward\+Iterator1 first, Forward\+Iterator1 last, Forward\+Iterator2 other\+First)}{swap_ranges(ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ Forward\+Iterator2 prism\+::swap\+\_\+ranges (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator1}]{first, }
\item[{Forward\+Iterator1}]{last, }
\item[{Forward\+Iterator2}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4661f2c0c4dca098c137179b4d93f3dc}{}\label{namespaceprism_a4661f2c0c4dca098c137179b4d93f3dc}


Swaps the elements in two ranges. 

All of the elements in the range \mbox{[}first,last\mbox{]} are swapped with the elements in the range beginning from {\itshape other\+First}. The element type must support operator=().

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em other\+First} & An iterator that points to the start of the other range\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the position after the last element swapped into the destination range
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!uninitialized\+\_\+copy@{uninitialized\+\_\+copy}}
\index{uninitialized\+\_\+copy@{uninitialized\+\_\+copy}!prism@{prism}}
\subsubsection[{\texorpdfstring{uninitialized\+\_\+copy(\+Forward\+Iterator1 first, Forward\+Iterator1 last, Forward\+Iterator2 other\+First)}{uninitialized_copy(ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ Forward\+Iterator2 prism\+::uninitialized\+\_\+copy (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator1}]{first, }
\item[{Forward\+Iterator1}]{last, }
\item[{Forward\+Iterator2}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5ff56f151fea6e709350a0e9fbdb70a8}{}\label{namespaceprism_a5ff56f151fea6e709350a0e9fbdb70a8}


Copies a range into an uninitialized range. 

The range \mbox{[}first,last\mbox{]} represents a block of memory that has been allocated but not initialized i.\+e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the \hyperlink{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}{prism\+::copy} algorithm). This algorithm takes that memory block and initializes each element by copy-\/constructing each element in place. This algorithm differs from \hyperlink{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}{prism\+::copy} because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn\textquotesingle{}t. It copy-\/constructs in place instead.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em other\+First} & An iterator that points to the start of an uninitialized range\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the position after the last element copied to the destination range
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!uninitialized\+\_\+copy\+\_\+n@{uninitialized\+\_\+copy\+\_\+n}}
\index{uninitialized\+\_\+copy\+\_\+n@{uninitialized\+\_\+copy\+\_\+n}!prism@{prism}}
\subsubsection[{\texorpdfstring{uninitialized\+\_\+copy\+\_\+n(\+Forward\+Iterator1 first, const int size, Forward\+Iterator2 other\+First)}{uninitialized_copy_n(ForwardIterator1 first, const int size, ForwardIterator2 otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ Forward\+Iterator2 prism\+::uninitialized\+\_\+copy\+\_\+n (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator1}]{first, }
\item[{const int}]{size, }
\item[{Forward\+Iterator2}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad1c7d8eb38174ba66d98321b68047e6e}{}\label{namespaceprism_ad1c7d8eb38174ba66d98321b68047e6e}


Copies a number of elements from a range into an uninitialized range. 

The range beginning at {\itshape first} represents a block of memory that has been allocated but not initialized i.\+e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{prism\+::fill} algorithm). This algorithm takes that memory block and initializes each element by copy-\/constructing each element in place. This algorithm differs from \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{prism\+::fill} because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn\textquotesingle{}t. It copy-\/constructs in place instead.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em size} & The number of elements to copy-\/initialize \\
\hline
\mbox{\tt in}  & {\em other\+First} & An iterator that points to the start of an uninitialized range\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the position after the last element copied to the destination range
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!uninitialized\+\_\+fill@{uninitialized\+\_\+fill}}
\index{uninitialized\+\_\+fill@{uninitialized\+\_\+fill}!prism@{prism}}
\subsubsection[{\texorpdfstring{uninitialized\+\_\+fill(\+Forward\+Iterator first, Forward\+Iterator last, const T \&value)}{uninitialized_fill(ForwardIterator first, ForwardIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::uninitialized\+\_\+fill (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8234c2c7917f750db94bb068d6fd554e}{}\label{namespaceprism_a8234c2c7917f750db94bb068d6fd554e}


Fills an uninitialized range with a value. 

The range \mbox{[}first,last\mbox{]} represents a block of memory that has been allocated but not initialized i.\+e. no elements have been constructed. This algorithm takes that memory block and initializes each element by copy-\/constructing each element in place.

The range is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed to by {\itshape first} but not the element pointed to by {\itshape last}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em last} & An iterator that points to the position past the last element in the range \\
\hline
\mbox{\tt in}  & {\em value} & The value to be assigned to the range\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
\index{prism@{prism}!uninitialized\+\_\+fill\+\_\+n@{uninitialized\+\_\+fill\+\_\+n}}
\index{uninitialized\+\_\+fill\+\_\+n@{uninitialized\+\_\+fill\+\_\+n}!prism@{prism}}
\subsubsection[{\texorpdfstring{uninitialized\+\_\+fill\+\_\+n(\+Forward\+Iterator first, const int size, const T \&value)}{uninitialized_fill_n(ForwardIterator first, const int size, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::uninitialized\+\_\+fill\+\_\+n (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{const int}]{size, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5485ae7bad862f6ff0ab363ed4697b61}{}\label{namespaceprism_a5485ae7bad862f6ff0ab363ed4697b61}


Fills the first number of elements in an uninitialized range with a value. 

The range starting at {\itshape first} represents a block of memory that has been allocated but not initialized i.\+e. no elements have been constructed. This algorithm takes that memory block and initializes each element by copy-\/constructing each element in place.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first} & An iterator that points to the start of the range \\
\hline
\mbox{\tt in}  & {\em size} & The number of elements to fill-\/initialize \\
\hline
\mbox{\tt in}  & {\em value} & The value to fill-\/initialize with\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing
\end{DoxyReturn}
\begin{DoxySince}{Since}
1.\+0.\+0 
\end{DoxySince}
