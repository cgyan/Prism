\hypertarget{namespaceprism}{}\section{prism Namespace Reference}
\label{namespaceprism}\index{prism@{prism}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classprism_1_1_array}{Array}
\item 
class \hyperlink{classprism_1_1_bitvector}{Bitvector}
\item 
struct \hyperlink{structprism_1_1_bitvector_data}{Bitvector\+Data}
\item 
class \hyperlink{classprism_1_1_char}{Char}
\item 
class \hyperlink{classprism_1_1_circle}{Circle}
\item 
class \hyperlink{classprism_1_1_exception}{Exception}
\item 
class \hyperlink{classprism_1_1_flag}{Flag}
\item 
class \hyperlink{classprism_1_1_flags}{Flags}
\item 
class \hyperlink{classprism_1_1_fraction}{Fraction}
\item 
class \hyperlink{classprism_1_1_list}{List}
\item 
struct \hyperlink{structprism_1_1_list_const_iterator}{List\+Const\+Iterator}
\item 
struct \hyperlink{structprism_1_1_list_iterator}{List\+Iterator}
\item 
class \hyperlink{classprism_1_1_mathf}{Mathf}
\item 
class \hyperlink{classprism_1_1_matrix4}{Matrix4}
\item 
class \hyperlink{classprism_1_1_out_of_bounds_exception}{Out\+Of\+Bounds\+Exception}
\item 
class \hyperlink{classprism_1_1_overflow_exception}{Overflow\+Exception}
\item 
class \hyperlink{classprism_1_1_point}{Point}
\item 
class \hyperlink{classprism_1_1_pointf}{Pointf}
\item 
class \hyperlink{classprism_1_1_quaternion}{Quaternion}
\item 
class \hyperlink{classprism_1_1_queue}{Queue}
\item 
class \hyperlink{classprism_1_1_rect}{Rect}
\item 
class \hyperlink{classprism_1_1_reference_counter}{Reference\+Counter}
\item 
class \hyperlink{classprism_1_1_shared_data}{Shared\+Data}
\item 
class \hyperlink{classprism_1_1_shared_data_pointer}{Shared\+Data\+Pointer}
\item 
class \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}
\item 
class \hyperlink{classprism_1_1_size}{Size}
\item 
class \hyperlink{classprism_1_1_stack}{Stack}
\item 
struct \hyperlink{structprism_1_1_stack_data}{Stack\+Data}
\item 
class \hyperlink{classprism_1_1_string}{String}
\item 
class \hyperlink{classprism_1_1_time}{Time}
\item 
class \hyperlink{classprism_1_1_unequal_size_exception}{Unequal\+Size\+Exception}
\item 
class \hyperlink{classprism_1_1_vector}{Vector}
\item 
class \hyperlink{classprism_1_1_vector2}{Vector2}
\item 
class \hyperlink{classprism_1_1_vector3}{Vector3}
\item 
class \hyperlink{classprism_1_1_vector4}{Vector4}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class T $>$ }\\std\+::ostream \& \hyperlink{namespaceprism_a403ca8f79c481a89132691c0fd8c3a06}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_array}{Array}$<$ T $>$ \&array)
\item 
{\footnotesize template$<$class T $>$ }\\std\+::ostream \& \hyperlink{namespaceprism_a50da64555d454821545fe0311fde6a62}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_list}{List}$<$ T $>$ \&list)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_a9df924e4deb059bf1200701c8235410a}{operator!=} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_ad6391c124e006b0e3a3ec67f55e208b0}{operator!=} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const U $\ast$p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_ab8792dbd5cac5678390843bacdb69daa}{operator!=} (const U $\ast$p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_ae53d52e8a36ec7ca58ea1731cc18f1d8}{operator==} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_a2b73e87f080646696ed6b595a3900119}{operator==} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const U $\ast$p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_a1f29b22985dc0ec1fc548a551ce313ed}{operator==} (const U $\ast$p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{namespaceprism_a6430516ab4f2e2a7f43323acb6b559d8}{swap} (T \&a, T \&b)
\item 
{\footnotesize template$<$class Random\+Access\+Iterator $>$ }\\void \hyperlink{namespaceprism_a5f2c83ae0d89a6581d1c42ba6fd79de0}{p\+\_\+heapify} (Random\+Access\+Iterator node, Random\+Access\+Iterator first, Random\+Access\+Iterator last)
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\Forward\+Iterator \hyperlink{namespaceprism_a82052418345794a13044c15d8e32dd89}{adjacent\+\_\+find} (Forward\+Iterator first, Forward\+Iterator last)
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\bool \hyperlink{namespaceprism_aba366b328f3b6161e6115c16b7153c6d}{all\+\_\+of} (Input\+Iterator first, Input\+Iterator last, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\bool \hyperlink{namespaceprism_a5d0e3ddb9f698759635572f1220ec0ca}{any\+\_\+of} (Input\+Iterator first, Input\+Iterator last, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator $>$ }\\Output\+Iterator \hyperlink{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}{copy} (Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First)
\item 
{\footnotesize template$<$class Bidirectional\+Iterator1 , class Bidirectional\+Iterator2 $>$ }\\Bidirectional\+Iterator2 \hyperlink{namespaceprism_a2564c63b76369cc81ff725a56e818046}{copy\+\_\+backward} (Bidirectional\+Iterator1 first, Bidirectional\+Iterator1 last, Bidirectional\+Iterator2 other\+Last)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class Predicate $>$ }\\Output\+Iterator \hyperlink{namespaceprism_afbed55ae6769c2d88c125aedc2f3846e}{copy\+\_\+if} (Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator , class Size , class Output\+Iterator $>$ }\\Output\+Iterator \hyperlink{namespaceprism_af907f3f5637d4ec056e9b833b6272953}{copy\+\_\+n} (Input\+Iterator first, \hyperlink{classprism_1_1_size}{Size} n, Output\+Iterator other\+First)
\item 
{\footnotesize template$<$class Input\+Iterator , class T $>$ }\\int \hyperlink{namespaceprism_a024117fc3639cdf6598509edf22f034a}{count} (Input\+Iterator first, Input\+Iterator last, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\int \hyperlink{namespaceprism_af0007d361beae18a930b6249752e509e}{count\+\_\+if} (Input\+Iterator first, Input\+Iterator last, Predicate pred)
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\void \hyperlink{namespaceprism_a83e62e5b148c55f949e5ea843d53ad67}{delete\+\_\+range} (Forward\+Iterator first, Forward\+Iterator last)
\item 
{\footnotesize template$<$class Input\+Iterator1 , class Input\+Iterator2 $>$ }\\bool \hyperlink{namespaceprism_ad3bede9a0f2c648e93677b14c45b1b7b}{equal} (Input\+Iterator1 first, Input\+Iterator1 last, Input\+Iterator2 other\+First)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{fill} (Forward\+Iterator first, Forward\+Iterator last, const T \&value)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_aceb4b9c511a5edb706296b457427b226}{fill\+\_\+n} (Forward\+Iterator first, int size, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class T $>$ }\\Input\+Iterator \hyperlink{namespaceprism_a1b543d9c2862a539cc8b770abda87561}{find} (Input\+Iterator first, Input\+Iterator last, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\Input\+Iterator \hyperlink{namespaceprism_aa17e9e6c80f8a52479a52450a108a636}{find\+\_\+if} (Input\+Iterator first, Input\+Iterator last, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator , class T $>$ }\\Input\+Iterator \hyperlink{namespaceprism_a3189014b9fa31e0ef0d1933c6f616618}{find\+\_\+last} (Input\+Iterator first, Input\+Iterator last, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Function $>$ }\\Function \hyperlink{namespaceprism_aae062d5bfdc0e53ae49c56520aded906}{for\+\_\+each} (Input\+Iterator first, Input\+Iterator last, Function func)
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\const bool \hyperlink{namespaceprism_acf5efbeb096446c47690b9e8bd2cc01a}{is\+\_\+sorted} (Forward\+Iterator first, Forward\+Iterator last)
\item 
{\footnotesize template$<$class Random\+Access\+Iterator $>$ }\\void \hyperlink{namespaceprism_af8e36230e6cb92a41aaca282772a9e6e}{make\+\_\+heap} (Random\+Access\+Iterator first, Random\+Access\+Iterator last)
\item 
{\footnotesize template$<$class T $>$ }\\const T \& \hyperlink{namespaceprism_a812456273adfa37979e79f07e731d412}{max} (const T \&a, const T \&b)
\item 
{\footnotesize template$<$class T $>$ }\\const T \& \hyperlink{namespaceprism_a10aff0aca673fb1837069dd8967e4738}{min} (const T \&a, const T \&b)
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\bool \hyperlink{namespaceprism_a10c83b433c7f98fd4513f1b68c6db594}{none\+\_\+of} (Input\+Iterator first, Input\+Iterator last, Predicate pred)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\Forward\+Iterator \hyperlink{namespaceprism_aeddd21943bcf811c56f7d9d1bd4784f6}{remove} (Forward\+Iterator first, Forward\+Iterator last, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ }\\Output\+Iterator \hyperlink{namespaceprism_ab7b6fb407340e51749169560b48fb20c}{remove\+\_\+copy} (Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class Unary\+Predicate $>$ }\\Output\+Iterator \hyperlink{namespaceprism_abfc7da1f951e480a26d58fc098b78844}{remove\+\_\+copy\+\_\+if} (Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Unary\+Predicate pred)
\item 
{\footnotesize template$<$class Forward\+Iterator , class Predicate $>$ }\\Forward\+Iterator \hyperlink{namespaceprism_a2e9d25191ed83ea0a193f16d9c0a00b7}{remove\+\_\+if} (Forward\+Iterator first, Forward\+Iterator last, Predicate pred)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_a6156070b98de7130b8c912ae3a6d333f}{replace} (Forward\+Iterator first, Forward\+Iterator last, const T \&old\+Value, const T \&new\+Value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ }\\Output\+Iterator \hyperlink{namespaceprism_a16d85ecb70d2f216714a0146a057a105}{replace\+\_\+copy} (Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, const T \&old\+Value, const T \&new\+Value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class Predicate , class T $>$ }\\Output\+Iterator \hyperlink{namespaceprism_a55d702599739f7137516dcd095119f15}{replace\+\_\+copy\+\_\+if} (Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Predicate pred, const T \&new\+Value)
\item 
{\footnotesize template$<$class Forward\+Iterator , class Predicate , class T $>$ }\\void \hyperlink{namespaceprism_af118c19f6b5448319eb3aaf2d556ac54}{replace\+\_\+if} (Forward\+Iterator first, Forward\+Iterator last, Predicate pred, const T \&new\+Value)
\item 
{\footnotesize template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ }\\Forward\+Iterator1 \hyperlink{namespaceprism_affcb3e5150d72d9f79b85b9ea4eb41e2}{search} (Forward\+Iterator1 first1, Forward\+Iterator1 last1, Forward\+Iterator2 first2, Forward\+Iterator2 last2)
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\void \hyperlink{namespaceprism_a9bf397cad0a67b67fbd1ecddf40d405e}{sort} (Forward\+Iterator first, Forward\+Iterator last)
\item 
{\footnotesize template$<$class Random\+Access\+Iterator $>$ }\\void \hyperlink{namespaceprism_aa597d262eb2f9ef80703c883a2d18d1e}{sort\+\_\+bubble} (Random\+Access\+Iterator first, Random\+Access\+Iterator last)
\item 
{\footnotesize template$<$class Random\+Access\+Iterator $>$ }\\void \hyperlink{namespaceprism_a1e9fe74c5dcee70bf5dd5c89f1234a02}{sort\+\_\+heap} (Random\+Access\+Iterator first, Random\+Access\+Iterator last)
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\void \hyperlink{namespaceprism_a720fbbcb3f399b006969bb00a66686f9}{sort\+\_\+quicksort} (Forward\+Iterator first, Forward\+Iterator last)
\item 
{\footnotesize template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ }\\Forward\+Iterator2 \hyperlink{namespaceprism_a4661f2c0c4dca098c137179b4d93f3dc}{swap\+\_\+ranges} (Forward\+Iterator1 first, Forward\+Iterator1 last, Forward\+Iterator2 other\+First)
\item 
\hyperlink{classprism_1_1_bitvector}{Bitvector} \hyperlink{namespaceprism_a26b2b2b5b2c5f305badd964c24625b36}{operator\&} (const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv1, const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv2)
\item 
\hyperlink{classprism_1_1_bitvector}{Bitvector} \hyperlink{namespaceprism_a145d1e196c14cdbdc4eccb01c60c9275}{operator$\vert$} (const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv1, const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv2)
\item 
\hyperlink{classprism_1_1_bitvector}{Bitvector} \hyperlink{namespaceprism_a6a18ff84f30ae8056d6807056a24ef14}{operator$^\wedge$} (const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv1, const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv2)
\item 
const bool \hyperlink{namespaceprism_aca036c7f0f8a5aaf98b46b4879189bcc}{operator==} (const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv1, const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv2)
\item 
const bool \hyperlink{namespaceprism_aca663878d61686ef365f3e51efddc4b4}{operator!=} (const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv1, const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a0b98ff0fee78022242292f24158ad1f0}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv)
\item 
const bool \hyperlink{namespaceprism_a1ba68b64a6cfdcff9e144b8c2476cddb}{operator==} (const \hyperlink{classprism_1_1_char}{Char} \&c1, const \hyperlink{classprism_1_1_char}{Char} \&c2)
\item 
const bool \hyperlink{namespaceprism_a249b6933154570d808cdd405ab1fd89b}{operator!=} (const \hyperlink{classprism_1_1_char}{Char} \&c1, const \hyperlink{classprism_1_1_char}{Char} \&c2)
\item 
const bool \hyperlink{namespaceprism_a2fc3e64ba36a16f24cb0ae387c83f35f}{operator$<$} (const \hyperlink{classprism_1_1_char}{Char} \&c1, const \hyperlink{classprism_1_1_char}{Char} \&c2)
\item 
const bool \hyperlink{namespaceprism_ab8a312729c4c9ae72836d0034a6f0758}{operator$>$} (const \hyperlink{classprism_1_1_char}{Char} \&c1, const \hyperlink{classprism_1_1_char}{Char} \&c2)
\item 
const bool \hyperlink{namespaceprism_a87d86e9266469c8a40537e12a560b066}{operator$<$=} (const \hyperlink{classprism_1_1_char}{Char} \&c1, const \hyperlink{classprism_1_1_char}{Char} \&c2)
\item 
const bool \hyperlink{namespaceprism_aad049ddef9beb3fec3e7057a7f651280}{operator$>$=} (const \hyperlink{classprism_1_1_char}{Char} \&c1, const \hyperlink{classprism_1_1_char}{Char} \&c2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_aa67ea1154a35dabe9c2c232aff65e930}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_char}{Char} \&c)
\item 
const bool \hyperlink{namespaceprism_a0ce1ad6e6392618212d5ab3bebb8e585}{operator==} (const \hyperlink{classprism_1_1_circle}{Circle} \&c1, const \hyperlink{classprism_1_1_circle}{Circle} \&c2)
\item 
const bool \hyperlink{namespaceprism_a58cbf7ef406800002b446a0f1e917745}{operator!=} (const \hyperlink{classprism_1_1_circle}{Circle} \&c1, const \hyperlink{classprism_1_1_circle}{Circle} \&c2)
\item 
const bool \hyperlink{namespaceprism_a8e662d15b162ca76912c491798caefd3}{operator$<$} (const \hyperlink{classprism_1_1_circle}{Circle} \&c1, const \hyperlink{classprism_1_1_circle}{Circle} \&c2)
\item 
const bool \hyperlink{namespaceprism_a671739ac8567654dba563c34af92213f}{operator$>$} (const \hyperlink{classprism_1_1_circle}{Circle} \&c1, const \hyperlink{classprism_1_1_circle}{Circle} \&c2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_aa63d3d39d3fad8fa5c5966cc4f306324}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_circle}{Circle} \&c)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_ac1b5b2765c314b2baa2dba5c57419829}{operator+} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_a2daf470e5f35f8450447deb2634c22c1}{operator-\/} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_ac4f48e3429a86bafcc7c21a2bd6a7ae1}{operator$\ast$} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_a1f5007702b28b447f62c3b9df62f2aa4}{operator$\ast$} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&fraction, const int i)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_af1ff5871f65565a84b886c5013bcd50a}{operator$\ast$} (const int i, const \hyperlink{classprism_1_1_fraction}{Fraction} \&fraction)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_a7ba7b5cc9750f0d6cda50f0cb874da6f}{operator/} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
const bool \hyperlink{namespaceprism_a105ac9995ade66ebb2a039ef90751c7a}{operator$<$} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
const bool \hyperlink{namespaceprism_a7122a7ff43fc6aba9cef9d31fe8c7559}{operator$>$} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
const bool \hyperlink{namespaceprism_a5b9e84008b9eaa99d29d4b74cd150cd8}{operator==} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
const bool \hyperlink{namespaceprism_aea72179b12983e614f72acd2b3cbf0e0}{operator!=} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a9c2d182a77a92e6cba7917dbd58f9d87}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a33537d30f01f996f8a05fc5b1b49ba3b}{operator+} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a34a2f64f209065f753bed62a880b75b6}{operator-\/} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a879d3410d690b5722a9af17297f38fbb}{operator-\/} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a9ae44fb46bb709a5c8f4d592baf65522}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_ab3639f7bd46a54726522dfe406841ea9}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a4073983f089695c40b6fd20d892175f9}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m, const float factor)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_aa2859acb8e8dd6fea8678e14249e561d}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const float $\ast$m2)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a5e83bcd69595728106bed838aeb32f70}{operator$\ast$} (const float $\ast$m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a95ceb3342a808c88d0bb7c1f7e0ef82b}{operator$\ast$} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&v, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a04f1e6e0f84169fce23b236e0312d6a0}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m, const \hyperlink{classprism_1_1_vector3}{Vector3} \&v)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_a5a10d8ea1e63b19d02bd294e4ebabb1b}{operator$\ast$} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&v, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_ad125bd8304d577b6f879fb973f774eb8}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m, const \hyperlink{classprism_1_1_vector4}{Vector4} \&v)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a44373b8bda7131a90d04eef7e455ea6f}{operator$\ast$} (const \hyperlink{classprism_1_1_point}{Point} \&p, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a82522932359d2381607cf1fe0c898011}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m, const \hyperlink{classprism_1_1_point}{Point} \&p)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a517b4bc9b0ccc23f79b744d93b540fa6}{operator/} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m, const float divisor)
\item 
const bool \hyperlink{namespaceprism_a8804ec2ab8dda9441d64e947f05e293c}{operator==} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
const bool \hyperlink{namespaceprism_a4d184994eec61a1511fc936a9facb69a}{operator!=} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_ab65e15b3e601e0570beb49a11610c671}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&matrix)
\item 
std\+::ostream \& \hyperlink{namespaceprism_acb9fe7ab8ef5f1ee0338e3b057624393}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_point}{Point} \&p)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a49e983b5c32c93114583309eda19dc2b}{operator+} (const \hyperlink{classprism_1_1_point}{Point} \&p1, const \hyperlink{classprism_1_1_point}{Point} \&p2)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a505cbd94f024ad80136afe0b751da08a}{operator-\/} (const \hyperlink{classprism_1_1_point}{Point} \&p1, const \hyperlink{classprism_1_1_point}{Point} \&p2)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a40976ce143923309d4c737bb8288d9e5}{operator$\ast$} (const \hyperlink{classprism_1_1_point}{Point} \&p, const int factor)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a96e41c0858ff4149eafa1bc878dabb7c}{operator$\ast$} (const \hyperlink{classprism_1_1_point}{Point} \&p, const float factor)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_aa46a547ddc48425588986b0840d026a4}{operator$\ast$} (const int factor, const \hyperlink{classprism_1_1_point}{Point} \&p)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a1ec2671f1e6c155a79740a8556baecc0}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_point}{Point} \&p)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a5f73aee33931e5b9977da32e50d47c0e}{operator/} (const \hyperlink{classprism_1_1_point}{Point} \&p, const float divisor)
\item 
bool \hyperlink{namespaceprism_a739baa4e75c1ca83624d486eec1d45e9}{operator==} (const \hyperlink{classprism_1_1_point}{Point} \&p1, const \hyperlink{classprism_1_1_point}{Point} \&p2)
\item 
bool \hyperlink{namespaceprism_a75cab41d882d24ca064927f2390ef3a6}{operator!=} (const \hyperlink{classprism_1_1_point}{Point} \&p1, const \hyperlink{classprism_1_1_point}{Point} \&p2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_acad408bf2576dfc62a573cb44aa895fb}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p)
\item 
\hyperlink{classprism_1_1_pointf}{Pointf} \hyperlink{namespaceprism_a64243aa2d4cf6ddb70526aaeda396f82}{operator+} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p1, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p2)
\item 
\hyperlink{classprism_1_1_pointf}{Pointf} \hyperlink{namespaceprism_a435d5c45d873875f2c5092d102eddb78}{operator-\/} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p1, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p2)
\item 
\hyperlink{classprism_1_1_pointf}{Pointf} \hyperlink{namespaceprism_ade1984e58679ef4d8fcdd37726ee6483}{operator$\ast$} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p, const float factor)
\item 
\hyperlink{classprism_1_1_pointf}{Pointf} \hyperlink{namespaceprism_a409aa6b61b79f029d78f6d4c3aba2df5}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p)
\item 
\hyperlink{classprism_1_1_pointf}{Pointf} \hyperlink{namespaceprism_a71504f6dd299e8bc788e07d11d29dc5e}{operator/} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p, const float divisor)
\item 
bool \hyperlink{namespaceprism_a13ab889958edc08eea9a5bea056cd9c1}{operator==} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p1, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p2)
\item 
bool \hyperlink{namespaceprism_ae010d5880eb7bcf5119f006e26bf473f}{operator!=} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p1, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p2)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_ad81bceaddc25922e571b4bf427ffe296}{operator+} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q1, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q2)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_a5eae37b5dc73c544572686f215cea89d}{operator-\/} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q1, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q2)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_ae04c2e5eae2242c58a967086ecad8ff4}{operator-\/} (\hyperlink{classprism_1_1_quaternion}{Quaternion} \&q)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_a74c3eeec91c3a178711b6f05a5487d70}{operator$\ast$} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q1, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q2)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_a45806b1a58ec5aae0db87d399d4d832b}{operator$\ast$} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q, const float factor)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_ad9f03413053b1efa6851344eb39a5982}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_a8aebd3615ba448915f37140515a37b05}{operator$\ast$} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q, const \hyperlink{classprism_1_1_vector3}{Vector3} \&v)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_a2c4c5e120d8c4de9891f2261a50f100e}{operator$\ast$} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q, const \hyperlink{classprism_1_1_vector4}{Vector4} \&v)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_aec648937a53338bcd9879670877d0425}{operator/} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q, const float divisor)
\item 
const bool \hyperlink{namespaceprism_ac4ae112433b9ab32c801cccc9c3f74f0}{operator==} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q1, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q2)
\item 
const bool \hyperlink{namespaceprism_a9e32551f997ae19dc52df146482405c1}{operator!=} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q1, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_ad2beaed7a837821f0abc608cf6ac6c0f}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q)
\item 
const bool \hyperlink{namespaceprism_abe409fa2ef458a2d477ed7845cf4b6a6}{operator==} (const \hyperlink{classprism_1_1_rect}{Rect} \&r1, const \hyperlink{classprism_1_1_rect}{Rect} \&r2)
\item 
const bool \hyperlink{namespaceprism_ad9f46c5ebd3cec844925173aaacbed9f}{operator!=} (const \hyperlink{classprism_1_1_rect}{Rect} \&r1, const \hyperlink{classprism_1_1_rect}{Rect} \&r2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a52fd2a97b66b06ba6e451e1890136ff4}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_rect}{Rect} \&rect)
\item 
const bool \hyperlink{namespaceprism_a2a7baeb09cd2ee29251667ad18a2bd00}{operator==} (const \hyperlink{classprism_1_1_size}{Size} \&s1, const \hyperlink{classprism_1_1_size}{Size} \&s2)
\item 
const bool \hyperlink{namespaceprism_a63ab3c18ecc73e21e7281dbe180e07e8}{operator!=} (const \hyperlink{classprism_1_1_size}{Size} \&s1, const \hyperlink{classprism_1_1_size}{Size} \&s2)
\item 
\hyperlink{classprism_1_1_size}{Size} \hyperlink{namespaceprism_a7141aeb35db81548155e44d60c05530e}{operator+} (const \hyperlink{classprism_1_1_size}{Size} \&s1, const \hyperlink{classprism_1_1_size}{Size} \&s2)
\item 
\hyperlink{classprism_1_1_size}{Size} \hyperlink{namespaceprism_ab170e3ca42d85a6766cbc7950ddfb0c4}{operator-\/} (const \hyperlink{classprism_1_1_size}{Size} \&s1, const \hyperlink{classprism_1_1_size}{Size} \&s2)
\item 
\hyperlink{classprism_1_1_size}{Size} \hyperlink{namespaceprism_a3d8e53ee3208e09e8736a77be3f485c9}{operator$\ast$} (const \hyperlink{classprism_1_1_size}{Size} \&size, const int factor)
\item 
\hyperlink{classprism_1_1_size}{Size} \hyperlink{namespaceprism_acd79758984cccce0dddfb459af65f6e1}{operator$\ast$} (const int factor, const \hyperlink{classprism_1_1_size}{Size} \&size)
\item 
\hyperlink{classprism_1_1_size}{Size} \hyperlink{namespaceprism_ad7e100bd6b1730deaab53d1218e29a67}{operator/} (const \hyperlink{classprism_1_1_size}{Size} \&size, const int factor)
\item 
std\+::ostream \& \hyperlink{namespaceprism_ad6335168e27f481d86ae42da444006d1}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_size}{Size} \&size)
\item 
const bool \hyperlink{namespaceprism_a0e7bfee93ae735b5af7e566ddd8c4f65}{operator==} (const \hyperlink{classprism_1_1_string}{String} \&str1, const \hyperlink{classprism_1_1_string}{String} \&str2)
\item 
const bool \hyperlink{namespaceprism_a5c2215edf9ab445c3c1791217d131b15}{operator!=} (const \hyperlink{classprism_1_1_string}{String} \&str1, const \hyperlink{classprism_1_1_string}{String} \&str2)
\item 
const \hyperlink{classprism_1_1_string}{String} \hyperlink{namespaceprism_a433f7afd310d95a93cf8c03d1f831812}{operator+} (const \hyperlink{classprism_1_1_string}{String} \&str1, const \hyperlink{classprism_1_1_string}{String} \&str2)
\item 
const \hyperlink{classprism_1_1_string}{String} \hyperlink{namespaceprism_a50879e9455a36b7762514951ca0f47f7}{operator+} (const \hyperlink{classprism_1_1_string}{String} \&str1, const char $\ast$str2)
\item 
const \hyperlink{classprism_1_1_string}{String} \hyperlink{namespaceprism_a7d59729f69eafd3bc9f4d30ad9dd06b6}{operator+} (const char $\ast$str1, const \hyperlink{classprism_1_1_string}{String} \&str2)
\item 
const \hyperlink{classprism_1_1_string}{String} \hyperlink{namespaceprism_aa0fce6a8b93050fcb6db327e68b701e3}{operator+} (const char c, const \hyperlink{classprism_1_1_string}{String} \&str)
\item 
const \hyperlink{classprism_1_1_string}{String} \hyperlink{namespaceprism_a8ae68ccc6eb3a47a748671c1a7af88ca}{operator+} (const \hyperlink{classprism_1_1_string}{String} \&str, const char c)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a0a166bbf645cc854542cc0fc50324670}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_string}{String} \&s)
\item 
\hyperlink{classprism_1_1_time}{Time} \hyperlink{namespaceprism_afd483f03b731881b25da5612b1213e5f}{operator+} (const \hyperlink{classprism_1_1_time}{Time} \&t1, const \hyperlink{classprism_1_1_time}{Time} \&t2)
\item 
\hyperlink{classprism_1_1_time}{Time} \hyperlink{namespaceprism_aa18009df22007fbbde08ab44b16a9a31}{operator-\/} (const \hyperlink{classprism_1_1_time}{Time} \&t1, const \hyperlink{classprism_1_1_time}{Time} \&t2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a7c24ead13d51c13dcadde1b6df4a4967}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_time}{Time} \&t)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_ae482804c32b466401a9ecdf26bc1e6de}{operator+} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&a, const \hyperlink{classprism_1_1_vector2}{Vector2} \&b)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_a86359a88dc5245847de48575a1f969e8}{operator-\/} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&a, const \hyperlink{classprism_1_1_vector2}{Vector2} \&b)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_a124f1081b3a9bbc441dac9927f8a0fc5}{operator-\/} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&v)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_a6528ec4496096e8ccde186bb01fbeed3}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_vector2}{Vector2} \&v)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_a1de3bc1dbc3fd33f26d580bce3520854}{operator$\ast$} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&v, const float factor)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_aea1ab02785c9d4d5ea560face252b75e}{operator/} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&v, const float divisor)
\item 
const bool \hyperlink{namespaceprism_a311fc983ec89876189643e840d781974}{operator==} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&a, const \hyperlink{classprism_1_1_vector2}{Vector2} \&b)
\item 
const bool \hyperlink{namespaceprism_a7e9d0b027a9e7d9e313affe5af91dabc}{operator!=} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&a, const \hyperlink{classprism_1_1_vector2}{Vector2} \&b)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a4616180b97f4288a3b3e28304efee020}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_vector2}{Vector2} \&v)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a7ac90b31f235390d6feb818e3f88ecf0}{operator+} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&a, const \hyperlink{classprism_1_1_vector3}{Vector3} \&b)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a3beb56b334423e027f1ab185785695f8}{operator-\/} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&a, const \hyperlink{classprism_1_1_vector3}{Vector3} \&b)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a8f7cf835ff415e187e6881169803f502}{operator-\/} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&v)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a429cccc5eee454ba019045afb4a01e93}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_vector3}{Vector3} \&v)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_aa1f2f6de8bf1b584cbb82062a607e167}{operator$\ast$} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&v, const float factor)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a87e022748076586917c38e83430df284}{operator/} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&v, const float divisor)
\item 
const bool \hyperlink{namespaceprism_a2fc2a483f2e3ec622ad2c0ac9699fbcb}{operator==} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&a, const \hyperlink{classprism_1_1_vector3}{Vector3} \&b)
\item 
const bool \hyperlink{namespaceprism_aa752c5d0210902dece31c2fcfc98a824}{operator!=} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&a, const \hyperlink{classprism_1_1_vector3}{Vector3} \&b)
\item 
std\+::ostream \& \hyperlink{namespaceprism_aa7b9367a483153af865552ba486f1196}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_vector3}{Vector3} \&v)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_a4ac9ebc0ce1449793eb8f521c64929a9}{operator+} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&a, const \hyperlink{classprism_1_1_vector4}{Vector4} \&b)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_a038a64f530d1c50bf72cf1a23886ecca}{operator-\/} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&a, const \hyperlink{classprism_1_1_vector4}{Vector4} \&b)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_a147712ae50c37618cbc61f20efe6729f}{operator-\/} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&v)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_aa652a61fe96302693aa0279e832360c7}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_vector4}{Vector4} \&v)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_ab3b4a59d9247143b49db3c2778838895}{operator$\ast$} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&v, const float factor)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_a4aa2b9a75c3d5134fc80cc6afc1be443}{operator/} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&v, const float divisor)
\item 
const bool \hyperlink{namespaceprism_a80bdef743a64c754bf1a2b217c82f60a}{operator==} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&a, const \hyperlink{classprism_1_1_vector4}{Vector4} \&b)
\item 
const bool \hyperlink{namespaceprism_a1ffa413af039c2bff07202dcfce55f05}{operator!=} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&a, const \hyperlink{classprism_1_1_vector4}{Vector4} \&b)
\item 
std\+::ostream \& \hyperlink{namespaceprism_aeb86919d9ba71747d21fbd6e28671692}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_vector4}{Vector4} \&v)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Completely and shamefully lifted from Qt\textquotesingle{}s Q\+Flag/\+Q\+Flags classes and macros and just renamed without the prepended \textquotesingle{}Q\textquotesingle{}. These classes allow enums to be treated as datatypes when passed to methods. They are also type-\/safe so that the receiving method is expecting the enum and not the basic int equivalent. So print\+Flag(\+Label\+::\+Align\+Left) works whilst print\+Flag(2) doesn\textquotesingle{}t.

For example,

class Label \{ private\+: enum Alignment \{ Align\+Left = 0x1, Align\+Right = 0x2 \} \hyperlink{_flags_8h_aa5aa2c9827ab949836e20999b9a068ec}{P\+R\+I\+S\+M\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+F\+L\+A\+G\+S(\+Align\+Flags, Alignment)} \}

// outside class def \hyperlink{_flags_8h_ae8aabb683a18b872a4449769b82e8e15}{P\+R\+I\+S\+M\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+O\+P\+E\+R\+A\+T\+O\+R\+S\+\_\+\+F\+O\+R\+\_\+\+F\+L\+A\+G\+S(\+Label\+::\+Align\+Flags)}

void print\+Flag(\+Label\+::\+Align\+Flags f) \{ if (f == Label\+::\+Align\+Left) std\+::cout $<$$<$ \char`\"{}\+Align\+Left\char`\"{} $<$$<$ std\+::endl; else if (f == Label\+::\+Align\+Right) std\+::cout $<$$<$ \char`\"{}\+Align\+Right\char`\"{} $<$$<$ std\+::endl; else std\+::cout $<$$<$ f $<$$<$ std\+::endl; \}

int main(int argc, char$\ast$$\ast$ argv) \{ print\+Flag(\+Label\+::\+Align\+Left); \}

A \hyperlink{classprism_1_1_quaternion}{Quaternion} is made up of four components (w, x, y and z) which are a scalar (w) and a 3d vector (x, y and z). It does not suffer from gimbal lock and yet can represent any orientation possible.

Some interesting properties of quaternion multiplication\+: a) it is associative but not commutitive -\/ (ab)c = a(bc) ab != ba

b) the magnitude of a quaternion product equals the product of the individual magnitudes. This is an important concept because when quaternions are of unit length and are multiplied, this guarentees us that the result will itself be a unit quaternion -\/ $\vert$$\vert$ab$\vert$$\vert$ = $\vert$$\vert$a$\vert$$\vert$$\vert$$\vert$b$\vert$$\vert$

c) the inverse of a quaternion product is equal to the product of the individual quaternion inverses in reverse order -\/ (ab).inverse = (b.\+inverse) $\ast$ (a.\+inverse)

Rotating vectors\+: When rotating with a quaternion it is important that the quaternion be normalised i.\+e. be of unit length. This is because otherwise scaling will occur and since we only require rotations from our quaternions this won\textquotesingle{}t do. Rotating a vector using quaternions is done with the following equation\+: v\textquotesingle{} = q $\ast$ v $\ast$ q.\+inverse where vector v is represented as a quaternion.

Concatenating rotational transforms together\+: Multiple quaternion rotations can be applied to a vector in one single action by concatenating the rotational quaternions together and then applying them to the vector using the above equation. For example, to rotate the vector v by quaternion a and then rotating that result by quaternion b would be as follows\+: v\textquotesingle{} = b $\ast$ (a $\ast$ v $\ast$ a.\+inverse) $\ast$ b.\+inverse = (b $\ast$ a) $\ast$ v $\ast$ (b.\+inverse $\ast$ a.\+inverse) = (b $\ast$ a) $\ast$ v $\ast$ (b $\ast$ a).inverse So, rotating by a and then by b is equivalent to the single rotation of the product of ba. 

\subsection{Function Documentation}
\index{prism@{prism}!adjacent\+\_\+find@{adjacent\+\_\+find}}
\index{adjacent\+\_\+find@{adjacent\+\_\+find}!prism@{prism}}
\subsubsection[{\texorpdfstring{adjacent\+\_\+find(\+Forward\+Iterator first, Forward\+Iterator last)}{adjacent_find(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ Forward\+Iterator prism\+::adjacent\+\_\+find (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a82052418345794a13044c15d8e32dd89}{}\label{namespaceprism_a82052418345794a13044c15d8e32dd89}
Searches the range {\itshape }\mbox{[}first,last\mbox{]} for the first occurrence of two consecutive elements that match. \begin{DoxyReturn}{Returns}
Returns an iterator to the first of these two elements, or {\itshape last} if no such pair is found. 
\end{DoxyReturn}
\index{prism@{prism}!all\+\_\+of@{all\+\_\+of}}
\index{all\+\_\+of@{all\+\_\+of}!prism@{prism}}
\subsubsection[{\texorpdfstring{all\+\_\+of(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{all_of(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ bool prism\+::all\+\_\+of (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aba366b328f3b6161e6115c16b7153c6d}{}\label{namespaceprism_aba366b328f3b6161e6115c16b7153c6d}
Returns true if {\itshape pred} returns true for all the elements in the range {\itshape }\mbox{[}first,last\mbox{]} or if the range is empty, and false otherwise. \index{prism@{prism}!any\+\_\+of@{any\+\_\+of}}
\index{any\+\_\+of@{any\+\_\+of}!prism@{prism}}
\subsubsection[{\texorpdfstring{any\+\_\+of(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{any_of(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ bool prism\+::any\+\_\+of (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5d0e3ddb9f698759635572f1220ec0ca}{}\label{namespaceprism_a5d0e3ddb9f698759635572f1220ec0ca}
Returns true if {\itshape pred} returns true for any of the elements in the range {\itshape }\mbox{[}first, last\mbox{]}. \index{prism@{prism}!copy@{copy}}
\index{copy@{copy}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First)}{copy(InputIterator first, InputIterator last, OutputIterator otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator $>$ Output\+Iterator prism\+::copy (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}{}\label{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} into the range beginning at {\itshape other\+First}. \index{prism@{prism}!copy\+\_\+backward@{copy\+\_\+backward}}
\index{copy\+\_\+backward@{copy\+\_\+backward}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy\+\_\+backward(\+Bidirectional\+Iterator1 first, Bidirectional\+Iterator1 last, Bidirectional\+Iterator2 other\+Last)}{copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 otherLast)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Bidirectional\+Iterator1 , class Bidirectional\+Iterator2 $>$ Bidirectional\+Iterator2 prism\+::copy\+\_\+backward (
\begin{DoxyParamCaption}
\item[{Bidirectional\+Iterator1}]{first, }
\item[{Bidirectional\+Iterator1}]{last, }
\item[{Bidirectional\+Iterator2}]{other\+Last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2564c63b76369cc81ff725a56e818046}{}\label{namespaceprism_a2564c63b76369cc81ff725a56e818046}
Copies the elements in the range \mbox{[}first,last\mbox{]} starting from {\itshape last} to the range ending at {\itshape other\+Last}. The elements copied are between {\itshape first} and {\itshape last}, including {\itshape first} but not {\itshape last}. {\itshape other\+Last} should point to the past-\/the-\/end position of the destination range. \index{prism@{prism}!copy\+\_\+if@{copy\+\_\+if}}
\index{copy\+\_\+if@{copy\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Predicate pred)}{copy_if(InputIterator first, InputIterator last, OutputIterator otherFirst, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class Predicate $>$ Output\+Iterator prism\+::copy\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_afbed55ae6769c2d88c125aedc2f3846e}{}\label{namespaceprism_afbed55ae6769c2d88c125aedc2f3846e}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} for which {\itshape pred} returns true to the range beginning at {\itshape other\+First}. \index{prism@{prism}!copy\+\_\+n@{copy\+\_\+n}}
\index{copy\+\_\+n@{copy\+\_\+n}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy\+\_\+n(\+Input\+Iterator first, Size n, Output\+Iterator other\+First)}{copy_n(InputIterator first, Size n, OutputIterator otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Size , class Output\+Iterator $>$ Output\+Iterator prism\+::copy\+\_\+n (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{{\bf Size}}]{n, }
\item[{Output\+Iterator}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af907f3f5637d4ec056e9b833b6272953}{}\label{namespaceprism_af907f3f5637d4ec056e9b833b6272953}
Copies the first {\itshape n} elements from the range beginning at {\itshape first} into the range beginning at {\itshape other\+First}. \index{prism@{prism}!count@{count}}
\index{count@{count}!prism@{prism}}
\subsubsection[{\texorpdfstring{count(\+Input\+Iterator first, Input\+Iterator last, const T \&value)}{count(InputIterator first, InputIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class T $>$ int prism\+::count (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a024117fc3639cdf6598509edf22f034a}{}\label{namespaceprism_a024117fc3639cdf6598509edf22f034a}
Returns the number of elements in the range {\itshape }\mbox{[}first,last\mbox{]} that compare equal to {\itshape value}. \index{prism@{prism}!count\+\_\+if@{count\+\_\+if}}
\index{count\+\_\+if@{count\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{count\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{count_if(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ int prism\+::count\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af0007d361beae18a930b6249752e509e}{}\label{namespaceprism_af0007d361beae18a930b6249752e509e}
Returns the number of elements in the range {\itshape }\mbox{[}first,last\mbox{]} for which {\itshape pred} is true. \index{prism@{prism}!delete\+\_\+range@{delete\+\_\+range}}
\index{delete\+\_\+range@{delete\+\_\+range}!prism@{prism}}
\subsubsection[{\texorpdfstring{delete\+\_\+range(\+Forward\+Iterator first, Forward\+Iterator last)}{delete_range(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ void prism\+::delete\+\_\+range (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a83e62e5b148c55f949e5ea843d53ad67}{}\label{namespaceprism_a83e62e5b148c55f949e5ea843d53ad67}
Deletes the elements in the range {\itshape }\mbox{[}first, last\mbox{]} by using the c++ delete operator. The element that the iterator points to therefore must be a pointer. \index{prism@{prism}!equal@{equal}}
\index{equal@{equal}!prism@{prism}}
\subsubsection[{\texorpdfstring{equal(\+Input\+Iterator1 first, Input\+Iterator1 last, Input\+Iterator2 other\+First)}{equal(InputIterator1 first, InputIterator1 last, InputIterator2 otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator1 , class Input\+Iterator2 $>$ bool prism\+::equal (
\begin{DoxyParamCaption}
\item[{Input\+Iterator1}]{first, }
\item[{Input\+Iterator1}]{last, }
\item[{Input\+Iterator2}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad3bede9a0f2c648e93677b14c45b1b7b}{}\label{namespaceprism_ad3bede9a0f2c648e93677b14c45b1b7b}
Compares the elements in the range {\itshape }\mbox{[}first1,last1\mbox{]} with those in the range beginning at {\itshape other\+First}, and returns true if all of the elements in both ranges match. ~\newline
\begin{DoxyNote}{Note}
The elements being compared must support \hyperlink{namespaceprism_ae53d52e8a36ec7ca58ea1731cc18f1d8}{operator==()}. 
\end{DoxyNote}
\index{prism@{prism}!fill@{fill}}
\index{fill@{fill}!prism@{prism}}
\subsubsection[{\texorpdfstring{fill(\+Forward\+Iterator first, Forward\+Iterator last, const T \&value)}{fill(ForwardIterator first, ForwardIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::fill (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{}\label{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}
Assigns {\itshape value} to all the elements in the range {\itshape }\mbox{[}first,last\mbox{]}. \index{prism@{prism}!fill\+\_\+n@{fill\+\_\+n}}
\index{fill\+\_\+n@{fill\+\_\+n}!prism@{prism}}
\subsubsection[{\texorpdfstring{fill\+\_\+n(\+Forward\+Iterator first, int size, const T \&value)}{fill_n(ForwardIterator first, int size, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::fill\+\_\+n (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{int}]{size, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aceb4b9c511a5edb706296b457427b226}{}\label{namespaceprism_aceb4b9c511a5edb706296b457427b226}
Assigns {\itshape value} to the first {\itshape n} elements of the sequence pointed by {\itshape first}. \index{prism@{prism}!find@{find}}
\index{find@{find}!prism@{prism}}
\subsubsection[{\texorpdfstring{find(\+Input\+Iterator first, Input\+Iterator last, const T \&value)}{find(InputIterator first, InputIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class T $>$ Input\+Iterator prism\+::find (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1b543d9c2862a539cc8b770abda87561}{}\label{namespaceprism_a1b543d9c2862a539cc8b770abda87561}
Returns an iterator to the first element in the range {\itshape }\mbox{[}first,last\mbox{]} that compares equal to {\itshape value}. If no such element is found, the function returns {\itshape last}. \index{prism@{prism}!find\+\_\+if@{find\+\_\+if}}
\index{find\+\_\+if@{find\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{find\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{find_if(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ Input\+Iterator prism\+::find\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa17e9e6c80f8a52479a52450a108a636}{}\label{namespaceprism_aa17e9e6c80f8a52479a52450a108a636}
Returns an iterator to the first element in the range {\itshape }\mbox{[}first,last\mbox{]} for which {\itshape pred} returns true. If no such element is found, the function returns {\itshape last}. \index{prism@{prism}!find\+\_\+last@{find\+\_\+last}}
\index{find\+\_\+last@{find\+\_\+last}!prism@{prism}}
\subsubsection[{\texorpdfstring{find\+\_\+last(\+Input\+Iterator first, Input\+Iterator last, const T \&value)}{find_last(InputIterator first, InputIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class T $>$ Input\+Iterator prism\+::find\+\_\+last (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a3189014b9fa31e0ef0d1933c6f616618}{}\label{namespaceprism_a3189014b9fa31e0ef0d1933c6f616618}
Returns an iterator to the last element in the range {\itshape }\mbox{[}first,last\mbox{]} that compares equal to {\itshape value}. The range searched is {\itshape }\mbox{[}first,last), which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. If no match is found then a null pointer is returned instead i.\+e. p=0; \index{prism@{prism}!for\+\_\+each@{for\+\_\+each}}
\index{for\+\_\+each@{for\+\_\+each}!prism@{prism}}
\subsubsection[{\texorpdfstring{for\+\_\+each(\+Input\+Iterator first, Input\+Iterator last, Function func)}{for_each(InputIterator first, InputIterator last, Function func)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Function $>$ Function prism\+::for\+\_\+each (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Function}]{func}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aae062d5bfdc0e53ae49c56520aded906}{}\label{namespaceprism_aae062d5bfdc0e53ae49c56520aded906}
Applies function {\itshape func} to each of the elements in the range {\itshape }\mbox{[}first,last\mbox{]}. \index{prism@{prism}!is\+\_\+sorted@{is\+\_\+sorted}}
\index{is\+\_\+sorted@{is\+\_\+sorted}!prism@{prism}}
\subsubsection[{\texorpdfstring{is\+\_\+sorted(\+Forward\+Iterator first, Forward\+Iterator last)}{is_sorted(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ const bool prism\+::is\+\_\+sorted (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_acf5efbeb096446c47690b9e8bd2cc01a}{}\label{namespaceprism_acf5efbeb096446c47690b9e8bd2cc01a}
Returns true if the elements in the range {\itshape }\mbox{[}first,last\mbox{]} are sorted in ascending order, false otherwise. The range searched is {\itshape }\mbox{[}first,last), which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. \index{prism@{prism}!make\+\_\+heap@{make\+\_\+heap}}
\index{make\+\_\+heap@{make\+\_\+heap}!prism@{prism}}
\subsubsection[{\texorpdfstring{make\+\_\+heap(\+Random\+Access\+Iterator first, Random\+Access\+Iterator last)}{make_heap(RandomAccessIterator first, RandomAccessIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Random\+Access\+Iterator $>$ void prism\+::make\+\_\+heap (
\begin{DoxyParamCaption}
\item[{Random\+Access\+Iterator}]{first, }
\item[{Random\+Access\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af8e36230e6cb92a41aaca282772a9e6e}{}\label{namespaceprism_af8e36230e6cb92a41aaca282772a9e6e}
Rearranges the elements in the range {\itshape }\mbox{[}first,last\mbox{]} so that they satisfy the order conditions of a heap.~\newline
The range searched is {\itshape }\mbox{[}first,last), which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. \index{prism@{prism}!max@{max}}
\index{max@{max}!prism@{prism}}
\subsubsection[{\texorpdfstring{max(const T \&a, const T \&b)}{max(const T &a, const T &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ const T\& prism\+::max (
\begin{DoxyParamCaption}
\item[{const T \&}]{a, }
\item[{const T \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a812456273adfa37979e79f07e731d412}{}\label{namespaceprism_a812456273adfa37979e79f07e731d412}
Returns the largest of {\itshape a} and {\itshape b}. If they are equivalent then {\itshape a} is returned. \index{prism@{prism}!min@{min}}
\index{min@{min}!prism@{prism}}
\subsubsection[{\texorpdfstring{min(const T \&a, const T \&b)}{min(const T &a, const T &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ const T\& prism\+::min (
\begin{DoxyParamCaption}
\item[{const T \&}]{a, }
\item[{const T \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a10aff0aca673fb1837069dd8967e4738}{}\label{namespaceprism_a10aff0aca673fb1837069dd8967e4738}
Returns the smallest of {\itshape a} and {\itshape b}. If they are equivalent then {\itshape a} is returned. \index{prism@{prism}!none\+\_\+of@{none\+\_\+of}}
\index{none\+\_\+of@{none\+\_\+of}!prism@{prism}}
\subsubsection[{\texorpdfstring{none\+\_\+of(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{none_of(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ bool prism\+::none\+\_\+of (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a10c83b433c7f98fd4513f1b68c6db594}{}\label{namespaceprism_a10c83b433c7f98fd4513f1b68c6db594}
Returns true if {\itshape pred} returns false for all the elements in the range {\itshape }\mbox{[}first,last\mbox{]} or if the range is empty, and false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Shared\+Pointer$<$ U $>$ \&p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator!=(const SharedPointer< U > &p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9df924e4deb059bf1200701c8235410a}{}\label{namespaceprism_a9df924e4deb059bf1200701c8235410a}
Returns true if the managed pointers of p1 and p2 do not point to the same data, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Shared\+Pointer$<$ U $>$ \&p1, const U $\ast$p2)}{operator!=(const SharedPointer< U > &p1, const U *p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const U $\ast$}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad6391c124e006b0e3a3ec67f55e208b0}{}\label{namespaceprism_ad6391c124e006b0e3a3ec67f55e208b0}
Returns true if the managed pointer of p1 and the raw pointer p2 do not point to the same data, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Char \&c1, const Char \&c2)}{operator!=(const Char &c1, const Char &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Char} \&}]{c1, }
\item[{const {\bf Char} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a249b6933154570d808cdd405ab1fd89b}{}\label{namespaceprism_a249b6933154570d808cdd405ab1fd89b}
\begin{DoxyReturn}{Returns}
Returns true if the chars {\itshape c1} and {\itshape c2} are not equal, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const U $\ast$p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator!=(const U *p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const U $\ast$}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab8792dbd5cac5678390843bacdb69daa}{}\label{namespaceprism_ab8792dbd5cac5678390843bacdb69daa}
Returns true if the raw pointer p1 and the managed pointer of p2 do not point to the same data, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Pointf \&p1, const Pointf \&p2)}{operator!=(const Pointf &p1, const Pointf &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p1, }
\item[{const {\bf Pointf} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae010d5880eb7bcf5119f006e26bf473f}{}\label{namespaceprism_ae010d5880eb7bcf5119f006e26bf473f}
Returns true if x or y of p1 and p2 are not equal, false if not \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Size \&s1, const Size \&s2)}{operator!=(const Size &s1, const Size &s2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{s1, }
\item[{const {\bf Size} \&}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a63ab3c18ecc73e21e7281dbe180e07e8}{}\label{namespaceprism_a63ab3c18ecc73e21e7281dbe180e07e8}
Returns true if the widths are equal and the heights are not equal of both \hyperlink{classprism_1_1_size}{Size} objects. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Fraction \&f1, const Fraction \&f2)}{operator!=(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aea72179b12983e614f72acd2b3cbf0e0}{}\label{namespaceprism_aea72179b12983e614f72acd2b3cbf0e0}
Returns true if /em f1 does not equal /em f2 in value, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Point \&p1, const Point \&p2)}{operator!=(const Point &p1, const Point &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p1, }
\item[{const {\bf Point} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a75cab41d882d24ca064927f2390ef3a6}{}\label{namespaceprism_a75cab41d882d24ca064927f2390ef3a6}
Returns true if x or y of p1 and p2 are not equal, false if not \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Vector2 \&a, const Vector2 \&b)}{operator!=(const Vector2 &a, const Vector2 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{a, }
\item[{const {\bf Vector2} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7e9d0b027a9e7d9e313affe5af91dabc}{}\label{namespaceprism_a7e9d0b027a9e7d9e313affe5af91dabc}
Compares the vectors and returns true if a and b are not equal, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Vector4 \&a, const Vector4 \&b)}{operator!=(const Vector4 &a, const Vector4 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{a, }
\item[{const {\bf Vector4} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1ffa413af039c2bff07202dcfce55f05}{}\label{namespaceprism_a1ffa413af039c2bff07202dcfce55f05}
Compares the vectors and returns true if a and b are not equal, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Vector3 \&a, const Vector3 \&b)}{operator!=(const Vector3 &a, const Vector3 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{a, }
\item[{const {\bf Vector3} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa752c5d0210902dece31c2fcfc98a824}{}\label{namespaceprism_aa752c5d0210902dece31c2fcfc98a824}
Compares the vectors and returns true if a and b are not equal, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Quaternion \&q1, const Quaternion \&q2)}{operator!=(const Quaternion &q1, const Quaternion &q2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q1, }
\item[{const {\bf Quaternion} \&}]{q2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9e32551f997ae19dc52df146482405c1}{}\label{namespaceprism_a9e32551f997ae19dc52df146482405c1}
Compares q1 and q2 and returns true if they are not equal, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Bitvector \&bv1, const Bitvector \&bv2)}{operator!=(const Bitvector &bv1, const Bitvector &bv2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Bitvector} \&}]{bv1, }
\item[{const {\bf Bitvector} \&}]{bv2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aca663878d61686ef365f3e51efddc4b4}{}\label{namespaceprism_aca663878d61686ef365f3e51efddc4b4}
\begin{DoxyReturn}{Returns}
Returns true if the two Bitvectors are not equal to each other, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Circle \&c1, const Circle \&c2)}{operator!=(const Circle &c1, const Circle &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Circle} \&}]{c1, }
\item[{const {\bf Circle} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a58cbf7ef406800002b446a0f1e917745}{}\label{namespaceprism_a58cbf7ef406800002b446a0f1e917745}
\begin{DoxyReturn}{Returns}
Returns true if both circles are not equal, false otherwsie. 
\end{DoxyReturn}
\index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Rect \&r1, const Rect \&r2)}{operator!=(const Rect &r1, const Rect &r2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Rect} \&}]{r1, }
\item[{const {\bf Rect} \&}]{r2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad9f46c5ebd3cec844925173aaacbed9f}{}\label{namespaceprism_ad9f46c5ebd3cec844925173aaacbed9f}
Returns true if the rectangles {\itshape r1} and {\itshape r2} are not equal, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Matrix4 \&m1, const Matrix4 \&m2)}{operator!=(const Matrix4 &m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4d184994eec61a1511fc936a9facb69a}{}\label{namespaceprism_a4d184994eec61a1511fc936a9facb69a}
Compares the elements of the two matrices and returns true if they don\textquotesingle{}t contain the same data, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const String \&str1, const String \&str2)}{operator!=(const String &str1, const String &str2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf String} \&}]{str1, }
\item[{const {\bf String} \&}]{str2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5c2215edf9ab445c3c1791217d131b15}{}\label{namespaceprism_a5c2215edf9ab445c3c1791217d131b15}
\index{prism@{prism}!operator\&@{operator\&}}
\index{operator\&@{operator\&}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator\&(const Bitvector \&bv1, const Bitvector \&bv2)}{operator&(const Bitvector &bv1, const Bitvector &bv2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Bitvector} prism\+::operator\& (
\begin{DoxyParamCaption}
\item[{const {\bf Bitvector} \&}]{bv1, }
\item[{const {\bf Bitvector} \&}]{bv2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a26b2b2b5b2c5f305badd964c24625b36}{}\label{namespaceprism_a26b2b2b5b2c5f305badd964c24625b36}
Performs a bitwise A\+ND on {\itshape bv1} and {\itshape bv2}. \begin{DoxyReturn}{Returns}
Returns a new \hyperlink{classprism_1_1_bitvector}{Bitvector} with the result of {\itshape }(bv1 \& bv2). 
\end{DoxyReturn}
\index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Fraction \&f1, const Fraction \&f2)}{operator*(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ac4f48e3429a86bafcc7c21a2bd6a7ae1}{}\label{namespaceprism_ac4f48e3429a86bafcc7c21a2bd6a7ae1}
Multiplies /em f1 and /em f2 together and returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. \hyperlink{classprism_1_1_fraction}{Fraction} multiplication is the easiest arithmetical operation. Simply multiply the two numerators together to form the new numerator and multiply the two denominators together to form the new denominator. e.\+g. 2 8 2x8 16 4 --- x --- = --- = --- = --- 5 4 5x4 20 5 \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Fraction \&fraction, const int i)}{operator*(const Fraction &fraction, const int i)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{fraction, }
\item[{const int}]{i}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1f5007702b28b447f62c3b9df62f2aa4}{}\label{namespaceprism_a1f5007702b28b447f62c3b9df62f2aa4}
Multiplies the \hyperlink{classprism_1_1_fraction}{Fraction} /em fraction by the whole number /em i. Returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Pointf \&p, const float factor)}{operator*(const Pointf &p, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pointf} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ade1984e58679ef4d8fcdd37726ee6483}{}\label{namespaceprism_ade1984e58679ef4d8fcdd37726ee6483}
Returns a \hyperlink{classprism_1_1_pointf}{Pointf} object that is formed by multiplying the components of p by the float factor \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Pointf \&p)}{operator*(const float factor, const Pointf &p)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pointf} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Pointf} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a409aa6b61b79f029d78f6d4c3aba2df5}{}\label{namespaceprism_a409aa6b61b79f029d78f6d4c3aba2df5}
\index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const int i, const Fraction \&fraction)}{operator*(const int i, const Fraction &fraction)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const int}]{i, }
\item[{const {\bf Fraction} \&}]{fraction}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af1ff5871f65565a84b886c5013bcd50a}{}\label{namespaceprism_af1ff5871f65565a84b886c5013bcd50a}
Multiplies the whole number /em i by the \hyperlink{classprism_1_1_fraction}{Fraction} /em fraction. Returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Point \&p, const int factor)}{operator*(const Point &p, const int factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p, }
\item[{const int}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a40976ce143923309d4c737bb8288d9e5}{}\label{namespaceprism_a40976ce143923309d4c737bb8288d9e5}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by multiplying the components of p by the int factor \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Point \&p, const float factor)}{operator*(const Point &p, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a96e41c0858ff4149eafa1bc878dabb7c}{}\label{namespaceprism_a96e41c0858ff4149eafa1bc878dabb7c}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by multiplying the components of p by the float factor Note\+: the x and y components are rounded to the nearest integer as they are stored as ints internally. Use \hyperlink{classprism_1_1_pointf}{Pointf} for floating point accuracy instead. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const int factor, const Point \&p)}{operator*(const int factor, const Point &p)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const int}]{factor, }
\item[{const {\bf Point} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa46a547ddc48425588986b0840d026a4}{}\label{namespaceprism_aa46a547ddc48425588986b0840d026a4}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by multiplying the components of p by the int factor \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Point \&p)}{operator*(const float factor, const Point &p)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Point} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1ec2671f1e6c155a79740a8556baecc0}{}\label{namespaceprism_a1ec2671f1e6c155a79740a8556baecc0}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by multiplying the components of p by the float factor Note\+: the x and y components are rounded to the nearest integer as they are stored as ints internally. Use \hyperlink{classprism_1_1_pointf}{Pointf} for floating point accuracy instead. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Size \&size, const int factor)}{operator*(const Size &size, const int factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Size} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{size, }
\item[{const int}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a3d8e53ee3208e09e8736a77be3f485c9}{}\label{namespaceprism_a3d8e53ee3208e09e8736a77be3f485c9}
Multiplies {\itshape size} by {\itshape factor} and returns a new \hyperlink{classprism_1_1_size}{Size} object. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const int factor, const Size \&size)}{operator*(const int factor, const Size &size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Size} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const int}]{factor, }
\item[{const {\bf Size} \&}]{size}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_acd79758984cccce0dddfb459af65f6e1}{}\label{namespaceprism_acd79758984cccce0dddfb459af65f6e1}
Multiplies {\itshape size} by {\itshape factor} and returns a new \hyperlink{classprism_1_1_size}{Size} object. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Vector2 \&v)}{operator*(const float factor, const Vector2 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Vector2} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6528ec4496096e8ccde186bb01fbeed3}{}\label{namespaceprism_a6528ec4496096e8ccde186bb01fbeed3}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Vector2 \&v, const float factor)}{operator*(const Vector2 &v, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{v, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1de3bc1dbc3fd33f26d580bce3520854}{}\label{namespaceprism_a1de3bc1dbc3fd33f26d580bce3520854}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Quaternion \&q1, const Quaternion \&q2)}{operator*(const Quaternion &q1, const Quaternion &q2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q1, }
\item[{const {\bf Quaternion} \&}]{q2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a74c3eeec91c3a178711b6f05a5487d70}{}\label{namespaceprism_a74c3eeec91c3a178711b6f05a5487d70}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the product of q1 and q2. Note\+: quaternion multiplication is associative so a(bc) = (ab)c but is not commutitive so q1q2 does not always equal q2q1. Order matters! \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Vector4 \&v)}{operator*(const float factor, const Vector4 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Vector4} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa652a61fe96302693aa0279e832360c7}{}\label{namespaceprism_aa652a61fe96302693aa0279e832360c7}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Vector4 \&v, const float factor)}{operator*(const Vector4 &v, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{v, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab3b4a59d9247143b49db3c2778838895}{}\label{namespaceprism_ab3b4a59d9247143b49db3c2778838895}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Vector3 \&v)}{operator*(const float factor, const Vector3 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Vector3} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a429cccc5eee454ba019045afb4a01e93}{}\label{namespaceprism_a429cccc5eee454ba019045afb4a01e93}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Vector3 \&v, const float factor)}{operator*(const Vector3 &v, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{v, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa1f2f6de8bf1b584cbb82062a607e167}{}\label{namespaceprism_aa1f2f6de8bf1b584cbb82062a607e167}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Quaternion \&q, const float factor)}{operator*(const Quaternion &q, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a45806b1a58ec5aae0db87d399d4d832b}{}\label{namespaceprism_a45806b1a58ec5aae0db87d399d4d832b}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the result of multiplying each component of q by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Quaternion \&q)}{operator*(const float factor, const Quaternion &q)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Quaternion} \&}]{q}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad9f03413053b1efa6851344eb39a5982}{}\label{namespaceprism_ad9f03413053b1efa6851344eb39a5982}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the result of multiplying each component of q by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Quaternion \&q, const Vector3 \&v)}{operator*(const Quaternion &q, const Vector3 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q, }
\item[{const {\bf Vector3} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8aebd3615ba448915f37140515a37b05}{}\label{namespaceprism_a8aebd3615ba448915f37140515a37b05}
Multiplies a quaternion and vector3 together and returns a quaternion as a result. The vector is just transformed into a quaternion (setting w = 0) and then the two quaternions are multiplied. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Quaternion \&q, const Vector4 \&v)}{operator*(const Quaternion &q, const Vector4 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q, }
\item[{const {\bf Vector4} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2c4c5e120d8c4de9891f2261a50f100e}{}\label{namespaceprism_a2c4c5e120d8c4de9891f2261a50f100e}
Multiplies a quaternion and \hyperlink{classprism_1_1_vector4}{Vector4} together and returns a quaternion as a result. The vector is just transformed into a quaternion and then the two quaternions are multiplied. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m1, const Matrix4 \&m2)}{operator*(const Matrix4 &m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9ae44fb46bb709a5c8f4d592baf65522}{}\label{namespaceprism_a9ae44fb46bb709a5c8f4d592baf65522}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} that is the product of m1 and m2 i.\+e. m1m2 \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Matrix4 \&m)}{operator*(const float factor, const Matrix4 &m)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Matrix4} \&}]{m}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab3639f7bd46a54726522dfe406841ea9}{}\label{namespaceprism_ab3639f7bd46a54726522dfe406841ea9}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} where each component of m is multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m, const float factor)}{operator*(const Matrix4 &m, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4073983f089695c40b6fd20d892175f9}{}\label{namespaceprism_a4073983f089695c40b6fd20d892175f9}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} where each component of m is multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m1, const float $\ast$m2)}{operator*(const Matrix4 &m1, const float *m2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const float $\ast$}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa2859acb8e8dd6fea8678e14249e561d}{}\label{namespaceprism_aa2859acb8e8dd6fea8678e14249e561d}
Returns a \hyperlink{classprism_1_1_matrix4}{Matrix4} that is the result of multiplying a \hyperlink{classprism_1_1_matrix4}{Matrix4} with a float array. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float $\ast$m1, const Matrix4 \&m2)}{operator*(const float *m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float $\ast$}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5e83bcd69595728106bed838aeb32f70}{}\label{namespaceprism_a5e83bcd69595728106bed838aeb32f70}
Returns a \hyperlink{classprism_1_1_matrix4}{Matrix4} that is the result of multiplying a \hyperlink{classprism_1_1_matrix4}{Matrix4} with a float array. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Vector3 \&v, const Matrix4 \&m)}{operator*(const Vector3 &v, const Matrix4 &m)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{v, }
\item[{const {\bf Matrix4} \&}]{m}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a95ceb3342a808c88d0bb7c1f7e0ef82b}{}\label{namespaceprism_a95ceb3342a808c88d0bb7c1f7e0ef82b}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} which has been transformed by the matrix M in the order of vM. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m, const Vector3 \&v)}{operator*(const Matrix4 &m, const Vector3 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m, }
\item[{const {\bf Vector3} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a04f1e6e0f84169fce23b236e0312d6a0}{}\label{namespaceprism_a04f1e6e0f84169fce23b236e0312d6a0}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} which has been transformed by the matrix M in the order of Mv. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Vector4 \&v, const Matrix4 \&m)}{operator*(const Vector4 &v, const Matrix4 &m)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{v, }
\item[{const {\bf Matrix4} \&}]{m}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5a10d8ea1e63b19d02bd294e4ebabb1b}{}\label{namespaceprism_a5a10d8ea1e63b19d02bd294e4ebabb1b}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} which has been transformed by the matrix M in the order of vM. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m, const Vector4 \&v)}{operator*(const Matrix4 &m, const Vector4 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m, }
\item[{const {\bf Vector4} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad125bd8304d577b6f879fb973f774eb8}{}\label{namespaceprism_ad125bd8304d577b6f879fb973f774eb8}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} which has been transformed by the matrix M in the order of Mv. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Point \&p, const Matrix4 \&m)}{operator*(const Point &p, const Matrix4 &m)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p, }
\item[{const {\bf Matrix4} \&}]{m}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a44373b8bda7131a90d04eef7e455ea6f}{}\label{namespaceprism_a44373b8bda7131a90d04eef7e455ea6f}
Returns a \hyperlink{classprism_1_1_point}{Point} which has been transformed by the matrix m in the order of pM \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m, const Point \&p)}{operator*(const Matrix4 &m, const Point &p)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m, }
\item[{const {\bf Point} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a82522932359d2381607cf1fe0c898011}{}\label{namespaceprism_a82522932359d2381607cf1fe0c898011}
Returns a \hyperlink{classprism_1_1_point}{Point} which has been transformed by the matrix M in the order of Mp \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Fraction \&f1, const Fraction \&f2)}{operator+(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ac1b5b2765c314b2baa2dba5c57419829}{}\label{namespaceprism_ac1b5b2765c314b2baa2dba5c57419829}
Adds the fractions /em f1 and /em f2 together and returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. If the two denominators are the same then the two numerators are added together to form the new numerator and the original denominator is kept the same. e.\+g. 1 1 2 --- + --- = --- 4 4 4 If the denominators are different then we alter the fractions in order to make both denominators the same value. We make a whole fraction out of the second fraction\textquotesingle{}s denominator and multiply it by the first fraction. Then make a whole fraction from the first fraction\textquotesingle{}s denominator and multiply it by the second fraction. Now we can simply add together the two numerators and keep the denominator the same. 1 1 $\vert$ 4 1 $\vert$ $\vert$ 1 2 $\vert$ 4 2 6 3 --- + --- = $\vert$--- x ---$\vert$ + $\vert$--- x ---$\vert$ = --- + --- = --- = --- 2 4 $\vert$ 4 2 $\vert$ $\vert$ 4 2 $\vert$ 8 8 8 4 \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Pointf \&p1, const Pointf \&p2)}{operator+(const Pointf &p1, const Pointf &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pointf} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p1, }
\item[{const {\bf Pointf} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a64243aa2d4cf6ddb70526aaeda396f82}{}\label{namespaceprism_a64243aa2d4cf6ddb70526aaeda396f82}
Returns a \hyperlink{classprism_1_1_pointf}{Pointf} object that is the sum of the components of p1 and p2 \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Point \&p1, const Point \&p2)}{operator+(const Point &p1, const Point &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p1, }
\item[{const {\bf Point} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a49e983b5c32c93114583309eda19dc2b}{}\label{namespaceprism_a49e983b5c32c93114583309eda19dc2b}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is the sum of the components of p1 and p2 \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Size \&s1, const Size \&s2)}{operator+(const Size &s1, const Size &s2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Size} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{s1, }
\item[{const {\bf Size} \&}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7141aeb35db81548155e44d60c05530e}{}\label{namespaceprism_a7141aeb35db81548155e44d60c05530e}
Adds {\itshape s1} and {\itshape s2} together and returns a new \hyperlink{classprism_1_1_size}{Size} object. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Time \&t1, const Time \&t2)}{operator+(const Time &t1, const Time &t2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Time} \&}]{t1, }
\item[{const {\bf Time} \&}]{t2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_afd483f03b731881b25da5612b1213e5f}{}\label{namespaceprism_afd483f03b731881b25da5612b1213e5f}
Adds the two \hyperlink{classprism_1_1_time}{Time} objects together to produce a new \hyperlink{classprism_1_1_time}{Time} object. If the new time would be after midnight then the time wraps round. 
\begin{DoxyCode}
Time t1(22,30);
Time offset = \hyperlink{classprism_1_1_time_a380242e03982df8bf4af3eaa2296c808}{Time::hour}(2);

Time result = t1+offset; \textcolor{comment}{// Time object set to 00:30:00:000}
\end{DoxyCode}
 \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Vector2 \&a, const Vector2 \&b)}{operator+(const Vector2 &a, const Vector2 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{a, }
\item[{const {\bf Vector2} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae482804c32b466401a9ecdf26bc1e6de}{}\label{namespaceprism_ae482804c32b466401a9ecdf26bc1e6de}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} that is the result of adding the components of vector a and vector b. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Quaternion \&q1, const Quaternion \&q2)}{operator+(const Quaternion &q1, const Quaternion &q2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q1, }
\item[{const {\bf Quaternion} \&}]{q2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad81bceaddc25922e571b4bf427ffe296}{}\label{namespaceprism_ad81bceaddc25922e571b4bf427ffe296}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the sum of q1 and q2 i.\+e. each component of q1 is added to the corresponding component of q2. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Vector4 \&a, const Vector4 \&b)}{operator+(const Vector4 &a, const Vector4 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{a, }
\item[{const {\bf Vector4} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4ac9ebc0ce1449793eb8f521c64929a9}{}\label{namespaceprism_a4ac9ebc0ce1449793eb8f521c64929a9}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} that is the result of adding the components of vector a and vector b. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Vector3 \&a, const Vector3 \&b)}{operator+(const Vector3 &a, const Vector3 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{a, }
\item[{const {\bf Vector3} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7ac90b31f235390d6feb818e3f88ecf0}{}\label{namespaceprism_a7ac90b31f235390d6feb818e3f88ecf0}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} that is the result of adding the components of vector a and vector b. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Matrix4 \&m1, const Matrix4 \&m2)}{operator+(const Matrix4 &m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a33537d30f01f996f8a05fc5b1b49ba3b}{}\label{namespaceprism_a33537d30f01f996f8a05fc5b1b49ba3b}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} which is the sum of m1 and m2. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const String \&str1, const String \&str2)}{operator+(const String &str1, const String &str2)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf String} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf String} \&}]{str1, }
\item[{const {\bf String} \&}]{str2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a433f7afd310d95a93cf8c03d1f831812}{}\label{namespaceprism_a433f7afd310d95a93cf8c03d1f831812}
\index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const String \&str1, const char $\ast$str2)}{operator+(const String &str1, const char *str2)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf String} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf String} \&}]{str1, }
\item[{const char $\ast$}]{str2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a50879e9455a36b7762514951ca0f47f7}{}\label{namespaceprism_a50879e9455a36b7762514951ca0f47f7}
\index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const char $\ast$str1, const String \&str2)}{operator+(const char *str1, const String &str2)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf String} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{str1, }
\item[{const {\bf String} \&}]{str2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7d59729f69eafd3bc9f4d30ad9dd06b6}{}\label{namespaceprism_a7d59729f69eafd3bc9f4d30ad9dd06b6}
\index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const char c, const String \&str)}{operator+(const char c, const String &str)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf String} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const char}]{c, }
\item[{const {\bf String} \&}]{str}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa0fce6a8b93050fcb6db327e68b701e3}{}\label{namespaceprism_aa0fce6a8b93050fcb6db327e68b701e3}
\index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const String \&str, const char c)}{operator+(const String &str, const char c)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf String} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf String} \&}]{str, }
\item[{const char}]{c}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8ae68ccc6eb3a47a748671c1a7af88ca}{}\label{namespaceprism_a8ae68ccc6eb3a47a748671c1a7af88ca}
\index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Fraction \&f1, const Fraction \&f2)}{operator-(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2daf470e5f35f8450447deb2634c22c1}{}\label{namespaceprism_a2daf470e5f35f8450447deb2634c22c1}
Subtracts the fractions /em f1 and /em f2 and returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. If the two denominators are the same then the two numerators are subtracted to form the new numerator and the original denominator is kept the same. e.\+g. 3 1 2 --- -\/ --- = --- 4 4 4 If the denominators are different then we alter the fractions in order to make both denominators the same value. We make a whole fraction out of the second fraction\textquotesingle{}s denominator and multiply it by the first fraction. Then make a whole fraction from the first fraction\textquotesingle{}s denominator and multiply it by the second fraction. Now we can simply subtract the two numerators and keep the denominator the same. 3 1 $\vert$ 2 3 $\vert$ $\vert$ 1 4 $\vert$ 6 4 2 1 --- -\/ --- = $\vert$--- x ---$\vert$ -\/ $\vert$--- x ---$\vert$ = --- -\/ --- = --- = --- 4 2 $\vert$ 2 4 $\vert$ $\vert$ 2 4 $\vert$ 8 8 8 4 \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Pointf \&p1, const Pointf \&p2)}{operator-(const Pointf &p1, const Pointf &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pointf} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p1, }
\item[{const {\bf Pointf} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a435d5c45d873875f2c5092d102eddb78}{}\label{namespaceprism_a435d5c45d873875f2c5092d102eddb78}
Returns a \hyperlink{classprism_1_1_pointf}{Pointf} object that is formed by subtracting the components of p2 from p1 \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Point \&p1, const Point \&p2)}{operator-(const Point &p1, const Point &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p1, }
\item[{const {\bf Point} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a505cbd94f024ad80136afe0b751da08a}{}\label{namespaceprism_a505cbd94f024ad80136afe0b751da08a}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by subtracting the components of p2 from p1 \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Size \&s1, const Size \&s2)}{operator-(const Size &s1, const Size &s2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Size} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{s1, }
\item[{const {\bf Size} \&}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab170e3ca42d85a6766cbc7950ddfb0c4}{}\label{namespaceprism_ab170e3ca42d85a6766cbc7950ddfb0c4}
Subtracts {\itshape s2} from {\itshape s1} and returns a new \hyperlink{classprism_1_1_size}{Size} object. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Time \&t1, const Time \&t2)}{operator-(const Time &t1, const Time &t2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Time} \&}]{t1, }
\item[{const {\bf Time} \&}]{t2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa18009df22007fbbde08ab44b16a9a31}{}\label{namespaceprism_aa18009df22007fbbde08ab44b16a9a31}
Subtracts the \hyperlink{classprism_1_1_time}{Time} object {\itshape t2} from {\itshape t1} to produce a new \hyperlink{classprism_1_1_time}{Time} object. If the new time would be before midnight then the time wraps round. 
\begin{DoxyCode}
Time t1(2,30);
Time offset = \hyperlink{classprism_1_1_time_a380242e03982df8bf4af3eaa2296c808}{Time::hour}(3);

Time result = t1-offset; \textcolor{comment}{// Time object set to 23:30:00:000}
\end{DoxyCode}
 \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector2 \&a, const Vector2 \&b)}{operator-(const Vector2 &a, const Vector2 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{a, }
\item[{const {\bf Vector2} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a86359a88dc5245847de48575a1f969e8}{}\label{namespaceprism_a86359a88dc5245847de48575a1f969e8}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} that is the result of subtracting the components of vector b from vector a. Note\+: vector subtraction is not commutitive so a-\/b does not always equal b-\/a \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector2 \&v)}{operator-(const Vector2 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a124f1081b3a9bbc441dac9927f8a0fc5}{}\label{namespaceprism_a124f1081b3a9bbc441dac9927f8a0fc5}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} object where each vector component of v has been negated. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Quaternion \&q1, const Quaternion \&q2)}{operator-(const Quaternion &q1, const Quaternion &q2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q1, }
\item[{const {\bf Quaternion} \&}]{q2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5eae37b5dc73c544572686f215cea89d}{}\label{namespaceprism_a5eae37b5dc73c544572686f215cea89d}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the result of subtracting q2 from q1 i.\+e. each component of q2 is subtracted from the corresponding component of q1. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector4 \&a, const Vector4 \&b)}{operator-(const Vector4 &a, const Vector4 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{a, }
\item[{const {\bf Vector4} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a038a64f530d1c50bf72cf1a23886ecca}{}\label{namespaceprism_a038a64f530d1c50bf72cf1a23886ecca}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} that is the result of subtracting the components of vector b from vector a. Note\+: vector subtraction is not commutitive so a-\/b does not always equal b-\/a \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(\+Quaternion \&q)}{operator-(Quaternion &q)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{{\bf Quaternion} \&}]{q}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae04c2e5eae2242c58a967086ecad8ff4}{}\label{namespaceprism_ae04c2e5eae2242c58a967086ecad8ff4}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} which has had each component of q negated. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector4 \&v)}{operator-(const Vector4 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a147712ae50c37618cbc61f20efe6729f}{}\label{namespaceprism_a147712ae50c37618cbc61f20efe6729f}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} object where each vector component of v has been negated. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector3 \&a, const Vector3 \&b)}{operator-(const Vector3 &a, const Vector3 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{a, }
\item[{const {\bf Vector3} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a3beb56b334423e027f1ab185785695f8}{}\label{namespaceprism_a3beb56b334423e027f1ab185785695f8}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} that is the result of subtracting the components of vector b from vector a. Note\+: vector subtraction is not commutitive so a-\/b does not always equal b-\/a \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector3 \&v)}{operator-(const Vector3 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8f7cf835ff415e187e6881169803f502}{}\label{namespaceprism_a8f7cf835ff415e187e6881169803f502}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} object where each vector component of v has been negated. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Matrix4 \&m1, const Matrix4 \&m2)}{operator-(const Matrix4 &m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a34a2f64f209065f753bed62a880b75b6}{}\label{namespaceprism_a34a2f64f209065f753bed62a880b75b6}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} which is the result of subtracting m2 from m1. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Matrix4 \&m)}{operator-(const Matrix4 &m)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a879d3410d690b5722a9af17297f38fbb}{}\label{namespaceprism_a879d3410d690b5722a9af17297f38fbb}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} where each component of matrix m has been negated (multiplyed by -\/1). \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Pointf \&p, const float divisor)}{operator/(const Pointf &p, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pointf} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a71504f6dd299e8bc788e07d11d29dc5e}{}\label{namespaceprism_a71504f6dd299e8bc788e07d11d29dc5e}
Returns a \hyperlink{classprism_1_1_pointf}{Pointf} object that is formed by dividing the components of p by divisor \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Fraction \&f1, const Fraction \&f2)}{operator/(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7ba7b5cc9750f0d6cda50f0cb874da6f}{}\label{namespaceprism_a7ba7b5cc9750f0d6cda50f0cb874da6f}
Divides /em f1 by /em f2 and returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. \hyperlink{classprism_1_1_fraction}{Fraction} division is achieved by taking the reciprocal of the second fraction and multiplying it against the first fraction. See /em \hyperlink{classprism_1_1_fraction_aab12f13967ca16e8956618f9d0641c31}{Fraction\+::reciprocal()} for more information. 3 2 3 7 21 --- / --- = --- $\ast$ --- = --- 4 7 4 2 8 \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Point \&p, const float divisor)}{operator/(const Point &p, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5f73aee33931e5b9977da32e50d47c0e}{}\label{namespaceprism_a5f73aee33931e5b9977da32e50d47c0e}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by dividing the components of p1 by the components of p2 \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Size \&size, const int factor)}{operator/(const Size &size, const int factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Size} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{size, }
\item[{const int}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad7e100bd6b1730deaab53d1218e29a67}{}\label{namespaceprism_ad7e100bd6b1730deaab53d1218e29a67}
Divides {\itshape size} by {\itshape factor} rounding to integer precision and returns a new \hyperlink{classprism_1_1_size}{Size} object. \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Vector2 \&v, const float divisor)}{operator/(const Vector2 &v, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{v, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aea1ab02785c9d4d5ea560face252b75e}{}\label{namespaceprism_aea1ab02785c9d4d5ea560face252b75e}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} where each component of vector v has been divided by divisor. If divisor is 0 then a zero vector is returned instead. \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Vector4 \&v, const float divisor)}{operator/(const Vector4 &v, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{v, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4aa2b9a75c3d5134fc80cc6afc1be443}{}\label{namespaceprism_a4aa2b9a75c3d5134fc80cc6afc1be443}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} where each component of vector v has been divided by divisor. If divisor is 0 then a zero vector is returned instead. \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Vector3 \&v, const float divisor)}{operator/(const Vector3 &v, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{v, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a87e022748076586917c38e83430df284}{}\label{namespaceprism_a87e022748076586917c38e83430df284}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} where each component of vector v has been divided by divisor. If divisor is 0 then a zero vector is returned instead. \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Quaternion \&q, const float divisor)}{operator/(const Quaternion &q, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aec648937a53338bcd9879670877d0425}{}\label{namespaceprism_aec648937a53338bcd9879670877d0425}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the result of dividing each component of q by divisor. If divisor is 0 then a identity quaternion is returned instead. \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Matrix4 \&m, const float divisor)}{operator/(const Matrix4 &m, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a517b4bc9b0ccc23f79b744d93b540fa6}{}\label{namespaceprism_a517b4bc9b0ccc23f79b744d93b540fa6}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} where each component of matrix m is divided by divisor. If divisor is 0 a new \hyperlink{classprism_1_1_matrix4}{Matrix4} is returned set to the identity matrix instead. \index{prism@{prism}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$(const Char \&c1, const Char \&c2)}{operator<(const Char &c1, const Char &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Char} \&}]{c1, }
\item[{const {\bf Char} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2fc3e64ba36a16f24cb0ae387c83f35f}{}\label{namespaceprism_a2fc3e64ba36a16f24cb0ae387c83f35f}
\begin{DoxyReturn}{Returns}
Returns true if the unicode value of {\itshape c1} is less than {\itshape c2}, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$(const Fraction \&f1, const Fraction \&f2)}{operator<(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a105ac9995ade66ebb2a039ef90751c7a}{}\label{namespaceprism_a105ac9995ade66ebb2a039ef90751c7a}
Returns true if /em f1 is less than /em f2, false otherwise. \index{prism@{prism}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$(const Circle \&c1, const Circle \&c2)}{operator<(const Circle &c1, const Circle &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Circle} \&}]{c1, }
\item[{const {\bf Circle} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8e662d15b162ca76912c491798caefd3}{}\label{namespaceprism_a8e662d15b162ca76912c491798caefd3}
\begin{DoxyReturn}{Returns}
Returns true if {\itshape c1} has a smaller radius than {\itshape c2}, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Pointf \&p)}{operator<<(std::ostream &out, const Pointf &p)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Pointf} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_acad408bf2576dfc62a573cb44aa895fb}{}\label{namespaceprism_acad408bf2576dfc62a573cb44aa895fb}
Returns an ostream object that allows this object to printed with std\+::cout \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Point \&p)}{operator<<(std::ostream &out, const Point &p)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Point} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_acb9fe7ab8ef5f1ee0338e3b057624393}{}\label{namespaceprism_acb9fe7ab8ef5f1ee0338e3b057624393}
Returns an ostream object that allows this object to printed with std\+::cout \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Char \&c)}{operator<<(std::ostream &out, const Char &c)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Char} \&}]{c}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa67ea1154a35dabe9c2c232aff65e930}{}\label{namespaceprism_aa67ea1154a35dabe9c2c232aff65e930}
Allows an instance of \hyperlink{classprism_1_1_char}{Char} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Fraction \&f)}{operator<<(std::ostream &out, const Fraction &f)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Fraction} \&}]{f}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9c2d182a77a92e6cba7917dbd58f9d87}{}\label{namespaceprism_a9c2d182a77a92e6cba7917dbd58f9d87}
Allows an instance of \hyperlink{classprism_1_1_fraction}{Fraction} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Size \&size)}{operator<<(std::ostream &out, const Size &size)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Size} \&}]{size}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad6335168e27f481d86ae42da444006d1}{}\label{namespaceprism_ad6335168e27f481d86ae42da444006d1}
Allows an instance of \hyperlink{classprism_1_1_size}{Size} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Time \&t)}{operator<<(std::ostream &out, const Time &t)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Time} \&}]{t}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7c24ead13d51c13dcadde1b6df4a4967}{}\label{namespaceprism_a7c24ead13d51c13dcadde1b6df4a4967}
Allows an instance of \hyperlink{classprism_1_1_time}{Time} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Vector2 \&v)}{operator<<(std::ostream &out, const Vector2 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Vector2} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4616180b97f4288a3b3e28304efee020}{}\label{namespaceprism_a4616180b97f4288a3b3e28304efee020}
Allows an instance of \hyperlink{classprism_1_1_vector2}{Vector2} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Vector4 \&v)}{operator<<(std::ostream &out, const Vector4 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Vector4} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aeb86919d9ba71747d21fbd6e28671692}{}\label{namespaceprism_aeb86919d9ba71747d21fbd6e28671692}
Allows an instance of \hyperlink{classprism_1_1_vector4}{Vector4} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Vector3 \&v)}{operator<<(std::ostream &out, const Vector3 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Vector3} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa7b9367a483153af865552ba486f1196}{}\label{namespaceprism_aa7b9367a483153af865552ba486f1196}
Allows an instance of \hyperlink{classprism_1_1_vector3}{Vector3} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Quaternion \&q)}{operator<<(std::ostream &out, const Quaternion &q)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Quaternion} \&}]{q}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad2beaed7a837821f0abc608cf6ac6c0f}{}\label{namespaceprism_ad2beaed7a837821f0abc608cf6ac6c0f}
Returns a reference to a stream which allows an instance of \hyperlink{classprism_1_1_quaternion}{Quaternion} to be written to the stream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Array$<$ T $>$ \&array)}{operator<<(std::ostream &out, const Array< T > &array)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Array}$<$ T $>$ \&}]{array}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a403ca8f79c481a89132691c0fd8c3a06}{}\label{namespaceprism_a403ca8f79c481a89132691c0fd8c3a06}
\index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Bitvector \&bv)}{operator<<(std::ostream &out, const Bitvector &bv)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Bitvector} \&}]{bv}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a0b98ff0fee78022242292f24158ad1f0}{}\label{namespaceprism_a0b98ff0fee78022242292f24158ad1f0}
Allows an instance of \hyperlink{classprism_1_1_bitvector}{Bitvector} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Circle \&c)}{operator<<(std::ostream &out, const Circle &c)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Circle} \&}]{c}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa63d3d39d3fad8fa5c5966cc4f306324}{}\label{namespaceprism_aa63d3d39d3fad8fa5c5966cc4f306324}
Allows an instance of \hyperlink{classprism_1_1_circle}{Circle} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Rect \&rect)}{operator<<(std::ostream &out, const Rect &rect)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Rect} \&}]{rect}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a52fd2a97b66b06ba6e451e1890136ff4}{}\label{namespaceprism_a52fd2a97b66b06ba6e451e1890136ff4}
Allows an instance of \hyperlink{classprism_1_1_rect}{Rect} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const List$<$ T $>$ \&list)}{operator<<(std::ostream &out, const List< T > &list)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf List}$<$ T $>$ \&}]{list}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a50da64555d454821545fe0311fde6a62}{}\label{namespaceprism_a50da64555d454821545fe0311fde6a62}
Outputs a human-\/friendly summary of {\itshape list} to the stream {\itshape out}. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Matrix4 \&matrix)}{operator<<(std::ostream &out, const Matrix4 &matrix)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Matrix4} \&}]{matrix}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab65e15b3e601e0570beb49a11610c671}{}\label{namespaceprism_ab65e15b3e601e0570beb49a11610c671}
Allows an instance of Matrx4x4 to be written to the ostream out and returns a reference to the ostream. i.\+e. std\+::cout $<$$<$ matrix $<$$<$ std\+::endl; \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const String \&s)}{operator<<(std::ostream &out, const String &s)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf String} \&}]{s}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a0a166bbf645cc854542cc0fc50324670}{}\label{namespaceprism_a0a166bbf645cc854542cc0fc50324670}
Allows an instance of \hyperlink{classprism_1_1_string}{String} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$=(const Char \&c1, const Char \&c2)}{operator<=(const Char &c1, const Char &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$<$= (
\begin{DoxyParamCaption}
\item[{const {\bf Char} \&}]{c1, }
\item[{const {\bf Char} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a87d86e9266469c8a40537e12a560b066}{}\label{namespaceprism_a87d86e9266469c8a40537e12a560b066}
\begin{DoxyReturn}{Returns}
Returns true if the unicode value of {\itshape c1} is less than or equal to {\itshape c2}, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Char \&c1, const Char \&c2)}{operator==(const Char &c1, const Char &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Char} \&}]{c1, }
\item[{const {\bf Char} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1ba68b64a6cfdcff9e144b8c2476cddb}{}\label{namespaceprism_a1ba68b64a6cfdcff9e144b8c2476cddb}
\begin{DoxyReturn}{Returns}
Returns true if the chars {\itshape c1} and {\itshape c2} are equal, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Pointf \&p1, const Pointf \&p2)}{operator==(const Pointf &p1, const Pointf &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p1, }
\item[{const {\bf Pointf} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a13ab889958edc08eea9a5bea056cd9c1}{}\label{namespaceprism_a13ab889958edc08eea9a5bea056cd9c1}
Returns true if x and y of p1 and p2 are equal, false if not \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Size \&s1, const Size \&s2)}{operator==(const Size &s1, const Size &s2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{s1, }
\item[{const {\bf Size} \&}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2a7baeb09cd2ee29251667ad18a2bd00}{}\label{namespaceprism_a2a7baeb09cd2ee29251667ad18a2bd00}
========================================================== \subsection*{Related non-\/members }

Returns true if the widths are equal and the heights are equal of both \hyperlink{classprism_1_1_size}{Size} objects. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Shared\+Pointer$<$ U $>$ \&p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator==(const SharedPointer< U > &p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae53d52e8a36ec7ca58ea1731cc18f1d8}{}\label{namespaceprism_ae53d52e8a36ec7ca58ea1731cc18f1d8}
Returns true if the managed pointers of p1 and p2 point to the same data, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Shared\+Pointer$<$ U $>$ \&p1, const U $\ast$p2)}{operator==(const SharedPointer< U > &p1, const U *p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const U $\ast$}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2b73e87f080646696ed6b595a3900119}{}\label{namespaceprism_a2b73e87f080646696ed6b595a3900119}
Returns true if the managed pointer of p1 and the raw pointer p2 point to the same data, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Fraction \&f1, const Fraction \&f2)}{operator==(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5b9e84008b9eaa99d29d4b74cd150cd8}{}\label{namespaceprism_a5b9e84008b9eaa99d29d4b74cd150cd8}
Returns true if /em f1 and /em f2 are equal in value. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const U $\ast$p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator==(const U *p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const U $\ast$}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1f29b22985dc0ec1fc548a551ce313ed}{}\label{namespaceprism_a1f29b22985dc0ec1fc548a551ce313ed}
Returns true if the raw pointer p1 and the managed pointer of p2 point to the same data, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Point \&p1, const Point \&p2)}{operator==(const Point &p1, const Point &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p1, }
\item[{const {\bf Point} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a739baa4e75c1ca83624d486eec1d45e9}{}\label{namespaceprism_a739baa4e75c1ca83624d486eec1d45e9}
Returns true if x and y of p1 and p2 are equal, false if not \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Vector2 \&a, const Vector2 \&b)}{operator==(const Vector2 &a, const Vector2 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{a, }
\item[{const {\bf Vector2} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a311fc983ec89876189643e840d781974}{}\label{namespaceprism_a311fc983ec89876189643e840d781974}
Compares the two vectors and if each of the corresponding components are equal in value then true is returned, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Vector4 \&a, const Vector4 \&b)}{operator==(const Vector4 &a, const Vector4 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{a, }
\item[{const {\bf Vector4} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a80bdef743a64c754bf1a2b217c82f60a}{}\label{namespaceprism_a80bdef743a64c754bf1a2b217c82f60a}
Compares the two vectors and if each of the corresponding components are equal in value then true is returned, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Vector3 \&a, const Vector3 \&b)}{operator==(const Vector3 &a, const Vector3 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{a, }
\item[{const {\bf Vector3} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2fc2a483f2e3ec622ad2c0ac9699fbcb}{}\label{namespaceprism_a2fc2a483f2e3ec622ad2c0ac9699fbcb}
Compares the two vectors and if each of the corresponding components are equal in value then true is returned, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Quaternion \&q1, const Quaternion \&q2)}{operator==(const Quaternion &q1, const Quaternion &q2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q1, }
\item[{const {\bf Quaternion} \&}]{q2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ac4ae112433b9ab32c801cccc9c3f74f0}{}\label{namespaceprism_ac4ae112433b9ab32c801cccc9c3f74f0}
Compares q1 and q2 and returns true if they are equal, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Bitvector \&bv1, const Bitvector \&bv2)}{operator==(const Bitvector &bv1, const Bitvector &bv2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Bitvector} \&}]{bv1, }
\item[{const {\bf Bitvector} \&}]{bv2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aca036c7f0f8a5aaf98b46b4879189bcc}{}\label{namespaceprism_aca036c7f0f8a5aaf98b46b4879189bcc}
\begin{DoxyReturn}{Returns}
Returns true if the two Bitvectors are equal to each other, false otherwise. The Bitvectors are considered equal if they are the same size and each corresponding bit is set to the same value. 
\end{DoxyReturn}
\index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Circle \&c1, const Circle \&c2)}{operator==(const Circle &c1, const Circle &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Circle} \&}]{c1, }
\item[{const {\bf Circle} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a0ce1ad6e6392618212d5ab3bebb8e585}{}\label{namespaceprism_a0ce1ad6e6392618212d5ab3bebb8e585}
\begin{DoxyReturn}{Returns}
Returns true if both circles have the same radius and (x,y) centre point, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Rect \&r1, const Rect \&r2)}{operator==(const Rect &r1, const Rect &r2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Rect} \&}]{r1, }
\item[{const {\bf Rect} \&}]{r2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_abe409fa2ef458a2d477ed7845cf4b6a6}{}\label{namespaceprism_abe409fa2ef458a2d477ed7845cf4b6a6}
===================================================================== \subsection*{Related non-\/members }

Returns true if the rectangles {\itshape r1} and {\itshape r2} are equal, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Matrix4 \&m1, const Matrix4 \&m2)}{operator==(const Matrix4 &m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8804ec2ab8dda9441d64e947f05e293c}{}\label{namespaceprism_a8804ec2ab8dda9441d64e947f05e293c}
Compares the elements of the two matrices and returns true if they contain the same data, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const String \&str1, const String \&str2)}{operator==(const String &str1, const String &str2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf String} \&}]{str1, }
\item[{const {\bf String} \&}]{str2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a0e7bfee93ae735b5af7e566ddd8c4f65}{}\label{namespaceprism_a0e7bfee93ae735b5af7e566ddd8c4f65}
\index{prism@{prism}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$>$(const Char \&c1, const Char \&c2)}{operator>(const Char &c1, const Char &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{const {\bf Char} \&}]{c1, }
\item[{const {\bf Char} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab8a312729c4c9ae72836d0034a6f0758}{}\label{namespaceprism_ab8a312729c4c9ae72836d0034a6f0758}
\begin{DoxyReturn}{Returns}
Returns true if the unicode value of {\itshape c1} is greater than {\itshape c2}, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$>$(const Fraction \&f1, const Fraction \&f2)}{operator>(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7122a7ff43fc6aba9cef9d31fe8c7559}{}\label{namespaceprism_a7122a7ff43fc6aba9cef9d31fe8c7559}
Returns true if /em f1 is less than /em f2, false otherwise. \index{prism@{prism}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$>$(const Circle \&c1, const Circle \&c2)}{operator>(const Circle &c1, const Circle &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{const {\bf Circle} \&}]{c1, }
\item[{const {\bf Circle} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a671739ac8567654dba563c34af92213f}{}\label{namespaceprism_a671739ac8567654dba563c34af92213f}
\begin{DoxyReturn}{Returns}
Returns true if {\itshape c1} has a greater radius than {\itshape c2}, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$>$=(const Char \&c1, const Char \&c2)}{operator>=(const Char &c1, const Char &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$>$= (
\begin{DoxyParamCaption}
\item[{const {\bf Char} \&}]{c1, }
\item[{const {\bf Char} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aad049ddef9beb3fec3e7057a7f651280}{}\label{namespaceprism_aad049ddef9beb3fec3e7057a7f651280}
\begin{DoxyReturn}{Returns}
Returns true if the unicode value of {\itshape c1} is greater than or equal to {\itshape c2}, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator$^\wedge$@{operator$^\wedge$}}
\index{operator$^\wedge$@{operator$^\wedge$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$^\wedge$(const Bitvector \&bv1, const Bitvector \&bv2)}{operator^(const Bitvector &bv1, const Bitvector &bv2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Bitvector} prism\+::operator$^\wedge$ (
\begin{DoxyParamCaption}
\item[{const {\bf Bitvector} \&}]{bv1, }
\item[{const {\bf Bitvector} \&}]{bv2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6a18ff84f30ae8056d6807056a24ef14}{}\label{namespaceprism_a6a18ff84f30ae8056d6807056a24ef14}
Performs a bitwise X\+OR on {\itshape bv1} and {\itshape bv2}. \begin{DoxyReturn}{Returns}
Returns a new \hyperlink{classprism_1_1_bitvector}{Bitvector} with the result of {\itshape }(bv1 $^\wedge$ bv2). 
\end{DoxyReturn}
\index{prism@{prism}!operator\texttt{"|}@{operator\texttt{"|}}}
\index{operator\texttt{"|}@{operator\texttt{"|}}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator\texttt{"|}(const Bitvector \&bv1, const Bitvector \&bv2)}{operator|(const Bitvector &bv1, const Bitvector &bv2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Bitvector} prism\+::operator$\vert$ (
\begin{DoxyParamCaption}
\item[{const {\bf Bitvector} \&}]{bv1, }
\item[{const {\bf Bitvector} \&}]{bv2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a145d1e196c14cdbdc4eccb01c60c9275}{}\label{namespaceprism_a145d1e196c14cdbdc4eccb01c60c9275}
Performs a bitwise OR on {\itshape bv1} and {\itshape bv2}. \begin{DoxyReturn}{Returns}
Returns a new \hyperlink{classprism_1_1_bitvector}{Bitvector} with the result of {\itshape }(bv1 $\vert$ bv2). 
\end{DoxyReturn}
\index{prism@{prism}!p\+\_\+heapify@{p\+\_\+heapify}}
\index{p\+\_\+heapify@{p\+\_\+heapify}!prism@{prism}}
\subsubsection[{\texorpdfstring{p\+\_\+heapify(\+Random\+Access\+Iterator node, Random\+Access\+Iterator first, Random\+Access\+Iterator last)}{p_heapify(RandomAccessIterator node, RandomAccessIterator first, RandomAccessIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Random\+Access\+Iterator $>$ void prism\+::p\+\_\+heapify (
\begin{DoxyParamCaption}
\item[{Random\+Access\+Iterator}]{node, }
\item[{Random\+Access\+Iterator}]{first, }
\item[{Random\+Access\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5f2c83ae0d89a6581d1c42ba6fd79de0}{}\label{namespaceprism_a5f2c83ae0d89a6581d1c42ba6fd79de0}
Private recursive function called by \hyperlink{namespaceprism_af8e36230e6cb92a41aaca282772a9e6e}{make\+\_\+heap()}. Compares a node with its two children (if it has any) and ensures that the largest of the three nodes is the parent node. \index{prism@{prism}!remove@{remove}}
\index{remove@{remove}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove(\+Forward\+Iterator first, Forward\+Iterator last, const T \&value)}{remove(ForwardIterator first, ForwardIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ Forward\+Iterator prism\+::remove (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aeddd21943bcf811c56f7d9d1bd4784f6}{}\label{namespaceprism_aeddd21943bcf811c56f7d9d1bd4784f6}
Transforms the range {\itshape }\mbox{[}first,last\mbox{]} into a range with all the elements that compare equal to {\itshape value} removed, and returns an iterator to the new end of that range. \index{prism@{prism}!remove\+\_\+copy@{remove\+\_\+copy}}
\index{remove\+\_\+copy@{remove\+\_\+copy}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+\_\+copy(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, const T \&value)}{remove_copy(InputIterator first, InputIterator last, OutputIterator otherFirst, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ Output\+Iterator prism\+::remove\+\_\+copy (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab7b6fb407340e51749169560b48fb20c}{}\label{namespaceprism_ab7b6fb407340e51749169560b48fb20c}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} to the range beginning at {\itshape other\+First}, except those elements that compare equal to {\itshape value}. \index{prism@{prism}!remove\+\_\+copy\+\_\+if@{remove\+\_\+copy\+\_\+if}}
\index{remove\+\_\+copy\+\_\+if@{remove\+\_\+copy\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+\_\+copy\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Unary\+Predicate pred)}{remove_copy_if(InputIterator first, InputIterator last, OutputIterator otherFirst, UnaryPredicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class Unary\+Predicate $>$ Output\+Iterator prism\+::remove\+\_\+copy\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{Unary\+Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_abfc7da1f951e480a26d58fc098b78844}{}\label{namespaceprism_abfc7da1f951e480a26d58fc098b78844}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} to the range beginning at {\itshape other\+First}, except those elements for which {\itshape pred} returns true. \index{prism@{prism}!remove\+\_\+if@{remove\+\_\+if}}
\index{remove\+\_\+if@{remove\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+\_\+if(\+Forward\+Iterator first, Forward\+Iterator last, Predicate pred)}{remove_if(ForwardIterator first, ForwardIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class Predicate $>$ Forward\+Iterator prism\+::remove\+\_\+if (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2e9d25191ed83ea0a193f16d9c0a00b7}{}\label{namespaceprism_a2e9d25191ed83ea0a193f16d9c0a00b7}
Transforms the range {\itshape }\mbox{[}first,last\mbox{]} into a range with all the elements for which {\itshape pred} returns true removed, and returns an iterator to the new end of that range. \index{prism@{prism}!replace@{replace}}
\index{replace@{replace}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace(\+Forward\+Iterator first, Forward\+Iterator last, const T \&old\+Value, const T \&new\+Value)}{replace(ForwardIterator first, ForwardIterator last, const T &oldValue, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::replace (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{const T \&}]{old\+Value, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6156070b98de7130b8c912ae3a6d333f}{}\label{namespaceprism_a6156070b98de7130b8c912ae3a6d333f}
Assigns {\itshape new\+Value} to all the elements in the range {\itshape }\mbox{[}first,last\mbox{]} that compare equal to {\itshape old\+Value}. \index{prism@{prism}!replace\+\_\+copy@{replace\+\_\+copy}}
\index{replace\+\_\+copy@{replace\+\_\+copy}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace\+\_\+copy(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, const T \&old\+Value, const T \&new\+Value)}{replace_copy(InputIterator first, InputIterator last, OutputIterator otherFirst, const T &oldValue, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ Output\+Iterator prism\+::replace\+\_\+copy (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{const T \&}]{old\+Value, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a16d85ecb70d2f216714a0146a057a105}{}\label{namespaceprism_a16d85ecb70d2f216714a0146a057a105}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} to the range beginning at {\itshape other\+First}, replacing the appearances of {\itshape old\+Value} by {\itshape new\+Value}. \index{prism@{prism}!replace\+\_\+copy\+\_\+if@{replace\+\_\+copy\+\_\+if}}
\index{replace\+\_\+copy\+\_\+if@{replace\+\_\+copy\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace\+\_\+copy\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Predicate pred, const T \&new\+Value)}{replace_copy_if(InputIterator first, InputIterator last, OutputIterator otherFirst, Predicate pred, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class Predicate , class T $>$ Output\+Iterator prism\+::replace\+\_\+copy\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{Predicate}]{pred, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a55d702599739f7137516dcd095119f15}{}\label{namespaceprism_a55d702599739f7137516dcd095119f15}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} to the range beginning at {\itshape other\+First}, replacing those for which {\itshape pred} returns true by new\+Value. \index{prism@{prism}!replace\+\_\+if@{replace\+\_\+if}}
\index{replace\+\_\+if@{replace\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace\+\_\+if(\+Forward\+Iterator first, Forward\+Iterator last, Predicate pred, const T \&new\+Value)}{replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class Predicate , class T $>$ void prism\+::replace\+\_\+if (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{Predicate}]{pred, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af118c19f6b5448319eb3aaf2d556ac54}{}\label{namespaceprism_af118c19f6b5448319eb3aaf2d556ac54}
Assigns {\itshape new\+Value} to all the elements in the range {\itshape }\mbox{[}first,last\mbox{]} for which {\itshape pred} returns true. \index{prism@{prism}!search@{search}}
\index{search@{search}!prism@{prism}}
\subsubsection[{\texorpdfstring{search(\+Forward\+Iterator1 first1, Forward\+Iterator1 last1, Forward\+Iterator2 first2, Forward\+Iterator2 last2)}{search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ Forward\+Iterator1 prism\+::search (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator1}]{first1, }
\item[{Forward\+Iterator1}]{last1, }
\item[{Forward\+Iterator2}]{first2, }
\item[{Forward\+Iterator2}]{last2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_affcb3e5150d72d9f79b85b9ea4eb41e2}{}\label{namespaceprism_affcb3e5150d72d9f79b85b9ea4eb41e2}
Searches the range \mbox{[}first1,last1\mbox{]} for the first occurrence of the sequence defined by \mbox{[}first2,last2\mbox{]}, and returns an iterator to its first element, or last1 if no occurrences are found. The range used is \mbox{[}first1,last1\mbox{]}, which contains all the elements between first1 and last1, including the element pointed by first1 but not the element pointed by last1. \index{prism@{prism}!sort@{sort}}
\index{sort@{sort}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort(\+Forward\+Iterator first, Forward\+Iterator last)}{sort(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ void prism\+::sort (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9bf397cad0a67b67fbd1ecddf40d405e}{}\label{namespaceprism_a9bf397cad0a67b67fbd1ecddf40d405e}
Sorts the elements in the range {\itshape }\mbox{[}first,last\mbox{]} in ascending order using the quicksort algorithm. The range used is \mbox{[}first1,last1\mbox{]}, which contains all the elements between first1 and last1, including the element pointed by first1 but not the element pointed by last1. ~\newline
Currently {\itshape \hyperlink{namespaceprism_a9bf397cad0a67b67fbd1ecddf40d405e}{sort()}} is implemented using the quicksort algorithm which averages a reasonable O(n log(n)) complexity. \index{prism@{prism}!sort\+\_\+bubble@{sort\+\_\+bubble}}
\index{sort\+\_\+bubble@{sort\+\_\+bubble}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort\+\_\+bubble(\+Random\+Access\+Iterator first, Random\+Access\+Iterator last)}{sort_bubble(RandomAccessIterator first, RandomAccessIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Random\+Access\+Iterator $>$ void prism\+::sort\+\_\+bubble (
\begin{DoxyParamCaption}
\item[{Random\+Access\+Iterator}]{first, }
\item[{Random\+Access\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa597d262eb2f9ef80703c883a2d18d1e}{}\label{namespaceprism_aa597d262eb2f9ef80703c883a2d18d1e}
Sorts the elements in the range {\itshape }\mbox{[}first, last\mbox{]} in ascending order using the Bubble Sort algorithm. ~\newline
The range used is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. \begin{DoxyNote}{Note}
The objects being sorted must support \hyperlink{namespaceprism_ab8a312729c4c9ae72836d0034a6f0758}{operator$>$()}. 
\end{DoxyNote}
\index{prism@{prism}!sort\+\_\+heap@{sort\+\_\+heap}}
\index{sort\+\_\+heap@{sort\+\_\+heap}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort\+\_\+heap(\+Random\+Access\+Iterator first, Random\+Access\+Iterator last)}{sort_heap(RandomAccessIterator first, RandomAccessIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Random\+Access\+Iterator $>$ void prism\+::sort\+\_\+heap (
\begin{DoxyParamCaption}
\item[{Random\+Access\+Iterator}]{first, }
\item[{Random\+Access\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1e9fe74c5dcee70bf5dd5c89f1234a02}{}\label{namespaceprism_a1e9fe74c5dcee70bf5dd5c89f1234a02}
Sorts the elements in the range {\itshape }\mbox{[}first,last\mbox{]} using the heapsort algorithm. ~\newline
The elements are first rearranged so that they satisfy the ordering of a heap (by a call to \hyperlink{namespaceprism_af8e36230e6cb92a41aaca282772a9e6e}{make\+\_\+heap()}).~\newline
The range used is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. \index{prism@{prism}!sort\+\_\+quicksort@{sort\+\_\+quicksort}}
\index{sort\+\_\+quicksort@{sort\+\_\+quicksort}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort\+\_\+quicksort(\+Forward\+Iterator first, Forward\+Iterator last)}{sort_quicksort(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ void prism\+::sort\+\_\+quicksort (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a720fbbcb3f399b006969bb00a66686f9}{}\label{namespaceprism_a720fbbcb3f399b006969bb00a66686f9}
Sorts the elements in the range {\itshape }\mbox{[}first, last\mbox{]} in ascending order using the Quicksort algorithm. ~\newline
The range used is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. \begin{DoxyNote}{Note}
The objects being sorted must support \hyperlink{namespaceprism_a87d86e9266469c8a40537e12a560b066}{operator$<$=()}. 
\end{DoxyNote}
\index{prism@{prism}!swap@{swap}}
\index{swap@{swap}!prism@{prism}}
\subsubsection[{\texorpdfstring{swap(\+T \&a, T \&b)}{swap(T &a, T &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ void prism\+::swap (
\begin{DoxyParamCaption}
\item[{T \&}]{a, }
\item[{T \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6430516ab4f2e2a7f43323acb6b559d8}{}\label{namespaceprism_a6430516ab4f2e2a7f43323acb6b559d8}
Exchanges the values of {\itshape a} and {\itshape b}. \index{prism@{prism}!swap\+\_\+ranges@{swap\+\_\+ranges}}
\index{swap\+\_\+ranges@{swap\+\_\+ranges}!prism@{prism}}
\subsubsection[{\texorpdfstring{swap\+\_\+ranges(\+Forward\+Iterator1 first, Forward\+Iterator1 last, Forward\+Iterator2 other\+First)}{swap_ranges(ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ Forward\+Iterator2 prism\+::swap\+\_\+ranges (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator1}]{first, }
\item[{Forward\+Iterator1}]{last, }
\item[{Forward\+Iterator2}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4661f2c0c4dca098c137179b4d93f3dc}{}\label{namespaceprism_a4661f2c0c4dca098c137179b4d93f3dc}
Exchanges the values of each of the elements in the range {\itshape }\mbox{[}first1,last1\mbox{]} with those of their respective elements in the range beginning at {\itshape other\+First}. 