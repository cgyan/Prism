\hypertarget{namespaceprism}{}\section{prism Namespace Reference}
\label{namespaceprism}\index{prism@{prism}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classprism_1_1_allocator}{Allocator}
\item 
struct \hyperlink{structprism_1_1_allocator_traits}{Allocator\+Traits}
\item 
class \hyperlink{classprism_1_1_array}{Array}
\item 
class \hyperlink{classprism_1_1_bitvector}{Bitvector}
\item 
struct \hyperlink{structprism_1_1_bitvector_data}{Bitvector\+Data}
\item 
class \hyperlink{classprism_1_1_char}{Char}
\item 
class \hyperlink{classprism_1_1_circle}{Circle}
\item 
struct \hyperlink{structprism_1_1conditional__type}{conditional\+\_\+type}
\item 
struct \hyperlink{structprism_1_1conditional__type_3_01false_00_01_type1_00_01_type2_01_4}{conditional\+\_\+type$<$ false, Type1, Type2 $>$}
\item 
class \hyperlink{classprism_1_1_exception}{Exception}
\item 
class \hyperlink{classprism_1_1_flag}{Flag}
\item 
class \hyperlink{classprism_1_1_flags}{Flags}
\item 
class \hyperlink{classprism_1_1_fraction}{Fraction}
\item 
class \hyperlink{classprism_1_1_list}{List}
\item 
class \hyperlink{classprism_1_1_logger_allocator}{Logger\+Allocator}
\item 
class \hyperlink{classprism_1_1_mathf}{Mathf}
\item 
class \hyperlink{classprism_1_1_matrix4}{Matrix4}
\item 
class \hyperlink{classprism_1_1_obj}{Obj}
\item 
class \hyperlink{classprism_1_1_out_of_bounds_exception}{Out\+Of\+Bounds\+Exception}
\item 
class \hyperlink{classprism_1_1_overflow_exception}{Overflow\+Exception}
\item 
struct \hyperlink{structprism_1_1_pair}{Pair}
\item 
class \hyperlink{classprism_1_1_point}{Point}
\item 
class \hyperlink{classprism_1_1_pointf}{Pointf}
\item 
class \hyperlink{classprism_1_1_quaternion}{Quaternion}
\item 
class \hyperlink{classprism_1_1_queue}{Queue}
\item 
class \hyperlink{classprism_1_1_rect}{Rect}
\item 
class \hyperlink{classprism_1_1_reference_counter}{Reference\+Counter}
\item 
class \hyperlink{classprism_1_1_shared_data}{Shared\+Data}
\item 
class \hyperlink{classprism_1_1_shared_data_pointer}{Shared\+Data\+Pointer}
\item 
class \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}
\item 
class \hyperlink{classprism_1_1_size}{Size}
\item 
class \hyperlink{classprism_1_1_stack}{Stack}
\item 
class \hyperlink{classprism_1_1_string}{String}
\item 
class \hyperlink{classprism_1_1_time}{Time}
\item 
class \hyperlink{classprism_1_1_unequal_size_exception}{Unequal\+Size\+Exception}
\item 
class \hyperlink{classprism_1_1_vector}{Vector}
\item 
class \hyperlink{classprism_1_1_vector2}{Vector2}
\item 
class \hyperlink{classprism_1_1_vector3}{Vector3}
\item 
class \hyperlink{classprism_1_1_vector4}{Vector4}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\Forward\+Iterator \hyperlink{namespaceprism_a82052418345794a13044c15d8e32dd89}{adjacent\+\_\+find} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\bool \hyperlink{namespaceprism_aba366b328f3b6161e6115c16b7153c6d}{all\+\_\+of} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\bool \hyperlink{namespaceprism_a5d0e3ddb9f698759635572f1220ec0ca}{any\+\_\+of} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator $>$ }\\Output\+Iterator \hyperlink{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}{copy} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Output\+Iterator other\+First)
\item 
{\footnotesize template$<$class Bidirectional\+Iterator1 , class Bidirectional\+Iterator2 $>$ }\\Bidirectional\+Iterator2 \hyperlink{namespaceprism_a2564c63b76369cc81ff725a56e818046}{copy\+\_\+backward} (Bidirectional\+Iterator1 \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Bidirectional\+Iterator1 \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Bidirectional\+Iterator2 other\+Last)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class Predicate $>$ }\\Output\+Iterator \hyperlink{namespaceprism_afbed55ae6769c2d88c125aedc2f3846e}{copy\+\_\+if} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Output\+Iterator other\+First, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator , class Size , class Output\+Iterator $>$ }\\Output\+Iterator \hyperlink{namespaceprism_af907f3f5637d4ec056e9b833b6272953}{copy\+\_\+n} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, \hyperlink{classprism_1_1_size}{Size} n, Output\+Iterator other\+First)
\item 
{\footnotesize template$<$class Input\+Iterator , class T $>$ }\\int \hyperlink{namespaceprism_a024117fc3639cdf6598509edf22f034a}{count} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\int \hyperlink{namespaceprism_af0007d361beae18a930b6249752e509e}{count\+\_\+if} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Predicate pred)
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\void \hyperlink{namespaceprism_a83e62e5b148c55f949e5ea843d53ad67}{delete\+\_\+range} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class Input\+Iterator1 , class Input\+Iterator2 $>$ }\\bool \hyperlink{namespaceprism_ad3bede9a0f2c648e93677b14c45b1b7b}{equal} (Input\+Iterator1 \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator1 \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Input\+Iterator2 other\+First)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{fill} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, const T \&value)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_aceb4b9c511a5edb706296b457427b226}{fill\+\_\+n} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, int \hyperlink{namespaceprism_acd3c0f96adf158a29387191d79c4d874}{size}, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class T $>$ }\\Input\+Iterator \hyperlink{namespaceprism_a1b543d9c2862a539cc8b770abda87561}{find} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\Input\+Iterator \hyperlink{namespaceprism_aa17e9e6c80f8a52479a52450a108a636}{find\+\_\+if} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator , class T $>$ }\\Input\+Iterator \hyperlink{namespaceprism_a3189014b9fa31e0ef0d1933c6f616618}{find\+\_\+last} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Function $>$ }\\Function \hyperlink{namespaceprism_aae062d5bfdc0e53ae49c56520aded906}{for\+\_\+each} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Function func)
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\const bool \hyperlink{namespaceprism_acf5efbeb096446c47690b9e8bd2cc01a}{is\+\_\+sorted} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class Random\+Access\+Iterator $>$ }\\void \hyperlink{namespaceprism_af8e36230e6cb92a41aaca282772a9e6e}{make\+\_\+heap} (Random\+Access\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Random\+Access\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class T $>$ }\\const T \& \hyperlink{namespaceprism_a812456273adfa37979e79f07e731d412}{max} (const T \&a, const T \&b)
\item 
{\footnotesize template$<$class T $>$ }\\const T \& \hyperlink{namespaceprism_a10aff0aca673fb1837069dd8967e4738}{min} (const T \&a, const T \&b)
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\bool \hyperlink{namespaceprism_a10c83b433c7f98fd4513f1b68c6db594}{none\+\_\+of} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Predicate pred)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\Forward\+Iterator \hyperlink{namespaceprism_aeddd21943bcf811c56f7d9d1bd4784f6}{remove} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ }\\Output\+Iterator \hyperlink{namespaceprism_ab7b6fb407340e51749169560b48fb20c}{remove\+\_\+copy} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Output\+Iterator other\+First, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class Unary\+Predicate $>$ }\\Output\+Iterator \hyperlink{namespaceprism_abfc7da1f951e480a26d58fc098b78844}{remove\+\_\+copy\+\_\+if} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Output\+Iterator other\+First, Unary\+Predicate pred)
\item 
{\footnotesize template$<$class Forward\+Iterator , class Predicate $>$ }\\Forward\+Iterator \hyperlink{namespaceprism_a2e9d25191ed83ea0a193f16d9c0a00b7}{remove\+\_\+if} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Predicate pred)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_a6156070b98de7130b8c912ae3a6d333f}{replace} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, const T \&old\+Value, const T \&new\+Value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ }\\Output\+Iterator \hyperlink{namespaceprism_a16d85ecb70d2f216714a0146a057a105}{replace\+\_\+copy} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Output\+Iterator other\+First, const T \&old\+Value, const T \&new\+Value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class Predicate , class T $>$ }\\Output\+Iterator \hyperlink{namespaceprism_a55d702599739f7137516dcd095119f15}{replace\+\_\+copy\+\_\+if} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Output\+Iterator other\+First, Predicate pred, const T \&new\+Value)
\item 
{\footnotesize template$<$class Forward\+Iterator , class Predicate , class T $>$ }\\void \hyperlink{namespaceprism_af118c19f6b5448319eb3aaf2d556ac54}{replace\+\_\+if} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Predicate pred, const T \&new\+Value)
\item 
{\footnotesize template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ }\\Forward\+Iterator1 \hyperlink{namespaceprism_a03dbb806369b062fd90909fd826c2ee4}{search} (Forward\+Iterator1 \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator1 \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Forward\+Iterator2 other\+First, Forward\+Iterator2 other\+Last)
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\void \hyperlink{namespaceprism_a9bf397cad0a67b67fbd1ecddf40d405e}{sort} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class Random\+Access\+Iterator $>$ }\\void \hyperlink{namespaceprism_aa597d262eb2f9ef80703c883a2d18d1e}{sort\+\_\+bubble} (Random\+Access\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Random\+Access\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class Random\+Access\+Iterator $>$ }\\void \hyperlink{namespaceprism_a1e9fe74c5dcee70bf5dd5c89f1234a02}{sort\+\_\+heap} (Random\+Access\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Random\+Access\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\void \hyperlink{namespaceprism_a720fbbcb3f399b006969bb00a66686f9}{sort\+\_\+quicksort} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{namespaceprism_a6430516ab4f2e2a7f43323acb6b559d8}{swap} (T \&a, T \&b)
\item 
{\footnotesize template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ }\\Forward\+Iterator2 \hyperlink{namespaceprism_a4661f2c0c4dca098c137179b4d93f3dc}{swap\+\_\+ranges} (Forward\+Iterator1 \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator1 \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Forward\+Iterator2 other\+First)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_a8234c2c7917f750db94bb068d6fd554e}{uninitialized\+\_\+fill} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, const T \&value)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_a5485ae7bad862f6ff0ab363ed4697b61}{uninitialized\+\_\+fill\+\_\+n} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, const int \hyperlink{namespaceprism_acd3c0f96adf158a29387191d79c4d874}{size}, const T \&value)
\item 
{\footnotesize template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ }\\Forward\+Iterator2 \hyperlink{namespaceprism_a5ff56f151fea6e709350a0e9fbdb70a8}{uninitialized\+\_\+copy} (Forward\+Iterator1 \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator1 \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Forward\+Iterator2 other\+First)
\item 
{\footnotesize template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ }\\Forward\+Iterator2 \hyperlink{namespaceprism_ad1c7d8eb38174ba66d98321b68047e6e}{uninitialized\+\_\+copy\+\_\+n} (Forward\+Iterator1 \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, const int \hyperlink{namespaceprism_acd3c0f96adf158a29387191d79c4d874}{size}, Forward\+Iterator2 other\+First)
\item 
{\footnotesize template$<$class Random\+Access\+Iterator $>$ }\\void \hyperlink{namespaceprism_a5f2c83ae0d89a6581d1c42ba6fd79de0}{p\+\_\+heapify} (Random\+Access\+Iterator node, Random\+Access\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Random\+Access\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\Forward\+Iterator \hyperlink{namespaceprism_a6b26c227e2d379b9d934a85a2570bae7}{adjacent\+\_\+find\+\_\+aux} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\bool \hyperlink{namespaceprism_adee0c5bacf315d8cfdc4de7151ba2295}{all\+\_\+of\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\bool \hyperlink{namespaceprism_aae3105c7afbb375201f4691b7ea966b4}{any\+\_\+of\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator $>$ }\\Output\+Iterator \hyperlink{namespaceprism_a8fc5dc440a705fbe80912a49ea6d899b}{copy\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Output\+Iterator other\+First)
\item 
{\footnotesize template$<$class Bidirectional\+Iterator1 , class Bidirectional\+Iterator2 $>$ }\\Bidirectional\+Iterator2 \hyperlink{namespaceprism_af94bcd5517145cc7b62c59a84a776814}{copy\+\_\+backward\+\_\+aux} (Bidirectional\+Iterator1 \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Bidirectional\+Iterator1 \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Bidirectional\+Iterator2 other\+Last)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class Predicate $>$ }\\Output\+Iterator \hyperlink{namespaceprism_a06d95b48370d6b89936a81e08f7ed8d7}{copy\+\_\+if\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Output\+Iterator other\+First, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator , class Size , class Output\+Iterator $>$ }\\Output\+Iterator \hyperlink{namespaceprism_a305d5bebe30595a5d4705a6cef37b52a}{copy\+\_\+n\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, \hyperlink{classprism_1_1_size}{Size} n, Output\+Iterator other\+First)
\item 
{\footnotesize template$<$class Input\+Iterator , class T $>$ }\\int \hyperlink{namespaceprism_a161f644c4e266d280a770bb0c9fbe045}{count\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\int \hyperlink{namespaceprism_a8d72a3b00c7e3e537c82829965732dad}{count\+\_\+if\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Predicate pred)
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\void \hyperlink{namespaceprism_a25e9f7e103a3f2ae15048eb75dc6af97}{delete\+\_\+range\+\_\+aux} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class Input\+Iterator1 , class Input\+Iterator2 $>$ }\\bool \hyperlink{namespaceprism_ac6dc9c68afaa8d8490148baf121bfc1c}{equal\+\_\+aux} (Input\+Iterator1 \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator1 \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Input\+Iterator2 other\+First)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_a76092b4faa3c2a98088678943ad23df4}{fill\+\_\+aux} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, const T \&value)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_ad2e7f5f7dee0072f4741520356ebdaee}{fill\+\_\+n\+\_\+aux} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, int \hyperlink{namespaceprism_acd3c0f96adf158a29387191d79c4d874}{size}, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class T $>$ }\\Input\+Iterator \hyperlink{namespaceprism_af23b68308b7ec11222bd2bfb2904c595}{find\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\Input\+Iterator \hyperlink{namespaceprism_a91c456a075b03cfe290044281af93203}{find\+\_\+if\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Predicate pred)
\item 
{\footnotesize template$<$class Input\+Iterator , class T $>$ }\\Input\+Iterator \hyperlink{namespaceprism_a66df70426cdeee37f0c06a90881f1f36}{find\+\_\+last\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Function $>$ }\\Function \hyperlink{namespaceprism_a9adcafd2357df71bd906d85ffe9fdf85}{for\+\_\+each\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Function func)
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\const bool \hyperlink{namespaceprism_a29c1478cf9a6f78fa511d96f93b22791}{is\+\_\+sorted\+\_\+aux} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class Random\+Access\+Iterator $>$ }\\void \hyperlink{namespaceprism_a567b63d0d3fa2bc8bdba883f152848be}{make\+\_\+heap\+\_\+aux} (Random\+Access\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Random\+Access\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class T $>$ }\\const T \& \hyperlink{namespaceprism_a9d5ae6f65d12dcb2e433ffdc95b733bb}{max\+\_\+aux} (const T \&a, const T \&b)
\item 
{\footnotesize template$<$class T $>$ }\\const T \& \hyperlink{namespaceprism_a5ded05d282e95b0ab21c6aeaca2e8794}{min\+\_\+aux} (const T \&a, const T \&b)
\item 
{\footnotesize template$<$class Input\+Iterator , class Predicate $>$ }\\bool \hyperlink{namespaceprism_a4333d241a3ee0f8bce307db84c7eba23}{none\+\_\+of\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Predicate pred)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\Forward\+Iterator \hyperlink{namespaceprism_acb7d8d4b86592081686e15ee7a18f856}{remove\+\_\+aux} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ }\\Output\+Iterator \hyperlink{namespaceprism_ae3f41bf6d9ab98a87d693fba69f138dc}{remove\+\_\+copy\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Output\+Iterator other\+First, const T \&value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class Unary\+Predicate $>$ }\\Output\+Iterator \hyperlink{namespaceprism_a198b599ea535deb9fdf28c46c8658bd4}{remove\+\_\+copy\+\_\+if\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Output\+Iterator other\+First, Unary\+Predicate pred)
\item 
{\footnotesize template$<$class Forward\+Iterator , class Predicate $>$ }\\Forward\+Iterator \hyperlink{namespaceprism_a95e9f5186670e27472aa7d8cd02397eb}{remove\+\_\+if\+\_\+aux} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Predicate pred)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_ad053e45daef65797bc1cff18dfcd8dc0}{replace\+\_\+aux} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, const T \&old\+Value, const T \&new\+Value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ }\\Output\+Iterator \hyperlink{namespaceprism_a7055d91bb6279fa78b8b498297a11eab}{replace\+\_\+copy\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Output\+Iterator other\+First, const T \&old\+Value, const T \&new\+Value)
\item 
{\footnotesize template$<$class Input\+Iterator , class Output\+Iterator , class Predicate , class T $>$ }\\Output\+Iterator \hyperlink{namespaceprism_a1e660997b10ccb0985b35999c84a9bbf}{replace\+\_\+copy\+\_\+if\+\_\+aux} (Input\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Input\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Output\+Iterator other\+First, Predicate pred, const T \&new\+Value)
\item 
{\footnotesize template$<$class Forward\+Iterator , class Predicate , class T $>$ }\\void \hyperlink{namespaceprism_ad23d44d30470aed0ee16e931514bd727}{replace\+\_\+if\+\_\+aux} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Predicate pred, const T \&new\+Value)
\item 
{\footnotesize template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ }\\Forward\+Iterator1 \hyperlink{namespaceprism_ab6f8ed8b450ff281e02218e10d5643a7}{search\+\_\+aux} (Forward\+Iterator1 first1, Forward\+Iterator1 last1, Forward\+Iterator2 first2, Forward\+Iterator2 last2)
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\void \hyperlink{namespaceprism_a9e7b2f97895db323cbefbc4af311ccb9}{sort\+\_\+aux} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class Random\+Access\+Iterator $>$ }\\void \hyperlink{namespaceprism_af3a66e1051c4c7874f305ad2a5f0b37e}{sort\+\_\+bubble\+\_\+aux} (Random\+Access\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Random\+Access\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class Random\+Access\+Iterator $>$ }\\void \hyperlink{namespaceprism_ab289bdf7cde130b0aeea21a9711770f4}{sort\+\_\+heap\+\_\+aux} (Random\+Access\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Random\+Access\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\void \hyperlink{namespaceprism_a46e0e235fa71938e5ebf29387b917057}{sort\+\_\+quicksort\+\_\+aux} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{namespaceprism_a6d3a7129cc6ab5d9a80301436e4d2e48}{swap\+\_\+aux} (T \&a, T \&b)
\item 
{\footnotesize template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ }\\Forward\+Iterator2 \hyperlink{namespaceprism_a7ca4ae3ad4c2e21d6fe48b6fae6930c3}{swap\+\_\+ranges\+\_\+aux} (Forward\+Iterator1 \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator1 \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Forward\+Iterator2 other\+First)
\item 
{\footnotesize template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ }\\Forward\+Iterator2 \hyperlink{namespaceprism_a85d1fe2d10e98f9de7aec30799f2eec0}{uninitialized\+\_\+copy\+\_\+n\+\_\+aux} (Forward\+Iterator1 \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, const int \hyperlink{namespaceprism_acd3c0f96adf158a29387191d79c4d874}{size}, Forward\+Iterator2 other\+First)
\item 
{\footnotesize template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ }\\Forward\+Iterator2 \hyperlink{namespaceprism_a6ef07b731fbaecb8abe1ad8faabaab1e}{uninitialized\+\_\+copy\+\_\+aux} (Forward\+Iterator1 \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator1 \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, Forward\+Iterator2 other\+First)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_aa02596d3361c57f312168ffac621e421}{uninitialized\+\_\+fill\+\_\+n\+\_\+aux} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, const int \hyperlink{namespaceprism_acd3c0f96adf158a29387191d79c4d874}{size}, const T \&value)
\item 
{\footnotesize template$<$class Forward\+Iterator , class T $>$ }\\void \hyperlink{namespaceprism_aaa8fcd4a3943bfa624f77fc8f3af5916}{uninitialized\+\_\+fill\+\_\+aux} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last}, const T \&value)
\item 
{\footnotesize template$<$class Random\+Access\+Iterator $>$ }\\void \hyperlink{namespaceprism_a95d95c728950cef3542d8b1dd27eb344}{p\+\_\+heapify\+\_\+aux} (Random\+Access\+Iterator node, Random\+Access\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Random\+Access\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
{\footnotesize template$<$class T $>$ }\\std\+::ostream \& \hyperlink{namespaceprism_a403ca8f79c481a89132691c0fd8c3a06}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_array}{Array}$<$ T $>$ \&array)
\item 
\hyperlink{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}{Deque} ()
\item 
\hyperlink{namespaceprism_a73ec48544ee84c6327a63ac5c4c5cb60}{Deque} (const int \hyperlink{namespaceprism_acd3c0f96adf158a29387191d79c4d874}{size}, const T \&value=T())
\item 
{\footnotesize template$<$class Forward\+Iterator $>$ }\\\hyperlink{namespaceprism_aa7bbb75108907fb0573f35d3b82ddf3a}{Deque} (Forward\+Iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, Forward\+Iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
\hyperlink{namespaceprism_a6d8b2ede230218b04aa9b6f48c94f77d}{Deque} (std\+::initializer\+\_\+list$<$ T $>$ list)
\item 
\hyperlink{namespaceprism_af8a6c6b9242eb9a0c22af9e28ee4ae80}{Deque} (const Deque$<$ T, T\+\_\+\+Alloc $>$ \&\hyperlink{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}{copy})
\item 
\hyperlink{namespaceprism_a331c22c8877ca45c3f9504b1fbfb711c}{$\sim$\+Deque} ()
\item 
T\+\_\+\+Alloc \hyperlink{namespaceprism_af48d4e417d7dc90cd7979795347e1718}{allocator} () const 
\item 
void \hyperlink{namespaceprism_afc3c0da5e0e065dd58d686f551746982}{append} (const T \&value)
\item 
reference \hyperlink{namespaceprism_a675cbab48f22d95f990b33294a447dfe}{at} (const int i)
\item 
reference \hyperlink{namespaceprism_a32fa4c8645ce4e3df7586e5a9f50c768}{back} ()
\item 
iterator \hyperlink{namespaceprism_a05fcc740caf535a0f4ee6bba7301cf7f}{begin} ()
\item 
const int \hyperlink{namespaceprism_a7f11d607fd7daaeaf07d7b83e1add209}{capacity} () const 
\item 
const\+\_\+iterator \hyperlink{namespaceprism_acd7a4333c9a67559cfd90bb6d1c85420}{cbegin} () const 
\item 
const\+\_\+iterator \hyperlink{namespaceprism_a0247b88b3e29f34b1cb742d724a6a330}{cend} () const 
\item 
void \hyperlink{namespaceprism_ad22144cb445517f69b2e6f76586cf75d}{clear} ()
\item 
const\+\_\+iterator \hyperlink{namespaceprism_a8f07ef2e7db05a23c631dee99ad4eba3}{const\+Begin} () const 
\item 
const\+\_\+iterator \hyperlink{namespaceprism_a61b5e8524d7d3106a0b01cd002af8f75}{const\+End} () const 
\item 
const bool \hyperlink{namespaceprism_aec550341cf4587d3a0afaa9492e77503}{contains} (const T \&value) const 
\item 
const int \hyperlink{namespaceprism_a02873ae9088199948854cc05b20831c5}{count} (const T \&value) const 
\item 
const bool \hyperlink{namespaceprism_a7441180af2d914cc54ac35aead6ed030}{empty} () const 
\item 
iterator \hyperlink{namespaceprism_a8976ba2aea6612a03f75a390f40daef8}{end} ()
\item 
const bool \hyperlink{namespaceprism_abfc42fa48a8be97e541b137e9ae83c18}{ends\+With} (const T \&value) const 
\item 
iterator \hyperlink{namespaceprism_a46f69cc5e78e0a7bcd2d9a7ed9c05a8b}{erase} (iterator pos)
\item 
iterator \hyperlink{namespaceprism_ab853ba84b4ed547730d02a8c21328e65}{erase} (iterator \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first}, iterator \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last})
\item 
void \hyperlink{namespaceprism_ab76b40745e46fbda01eb55d8258ff498}{fill} (const T \&value)
\item 
reference \hyperlink{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{first} ()
\item 
reference \hyperlink{namespaceprism_a0c27e6535264895614b87eefa337404d}{front} ()
\item 
const int \hyperlink{namespaceprism_a78b6d3259343e632ab4e9d806498ac92}{index\+Of} (const T \&value, const int from=0) const 
\item 
void \hyperlink{namespaceprism_af52510a241330236aa7202abf65c6dcb}{insert} (const int index, const T \&value)
\item 
void \hyperlink{namespaceprism_abd912a072952b08ebd1009abbede3ee5}{insert} (const int index, const int \hyperlink{namespaceprism_a024117fc3639cdf6598509edf22f034a}{count}, const T \&value)
\item 
iterator \hyperlink{namespaceprism_a391f88be142a74df98c77632bb8352af}{insert} (iterator insert\+Before, const T \&value)
\item 
iterator \hyperlink{namespaceprism_a414531a413ed8c90d951f6fd94ac5535}{insert} (iterator insert\+Before, const int \hyperlink{namespaceprism_a024117fc3639cdf6598509edf22f034a}{count}, const T \&value)
\item 
const bool \hyperlink{namespaceprism_a538f7dd7bdd8d7963b39a9aea232a598}{is\+Empty} () const 
\item 
reference \hyperlink{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{last} ()
\item 
const int \hyperlink{namespaceprism_af0ed081bf6c17e965bfac0d207cd6c28}{last\+Index\+Of} (const T \&value, int from=-\/1) const 
\item 
\hyperlink{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}{Deque}$<$ T, T\+\_\+\+Alloc $>$ \hyperlink{namespaceprism_aeb39a03321ba086c660e96bfa11d33c4}{mid} (const int start\+Index, const int \hyperlink{namespaceprism_a024117fc3639cdf6598509edf22f034a}{count}) const 
\item 
void \hyperlink{namespaceprism_a682dc15d5493595804b4cf818b16281d}{pop\+\_\+back} ()
\item 
void \hyperlink{namespaceprism_a407f71f548b4930e7880b44cd695b33d}{pop\+\_\+front} ()
\item 
void \hyperlink{namespaceprism_ac5a9a7c94d57bb61f25a61ef10d74b80}{prepend} (const T \&value)
\item 
void \hyperlink{namespaceprism_aae03a861ef55e15b5a64c5cb2a727667}{push\+\_\+back} (const T \&value)
\item 
void \hyperlink{namespaceprism_a9a451a8db591d6c4fc315b05f9bff515}{push\+\_\+front} (const T \&value)
\item 
void \hyperlink{namespaceprism_a5b180b06c92cd65b70d2e565878e5d06}{remove} (const int index)
\item 
void \hyperlink{namespaceprism_a2a67eb6dd63f426b2837aebb07940b0b}{remove} (const int index, const int \hyperlink{namespaceprism_a024117fc3639cdf6598509edf22f034a}{count})
\item 
void \hyperlink{namespaceprism_a91a96073d835746d48ba0a145c33b29e}{remove\+All} (const T \&value)
\item 
void \hyperlink{namespaceprism_a32a0d96bc03a45529e399cd39c48cb66}{remove\+First} ()
\item 
void \hyperlink{namespaceprism_a7dd774edd9e5b7398334440070da6bdd}{remove\+Last} ()
\item 
void \hyperlink{namespaceprism_acac76605957b60675b2859cef694c61f}{replace} (const int index, const T \&value)
\item 
void \hyperlink{namespaceprism_a7236cdb4e2661bd63c2fe4ee5c3452f9}{resize} (const int new\+Size, const T \&value=T())
\item 
const int \hyperlink{namespaceprism_acd3c0f96adf158a29387191d79c4d874}{size} () const 
\item 
const bool \hyperlink{namespaceprism_a92e90ca54b9fa627213076f93d44ca2d}{starts\+With} (const T \&value) const 
\item 
\hyperlink{classprism_1_1_list}{List}$<$ T $>$ \hyperlink{namespaceprism_a07654e91e7474a3ccdcd95bb5e57baea}{to\+List} () const 
\item 
std\+::deque$<$ T $>$ \hyperlink{namespaceprism_a770640a1fe99095d96e9295b225ac93d}{to\+Std\+Deque} () const 
\item 
reference \hyperlink{namespaceprism_ae5cdc796ecf7df67ce6377bfe9eadb7c}{operator\mbox{[}$\,$\mbox{]}} (const int i)
\item 
\hyperlink{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}{Deque}$<$ T, T\+\_\+\+Alloc $>$ \& \hyperlink{namespaceprism_ab5a3ba3d60ef11974d02f7941fa9a263}{operator=} (const \hyperlink{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}{Deque}$<$ T, T\+\_\+\+Alloc $>$ \&rhs)
\item 
const bool \hyperlink{namespaceprism_a47eb78b48fe05bc2087a1c5e70f4c373}{operator==} (const \hyperlink{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}{Deque}$<$ T, T\+\_\+\+Alloc $>$ \&rhs)
\item 
const bool \hyperlink{namespaceprism_a7410d6cd07f48e8495d2ac7196b2e609}{operator!=} (const \hyperlink{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}{Deque}$<$ T, T\+\_\+\+Alloc $>$ \&rhs)
\item 
\hyperlink{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}{Deque}$<$ T, Alloc $>$ \hyperlink{namespaceprism_a769b9ece349795edbfeb8e33cbf276e5}{operator+} (const \hyperlink{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}{Deque}$<$ T, Alloc $>$ \&rhs)
\item 
\hyperlink{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}{Deque}$<$ T, Alloc $>$ \& \hyperlink{namespaceprism_a1619579754dfe66f3fe3559f2e4495e5}{operator+=} (const \hyperlink{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}{Deque}$<$ T, Alloc $>$ \&rhs)
\item 
\hyperlink{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}{Deque}$<$ T, T\+\_\+\+Alloc $>$ \& \hyperlink{namespaceprism_a40203d2e776fe0acf317a98ef08f8be7}{operator$<$$<$} (const T \&value)
\item 
\hyperlink{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}{Deque}$<$ T, T\+\_\+\+Alloc $>$ \& \hyperlink{namespaceprism_a602c194731bf182cf114b7d297bbff51}{operator$<$$<$} (const \hyperlink{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}{Deque}$<$ T, T\+\_\+\+Alloc $>$ \&rhs)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a554e40f4cee7980e001683ea75b16cd9}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}{Deque}$<$ T, T\+\_\+\+Alloc $>$ \&d)
\item 
{\footnotesize template$<$class T $>$ }\\std\+::ostream \& \hyperlink{namespaceprism_a50da64555d454821545fe0311fde6a62}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_list}{List}$<$ T $>$ \&list)
\item 
{\footnotesize template$<$class T , typename... Args$>$ }\\void \hyperlink{namespaceprism_af62c0c26668facbe5607e8915442010e}{construct} (T $\ast$p, Args \&\&...args)
\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{namespaceprism_af889ac2726920ab1b4f5361e6563d041}{destroy} (T $\ast$p)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_a9df924e4deb059bf1200701c8235410a}{operator!=} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_ad6391c124e006b0e3a3ec67f55e208b0}{operator!=} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const U $\ast$p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_ab8792dbd5cac5678390843bacdb69daa}{operator!=} (const U $\ast$p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_ae53d52e8a36ec7ca58ea1731cc18f1d8}{operator==} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_a2b73e87f080646696ed6b595a3900119}{operator==} (const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p1, const U $\ast$p2)
\item 
{\footnotesize template$<$class U $>$ }\\const bool \hyperlink{namespaceprism_a1f29b22985dc0ec1fc548a551ce313ed}{operator==} (const U $\ast$p1, const \hyperlink{classprism_1_1_shared_pointer}{Shared\+Pointer}$<$ U $>$ \&p2)
\item 
\hyperlink{classprism_1_1_bitvector}{Bitvector} \hyperlink{namespaceprism_a26b2b2b5b2c5f305badd964c24625b36}{operator\&} (const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv1, const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv2)
\item 
\hyperlink{classprism_1_1_bitvector}{Bitvector} \hyperlink{namespaceprism_a145d1e196c14cdbdc4eccb01c60c9275}{operator$\vert$} (const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv1, const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv2)
\item 
\hyperlink{classprism_1_1_bitvector}{Bitvector} \hyperlink{namespaceprism_a6a18ff84f30ae8056d6807056a24ef14}{operator$^\wedge$} (const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv1, const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv2)
\item 
const bool \hyperlink{namespaceprism_aca036c7f0f8a5aaf98b46b4879189bcc}{operator==} (const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv1, const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv2)
\item 
const bool \hyperlink{namespaceprism_aca663878d61686ef365f3e51efddc4b4}{operator!=} (const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv1, const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a0b98ff0fee78022242292f24158ad1f0}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_bitvector}{Bitvector} \&bv)
\item 
const bool \hyperlink{namespaceprism_a1ba68b64a6cfdcff9e144b8c2476cddb}{operator==} (const \hyperlink{classprism_1_1_char}{Char} \&c1, const \hyperlink{classprism_1_1_char}{Char} \&c2)
\item 
const bool \hyperlink{namespaceprism_a249b6933154570d808cdd405ab1fd89b}{operator!=} (const \hyperlink{classprism_1_1_char}{Char} \&c1, const \hyperlink{classprism_1_1_char}{Char} \&c2)
\item 
const bool \hyperlink{namespaceprism_a2fc3e64ba36a16f24cb0ae387c83f35f}{operator$<$} (const \hyperlink{classprism_1_1_char}{Char} \&c1, const \hyperlink{classprism_1_1_char}{Char} \&c2)
\item 
const bool \hyperlink{namespaceprism_ab8a312729c4c9ae72836d0034a6f0758}{operator$>$} (const \hyperlink{classprism_1_1_char}{Char} \&c1, const \hyperlink{classprism_1_1_char}{Char} \&c2)
\item 
const bool \hyperlink{namespaceprism_a87d86e9266469c8a40537e12a560b066}{operator$<$=} (const \hyperlink{classprism_1_1_char}{Char} \&c1, const \hyperlink{classprism_1_1_char}{Char} \&c2)
\item 
const bool \hyperlink{namespaceprism_aad049ddef9beb3fec3e7057a7f651280}{operator$>$=} (const \hyperlink{classprism_1_1_char}{Char} \&c1, const \hyperlink{classprism_1_1_char}{Char} \&c2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_aa67ea1154a35dabe9c2c232aff65e930}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_char}{Char} \&c)
\item 
const bool \hyperlink{namespaceprism_a0ce1ad6e6392618212d5ab3bebb8e585}{operator==} (const \hyperlink{classprism_1_1_circle}{Circle} \&c1, const \hyperlink{classprism_1_1_circle}{Circle} \&c2)
\item 
const bool \hyperlink{namespaceprism_a58cbf7ef406800002b446a0f1e917745}{operator!=} (const \hyperlink{classprism_1_1_circle}{Circle} \&c1, const \hyperlink{classprism_1_1_circle}{Circle} \&c2)
\item 
const bool \hyperlink{namespaceprism_a8e662d15b162ca76912c491798caefd3}{operator$<$} (const \hyperlink{classprism_1_1_circle}{Circle} \&c1, const \hyperlink{classprism_1_1_circle}{Circle} \&c2)
\item 
const bool \hyperlink{namespaceprism_a671739ac8567654dba563c34af92213f}{operator$>$} (const \hyperlink{classprism_1_1_circle}{Circle} \&c1, const \hyperlink{classprism_1_1_circle}{Circle} \&c2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_aa63d3d39d3fad8fa5c5966cc4f306324}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_circle}{Circle} \&c)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_ac1b5b2765c314b2baa2dba5c57419829}{operator+} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_a2daf470e5f35f8450447deb2634c22c1}{operator-\/} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_ac4f48e3429a86bafcc7c21a2bd6a7ae1}{operator$\ast$} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_a1f5007702b28b447f62c3b9df62f2aa4}{operator$\ast$} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&fraction, const int i)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_af1ff5871f65565a84b886c5013bcd50a}{operator$\ast$} (const int i, const \hyperlink{classprism_1_1_fraction}{Fraction} \&fraction)
\item 
\hyperlink{classprism_1_1_fraction}{Fraction} \hyperlink{namespaceprism_a7ba7b5cc9750f0d6cda50f0cb874da6f}{operator/} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
const bool \hyperlink{namespaceprism_a105ac9995ade66ebb2a039ef90751c7a}{operator$<$} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
const bool \hyperlink{namespaceprism_a7122a7ff43fc6aba9cef9d31fe8c7559}{operator$>$} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
const bool \hyperlink{namespaceprism_a5b9e84008b9eaa99d29d4b74cd150cd8}{operator==} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
const bool \hyperlink{namespaceprism_aea72179b12983e614f72acd2b3cbf0e0}{operator!=} (const \hyperlink{classprism_1_1_fraction}{Fraction} \&f1, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a9c2d182a77a92e6cba7917dbd58f9d87}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_fraction}{Fraction} \&f)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a33537d30f01f996f8a05fc5b1b49ba3b}{operator+} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a34a2f64f209065f753bed62a880b75b6}{operator-\/} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a879d3410d690b5722a9af17297f38fbb}{operator-\/} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a9ae44fb46bb709a5c8f4d592baf65522}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_ab3639f7bd46a54726522dfe406841ea9}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a4073983f089695c40b6fd20d892175f9}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m, const float factor)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_aa2859acb8e8dd6fea8678e14249e561d}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const float $\ast$m2)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a5e83bcd69595728106bed838aeb32f70}{operator$\ast$} (const float $\ast$m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a95ceb3342a808c88d0bb7c1f7e0ef82b}{operator$\ast$} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&v, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a04f1e6e0f84169fce23b236e0312d6a0}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m, const \hyperlink{classprism_1_1_vector3}{Vector3} \&v)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_a5a10d8ea1e63b19d02bd294e4ebabb1b}{operator$\ast$} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&v, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_ad125bd8304d577b6f879fb973f774eb8}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m, const \hyperlink{classprism_1_1_vector4}{Vector4} \&v)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a44373b8bda7131a90d04eef7e455ea6f}{operator$\ast$} (const \hyperlink{classprism_1_1_point}{Point} \&p, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a82522932359d2381607cf1fe0c898011}{operator$\ast$} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m, const \hyperlink{classprism_1_1_point}{Point} \&p)
\item 
\hyperlink{classprism_1_1_matrix4}{Matrix4} \hyperlink{namespaceprism_a517b4bc9b0ccc23f79b744d93b540fa6}{operator/} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m, const float divisor)
\item 
const bool \hyperlink{namespaceprism_a8804ec2ab8dda9441d64e947f05e293c}{operator==} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
const bool \hyperlink{namespaceprism_a4d184994eec61a1511fc936a9facb69a}{operator!=} (const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m1, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&m2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_ab65e15b3e601e0570beb49a11610c671}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_matrix4}{Matrix4} \&matrix)
\item 
std\+::ostream \& \hyperlink{namespaceprism_acb9fe7ab8ef5f1ee0338e3b057624393}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_point}{Point} \&p)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a49e983b5c32c93114583309eda19dc2b}{operator+} (const \hyperlink{classprism_1_1_point}{Point} \&p1, const \hyperlink{classprism_1_1_point}{Point} \&p2)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a505cbd94f024ad80136afe0b751da08a}{operator-\/} (const \hyperlink{classprism_1_1_point}{Point} \&p1, const \hyperlink{classprism_1_1_point}{Point} \&p2)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a40976ce143923309d4c737bb8288d9e5}{operator$\ast$} (const \hyperlink{classprism_1_1_point}{Point} \&p, const int factor)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a96e41c0858ff4149eafa1bc878dabb7c}{operator$\ast$} (const \hyperlink{classprism_1_1_point}{Point} \&p, const float factor)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_aa46a547ddc48425588986b0840d026a4}{operator$\ast$} (const int factor, const \hyperlink{classprism_1_1_point}{Point} \&p)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a1ec2671f1e6c155a79740a8556baecc0}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_point}{Point} \&p)
\item 
\hyperlink{classprism_1_1_point}{Point} \hyperlink{namespaceprism_a5f73aee33931e5b9977da32e50d47c0e}{operator/} (const \hyperlink{classprism_1_1_point}{Point} \&p, const float divisor)
\item 
bool \hyperlink{namespaceprism_a739baa4e75c1ca83624d486eec1d45e9}{operator==} (const \hyperlink{classprism_1_1_point}{Point} \&p1, const \hyperlink{classprism_1_1_point}{Point} \&p2)
\item 
bool \hyperlink{namespaceprism_a75cab41d882d24ca064927f2390ef3a6}{operator!=} (const \hyperlink{classprism_1_1_point}{Point} \&p1, const \hyperlink{classprism_1_1_point}{Point} \&p2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_acad408bf2576dfc62a573cb44aa895fb}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p)
\item 
\hyperlink{classprism_1_1_pointf}{Pointf} \hyperlink{namespaceprism_a64243aa2d4cf6ddb70526aaeda396f82}{operator+} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p1, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p2)
\item 
\hyperlink{classprism_1_1_pointf}{Pointf} \hyperlink{namespaceprism_a435d5c45d873875f2c5092d102eddb78}{operator-\/} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p1, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p2)
\item 
\hyperlink{classprism_1_1_pointf}{Pointf} \hyperlink{namespaceprism_ade1984e58679ef4d8fcdd37726ee6483}{operator$\ast$} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p, const float factor)
\item 
\hyperlink{classprism_1_1_pointf}{Pointf} \hyperlink{namespaceprism_a409aa6b61b79f029d78f6d4c3aba2df5}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p)
\item 
\hyperlink{classprism_1_1_pointf}{Pointf} \hyperlink{namespaceprism_a71504f6dd299e8bc788e07d11d29dc5e}{operator/} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p, const float divisor)
\item 
bool \hyperlink{namespaceprism_a13ab889958edc08eea9a5bea056cd9c1}{operator==} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p1, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p2)
\item 
bool \hyperlink{namespaceprism_ae010d5880eb7bcf5119f006e26bf473f}{operator!=} (const \hyperlink{classprism_1_1_pointf}{Pointf} \&p1, const \hyperlink{classprism_1_1_pointf}{Pointf} \&p2)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_ad81bceaddc25922e571b4bf427ffe296}{operator+} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q1, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q2)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_a5eae37b5dc73c544572686f215cea89d}{operator-\/} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q1, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q2)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_ae04c2e5eae2242c58a967086ecad8ff4}{operator-\/} (\hyperlink{classprism_1_1_quaternion}{Quaternion} \&q)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_a74c3eeec91c3a178711b6f05a5487d70}{operator$\ast$} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q1, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q2)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_a45806b1a58ec5aae0db87d399d4d832b}{operator$\ast$} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q, const float factor)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_ad9f03413053b1efa6851344eb39a5982}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_a8aebd3615ba448915f37140515a37b05}{operator$\ast$} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q, const \hyperlink{classprism_1_1_vector3}{Vector3} \&v)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_a2c4c5e120d8c4de9891f2261a50f100e}{operator$\ast$} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q, const \hyperlink{classprism_1_1_vector4}{Vector4} \&v)
\item 
\hyperlink{classprism_1_1_quaternion}{Quaternion} \hyperlink{namespaceprism_aec648937a53338bcd9879670877d0425}{operator/} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q, const float divisor)
\item 
const bool \hyperlink{namespaceprism_ac4ae112433b9ab32c801cccc9c3f74f0}{operator==} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q1, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q2)
\item 
const bool \hyperlink{namespaceprism_a9e32551f997ae19dc52df146482405c1}{operator!=} (const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q1, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_ad2beaed7a837821f0abc608cf6ac6c0f}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_quaternion}{Quaternion} \&q)
\item 
const bool \hyperlink{namespaceprism_abe409fa2ef458a2d477ed7845cf4b6a6}{operator==} (const \hyperlink{classprism_1_1_rect}{Rect} \&r1, const \hyperlink{classprism_1_1_rect}{Rect} \&r2)
\item 
const bool \hyperlink{namespaceprism_ad9f46c5ebd3cec844925173aaacbed9f}{operator!=} (const \hyperlink{classprism_1_1_rect}{Rect} \&r1, const \hyperlink{classprism_1_1_rect}{Rect} \&r2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a52fd2a97b66b06ba6e451e1890136ff4}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_rect}{Rect} \&rect)
\item 
const bool \hyperlink{namespaceprism_a2a7baeb09cd2ee29251667ad18a2bd00}{operator==} (const \hyperlink{classprism_1_1_size}{Size} \&s1, const \hyperlink{classprism_1_1_size}{Size} \&s2)
\item 
const bool \hyperlink{namespaceprism_a63ab3c18ecc73e21e7281dbe180e07e8}{operator!=} (const \hyperlink{classprism_1_1_size}{Size} \&s1, const \hyperlink{classprism_1_1_size}{Size} \&s2)
\item 
\hyperlink{classprism_1_1_size}{Size} \hyperlink{namespaceprism_a7141aeb35db81548155e44d60c05530e}{operator+} (const \hyperlink{classprism_1_1_size}{Size} \&s1, const \hyperlink{classprism_1_1_size}{Size} \&s2)
\item 
\hyperlink{classprism_1_1_size}{Size} \hyperlink{namespaceprism_ab170e3ca42d85a6766cbc7950ddfb0c4}{operator-\/} (const \hyperlink{classprism_1_1_size}{Size} \&s1, const \hyperlink{classprism_1_1_size}{Size} \&s2)
\item 
\hyperlink{classprism_1_1_size}{Size} \hyperlink{namespaceprism_a3d8e53ee3208e09e8736a77be3f485c9}{operator$\ast$} (const \hyperlink{classprism_1_1_size}{Size} \&\hyperlink{namespaceprism_acd3c0f96adf158a29387191d79c4d874}{size}, const int factor)
\item 
\hyperlink{classprism_1_1_size}{Size} \hyperlink{namespaceprism_acd79758984cccce0dddfb459af65f6e1}{operator$\ast$} (const int factor, const \hyperlink{classprism_1_1_size}{Size} \&\hyperlink{namespaceprism_acd3c0f96adf158a29387191d79c4d874}{size})
\item 
\hyperlink{classprism_1_1_size}{Size} \hyperlink{namespaceprism_ad7e100bd6b1730deaab53d1218e29a67}{operator/} (const \hyperlink{classprism_1_1_size}{Size} \&\hyperlink{namespaceprism_acd3c0f96adf158a29387191d79c4d874}{size}, const int factor)
\item 
std\+::ostream \& \hyperlink{namespaceprism_ad6335168e27f481d86ae42da444006d1}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_size}{Size} \&\hyperlink{namespaceprism_acd3c0f96adf158a29387191d79c4d874}{size})
\item 
const bool \hyperlink{namespaceprism_a0e7bfee93ae735b5af7e566ddd8c4f65}{operator==} (const \hyperlink{classprism_1_1_string}{String} \&str1, const \hyperlink{classprism_1_1_string}{String} \&str2)
\item 
const bool \hyperlink{namespaceprism_a5c2215edf9ab445c3c1791217d131b15}{operator!=} (const \hyperlink{classprism_1_1_string}{String} \&str1, const \hyperlink{classprism_1_1_string}{String} \&str2)
\item 
const \hyperlink{classprism_1_1_string}{String} \hyperlink{namespaceprism_a433f7afd310d95a93cf8c03d1f831812}{operator+} (const \hyperlink{classprism_1_1_string}{String} \&str1, const \hyperlink{classprism_1_1_string}{String} \&str2)
\item 
const \hyperlink{classprism_1_1_string}{String} \hyperlink{namespaceprism_a50879e9455a36b7762514951ca0f47f7}{operator+} (const \hyperlink{classprism_1_1_string}{String} \&str1, const char $\ast$str2)
\item 
const \hyperlink{classprism_1_1_string}{String} \hyperlink{namespaceprism_a7d59729f69eafd3bc9f4d30ad9dd06b6}{operator+} (const char $\ast$str1, const \hyperlink{classprism_1_1_string}{String} \&str2)
\item 
const \hyperlink{classprism_1_1_string}{String} \hyperlink{namespaceprism_aa0fce6a8b93050fcb6db327e68b701e3}{operator+} (const char c, const \hyperlink{classprism_1_1_string}{String} \&str)
\item 
const \hyperlink{classprism_1_1_string}{String} \hyperlink{namespaceprism_a8ae68ccc6eb3a47a748671c1a7af88ca}{operator+} (const \hyperlink{classprism_1_1_string}{String} \&str, const char c)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a0a166bbf645cc854542cc0fc50324670}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_string}{String} \&s)
\item 
\hyperlink{classprism_1_1_time}{Time} \hyperlink{namespaceprism_afd483f03b731881b25da5612b1213e5f}{operator+} (const \hyperlink{classprism_1_1_time}{Time} \&t1, const \hyperlink{classprism_1_1_time}{Time} \&t2)
\item 
\hyperlink{classprism_1_1_time}{Time} \hyperlink{namespaceprism_aa18009df22007fbbde08ab44b16a9a31}{operator-\/} (const \hyperlink{classprism_1_1_time}{Time} \&t1, const \hyperlink{classprism_1_1_time}{Time} \&t2)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a7c24ead13d51c13dcadde1b6df4a4967}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_time}{Time} \&t)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_ae482804c32b466401a9ecdf26bc1e6de}{operator+} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&a, const \hyperlink{classprism_1_1_vector2}{Vector2} \&b)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_a86359a88dc5245847de48575a1f969e8}{operator-\/} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&a, const \hyperlink{classprism_1_1_vector2}{Vector2} \&b)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_a124f1081b3a9bbc441dac9927f8a0fc5}{operator-\/} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&v)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_a6528ec4496096e8ccde186bb01fbeed3}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_vector2}{Vector2} \&v)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_a1de3bc1dbc3fd33f26d580bce3520854}{operator$\ast$} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&v, const float factor)
\item 
\hyperlink{classprism_1_1_vector2}{Vector2} \hyperlink{namespaceprism_aea1ab02785c9d4d5ea560face252b75e}{operator/} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&v, const float divisor)
\item 
const bool \hyperlink{namespaceprism_a311fc983ec89876189643e840d781974}{operator==} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&a, const \hyperlink{classprism_1_1_vector2}{Vector2} \&b)
\item 
const bool \hyperlink{namespaceprism_a7e9d0b027a9e7d9e313affe5af91dabc}{operator!=} (const \hyperlink{classprism_1_1_vector2}{Vector2} \&a, const \hyperlink{classprism_1_1_vector2}{Vector2} \&b)
\item 
std\+::ostream \& \hyperlink{namespaceprism_a4616180b97f4288a3b3e28304efee020}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_vector2}{Vector2} \&v)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a7ac90b31f235390d6feb818e3f88ecf0}{operator+} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&a, const \hyperlink{classprism_1_1_vector3}{Vector3} \&b)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a3beb56b334423e027f1ab185785695f8}{operator-\/} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&a, const \hyperlink{classprism_1_1_vector3}{Vector3} \&b)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a8f7cf835ff415e187e6881169803f502}{operator-\/} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&v)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a429cccc5eee454ba019045afb4a01e93}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_vector3}{Vector3} \&v)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_aa1f2f6de8bf1b584cbb82062a607e167}{operator$\ast$} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&v, const float factor)
\item 
\hyperlink{classprism_1_1_vector3}{Vector3} \hyperlink{namespaceprism_a87e022748076586917c38e83430df284}{operator/} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&v, const float divisor)
\item 
const bool \hyperlink{namespaceprism_a2fc2a483f2e3ec622ad2c0ac9699fbcb}{operator==} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&a, const \hyperlink{classprism_1_1_vector3}{Vector3} \&b)
\item 
const bool \hyperlink{namespaceprism_aa752c5d0210902dece31c2fcfc98a824}{operator!=} (const \hyperlink{classprism_1_1_vector3}{Vector3} \&a, const \hyperlink{classprism_1_1_vector3}{Vector3} \&b)
\item 
std\+::ostream \& \hyperlink{namespaceprism_aa7b9367a483153af865552ba486f1196}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_vector3}{Vector3} \&v)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_a4ac9ebc0ce1449793eb8f521c64929a9}{operator+} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&a, const \hyperlink{classprism_1_1_vector4}{Vector4} \&b)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_a038a64f530d1c50bf72cf1a23886ecca}{operator-\/} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&a, const \hyperlink{classprism_1_1_vector4}{Vector4} \&b)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_a147712ae50c37618cbc61f20efe6729f}{operator-\/} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&v)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_aa652a61fe96302693aa0279e832360c7}{operator$\ast$} (const float factor, const \hyperlink{classprism_1_1_vector4}{Vector4} \&v)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_ab3b4a59d9247143b49db3c2778838895}{operator$\ast$} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&v, const float factor)
\item 
\hyperlink{classprism_1_1_vector4}{Vector4} \hyperlink{namespaceprism_a4aa2b9a75c3d5134fc80cc6afc1be443}{operator/} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&v, const float divisor)
\item 
const bool \hyperlink{namespaceprism_a80bdef743a64c754bf1a2b217c82f60a}{operator==} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&a, const \hyperlink{classprism_1_1_vector4}{Vector4} \&b)
\item 
const bool \hyperlink{namespaceprism_a1ffa413af039c2bff07202dcfce55f05}{operator!=} (const \hyperlink{classprism_1_1_vector4}{Vector4} \&a, const \hyperlink{classprism_1_1_vector4}{Vector4} \&b)
\item 
std\+::ostream \& \hyperlink{namespaceprism_aeb86919d9ba71747d21fbd6e28671692}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classprism_1_1_vector4}{Vector4} \&v)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Completely and shamefully lifted from Qt\textquotesingle{}s Q\+Flag/\+Q\+Flags classes and macros and just renamed without the prepended \textquotesingle{}Q\textquotesingle{}. These classes allow enums to be treated as datatypes when passed to methods. They are also type-\/safe so that the receiving method is expecting the enum and not the basic int equivalent. So print\+Flag(\+Label\+::\+Align\+Left) works whilst print\+Flag(2) doesn\textquotesingle{}t.

For example,

class Label \{ private\+: enum Alignment \{ Align\+Left = 0x1, Align\+Right = 0x2 \} \hyperlink{_flags_8h_aa5aa2c9827ab949836e20999b9a068ec}{P\+R\+I\+S\+M\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+F\+L\+A\+G\+S(\+Align\+Flags, Alignment)} \}

// outside class def \hyperlink{_flags_8h_ae8aabb683a18b872a4449769b82e8e15}{P\+R\+I\+S\+M\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+O\+P\+E\+R\+A\+T\+O\+R\+S\+\_\+\+F\+O\+R\+\_\+\+F\+L\+A\+G\+S(\+Label\+::\+Align\+Flags)}

void print\+Flag(\+Label\+::\+Align\+Flags f) \{ if (f == Label\+::\+Align\+Left) std\+::cout $<$$<$ \char`\"{}\+Align\+Left\char`\"{} $<$$<$ std\+::endl; else if (f == Label\+::\+Align\+Right) std\+::cout $<$$<$ \char`\"{}\+Align\+Right\char`\"{} $<$$<$ std\+::endl; else std\+::cout $<$$<$ f $<$$<$ std\+::endl; \}

int main(int argc, char$\ast$$\ast$ argv) \{ print\+Flag(\+Label\+::\+Align\+Left); \}

This simple class extends the \hyperlink{classprism_1_1_allocator}{Allocator} class by logging each memory allocation and deallocation by storing the newly allocated pointer in a \hyperlink{classprism_1_1_vector}{Vector} on allocation and removes it when the pointer is deallocated. In theory, at the end of the \hyperlink{classprism_1_1_logger_allocator}{Logger\+Allocator}\textquotesingle{}s lifetime the \hyperlink{classprism_1_1_vector}{Vector} should be empty as all pointers should be deallocated. If there are still pointers in the vector then an error message is printed to the console.

A \hyperlink{classprism_1_1_quaternion}{Quaternion} is made up of four components (w, x, y and z) which are a scalar (w) and a 3d vector (x, y and z). It does not suffer from gimbal lock and yet can represent any orientation possible.

Some interesting properties of quaternion multiplication\+: a) it is associative but not commutitive -\/ (ab)c = a(bc) ab != ba

b) the magnitude of a quaternion product equals the product of the individual magnitudes. This is an important concept because when quaternions are of unit length and are multiplied, this guarentees us that the result will itself be a unit quaternion -\/ $\vert$$\vert$ab$\vert$$\vert$ = $\vert$$\vert$a$\vert$$\vert$$\vert$$\vert$b$\vert$$\vert$

c) the inverse of a quaternion product is equal to the product of the individual quaternion inverses in reverse order -\/ (ab).inverse = (b.\+inverse) $\ast$ (a.\+inverse)

Rotating vectors\+: When rotating with a quaternion it is important that the quaternion be normalised i.\+e. be of unit length. This is because otherwise scaling will occur and since we only require rotations from our quaternions this won\textquotesingle{}t do. Rotating a vector using quaternions is done with the following equation\+: v\textquotesingle{} = q $\ast$ v $\ast$ q.\+inverse where vector v is represented as a quaternion.

Concatenating rotational transforms together\+: Multiple quaternion rotations can be applied to a vector in one single action by concatenating the rotational quaternions together and then applying them to the vector using the above equation. For example, to rotate the vector v by quaternion a and then rotating that result by quaternion b would be as follows\+: v\textquotesingle{} = b $\ast$ (a $\ast$ v $\ast$ a.\+inverse) $\ast$ b.\+inverse = (b $\ast$ a) $\ast$ v $\ast$ (b.\+inverse $\ast$ a.\+inverse) = (b $\ast$ a) $\ast$ v $\ast$ (b $\ast$ a).inverse So, rotating by a and then by b is equivalent to the single rotation of the product of ba. 

\subsection{Function Documentation}
\index{prism@{prism}!adjacent\+\_\+find@{adjacent\+\_\+find}}
\index{adjacent\+\_\+find@{adjacent\+\_\+find}!prism@{prism}}
\subsubsection[{\texorpdfstring{adjacent\+\_\+find(\+Forward\+Iterator first, Forward\+Iterator last)}{adjacent_find(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ Forward\+Iterator prism\+::adjacent\+\_\+find (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a82052418345794a13044c15d8e32dd89}{}\label{namespaceprism_a82052418345794a13044c15d8e32dd89}
Searches the range {\itshape }\mbox{[}first,last\mbox{]} for the first occurrence of two consecutive elements that match. \begin{DoxyReturn}{Returns}
Returns an iterator to the first of these two elements, or {\itshape last} if no such pair is found. 
\end{DoxyReturn}
\index{prism@{prism}!adjacent\+\_\+find\+\_\+aux@{adjacent\+\_\+find\+\_\+aux}}
\index{adjacent\+\_\+find\+\_\+aux@{adjacent\+\_\+find\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{adjacent\+\_\+find\+\_\+aux(\+Forward\+Iterator first, Forward\+Iterator last)}{adjacent_find_aux(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ Forward\+Iterator prism\+::adjacent\+\_\+find\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6b26c227e2d379b9d934a85a2570bae7}{}\label{namespaceprism_a6b26c227e2d379b9d934a85a2570bae7}
Searches the range {\itshape }\mbox{[}first,last\mbox{]} for the first occurrence of two consecutive elements that match. \begin{DoxyReturn}{Returns}
Returns an iterator to the first of these two elements, or {\itshape last} if no such pair is found. 
\end{DoxyReturn}
\index{prism@{prism}!all\+\_\+of@{all\+\_\+of}}
\index{all\+\_\+of@{all\+\_\+of}!prism@{prism}}
\subsubsection[{\texorpdfstring{all\+\_\+of(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{all_of(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ bool prism\+::all\+\_\+of (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aba366b328f3b6161e6115c16b7153c6d}{}\label{namespaceprism_aba366b328f3b6161e6115c16b7153c6d}
Returns true if {\itshape pred} returns true for all the elements in the range {\itshape }\mbox{[}first,last\mbox{]} or if the range is empty, and false otherwise. \index{prism@{prism}!all\+\_\+of\+\_\+aux@{all\+\_\+of\+\_\+aux}}
\index{all\+\_\+of\+\_\+aux@{all\+\_\+of\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{all\+\_\+of\+\_\+aux(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{all_of_aux(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ bool prism\+::all\+\_\+of\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_adee0c5bacf315d8cfdc4de7151ba2295}{}\label{namespaceprism_adee0c5bacf315d8cfdc4de7151ba2295}
Returns true if {\itshape pred} returns true for all the elements in the range {\itshape }\mbox{[}first,last\mbox{]} or if the range is empty, and false otherwise. \index{prism@{prism}!allocator@{allocator}}
\index{allocator@{allocator}!prism@{prism}}
\subsubsection[{\texorpdfstring{allocator() const }{allocator() const }}]{\setlength{\rightskip}{0pt plus 5cm}T\+\_\+\+Alloc prism\+::allocator (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_af48d4e417d7dc90cd7979795347e1718}{}\label{namespaceprism_af48d4e417d7dc90cd7979795347e1718}
\index{prism@{prism}!any\+\_\+of@{any\+\_\+of}}
\index{any\+\_\+of@{any\+\_\+of}!prism@{prism}}
\subsubsection[{\texorpdfstring{any\+\_\+of(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{any_of(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ bool prism\+::any\+\_\+of (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5d0e3ddb9f698759635572f1220ec0ca}{}\label{namespaceprism_a5d0e3ddb9f698759635572f1220ec0ca}
Returns true if {\itshape pred} returns true for any of the elements in the range {\itshape }\mbox{[}first, last\mbox{]}. \index{prism@{prism}!any\+\_\+of\+\_\+aux@{any\+\_\+of\+\_\+aux}}
\index{any\+\_\+of\+\_\+aux@{any\+\_\+of\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{any\+\_\+of\+\_\+aux(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{any_of_aux(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ bool prism\+::any\+\_\+of\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aae3105c7afbb375201f4691b7ea966b4}{}\label{namespaceprism_aae3105c7afbb375201f4691b7ea966b4}
Returns true if {\itshape pred} returns true for any of the elements in the range {\itshape }\mbox{[}first, last\mbox{]}. \index{prism@{prism}!append@{append}}
\index{append@{append}!prism@{prism}}
\subsubsection[{\texorpdfstring{append(const T \&value)}{append(const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::append (
\begin{DoxyParamCaption}
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_afc3c0da5e0e065dd58d686f551746982}{}\label{namespaceprism_afc3c0da5e0e065dd58d686f551746982}
\index{prism@{prism}!at@{at}}
\index{at@{at}!prism@{prism}}
\subsubsection[{\texorpdfstring{at(const int i)}{at(const int i)}}]{\setlength{\rightskip}{0pt plus 5cm}const\+\_\+reference prism\+::at (
\begin{DoxyParamCaption}
\item[{const int}]{i}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a675cbab48f22d95f990b33294a447dfe}{}\label{namespaceprism_a675cbab48f22d95f990b33294a447dfe}
\begin{DoxyReturn}{Returns}
Returns a reference to the the element at index {\itshape i}. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Throws} & an \hyperlink{classprism_1_1_out_of_bounds_exception}{Out\+Of\+Bounds\+Exception} if {\itshape i} is less than 0 or greater than or equal to {\itshape \hyperlink{namespaceprism_acd3c0f96adf158a29387191d79c4d874}{size()}}.\\
\hline
\end{DoxyExceptions}
\begin{DoxyReturn}{Returns}
Returns a const reference to the the element at index {\itshape i}. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Throws} & an \hyperlink{classprism_1_1_out_of_bounds_exception}{Out\+Of\+Bounds\+Exception} if {\itshape i} is less than 0 or greater than or equal to {\itshape \hyperlink{namespaceprism_acd3c0f96adf158a29387191d79c4d874}{size()}}. \\
\hline
\end{DoxyExceptions}
\index{prism@{prism}!back@{back}}
\index{back@{back}!prism@{prism}}
\subsubsection[{\texorpdfstring{back()}{back()}}]{\setlength{\rightskip}{0pt plus 5cm}const\+\_\+reference prism\+::back (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a32fa4c8645ce4e3df7586e5a9f50c768}{}\label{namespaceprism_a32fa4c8645ce4e3df7586e5a9f50c768}
\begin{DoxyReturn}{Returns}
Returns a reference to the last element in the Deque.

Returns a const reference to the last element in the Deque. 
\end{DoxyReturn}
\index{prism@{prism}!begin@{begin}}
\index{begin@{begin}!prism@{prism}}
\subsubsection[{\texorpdfstring{begin()}{begin()}}]{\setlength{\rightskip}{0pt plus 5cm}const\+\_\+iterator prism\+::begin (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a05fcc740caf535a0f4ee6bba7301cf7f}{}\label{namespaceprism_a05fcc740caf535a0f4ee6bba7301cf7f}
\begin{DoxyReturn}{Returns}
Returns an iterator that points to the first element in the Deque.

Returns a const\+\_\+iterator that points to the first element in the Deque. 
\end{DoxyReturn}
\index{prism@{prism}!capacity@{capacity}}
\index{capacity@{capacity}!prism@{prism}}
\subsubsection[{\texorpdfstring{capacity() const }{capacity() const }}]{\setlength{\rightskip}{0pt plus 5cm}const int prism\+::capacity (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_a7f11d607fd7daaeaf07d7b83e1add209}{}\label{namespaceprism_a7f11d607fd7daaeaf07d7b83e1add209}
\begin{DoxyReturn}{Returns}
Returns the capacity of the Deque. 
\end{DoxyReturn}
\index{prism@{prism}!cbegin@{cbegin}}
\index{cbegin@{cbegin}!prism@{prism}}
\subsubsection[{\texorpdfstring{cbegin() const }{cbegin() const }}]{\setlength{\rightskip}{0pt plus 5cm}const\+\_\+iterator prism\+::cbegin (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_acd7a4333c9a67559cfd90bb6d1c85420}{}\label{namespaceprism_acd7a4333c9a67559cfd90bb6d1c85420}
\begin{DoxyReturn}{Returns}
Returns a const\+\_\+iterator that points to the first element in the Deque. 
\end{DoxyReturn}
\index{prism@{prism}!cend@{cend}}
\index{cend@{cend}!prism@{prism}}
\subsubsection[{\texorpdfstring{cend() const }{cend() const }}]{\setlength{\rightskip}{0pt plus 5cm}const\+\_\+iterator prism\+::cend (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_a0247b88b3e29f34b1cb742d724a6a330}{}\label{namespaceprism_a0247b88b3e29f34b1cb742d724a6a330}
\begin{DoxyReturn}{Returns}
Returns a const\+\_\+iterator that points to one position past the last element in the Deque. 
\end{DoxyReturn}
\index{prism@{prism}!clear@{clear}}
\index{clear@{clear}!prism@{prism}}
\subsubsection[{\texorpdfstring{clear()}{clear()}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::clear (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad22144cb445517f69b2e6f76586cf75d}{}\label{namespaceprism_ad22144cb445517f69b2e6f76586cf75d}
Clears all elements from the Deque so that its size is 0. ~\newline
Note that this does not affect the capacity. \index{prism@{prism}!const\+Begin@{const\+Begin}}
\index{const\+Begin@{const\+Begin}!prism@{prism}}
\subsubsection[{\texorpdfstring{const\+Begin() const }{constBegin() const }}]{\setlength{\rightskip}{0pt plus 5cm}const\+\_\+iterator prism\+::const\+Begin (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_a8f07ef2e7db05a23c631dee99ad4eba3}{}\label{namespaceprism_a8f07ef2e7db05a23c631dee99ad4eba3}
\begin{DoxyReturn}{Returns}
Returns a const\+\_\+iterator that points to the first element in the Deque. 
\end{DoxyReturn}
\index{prism@{prism}!const\+End@{const\+End}}
\index{const\+End@{const\+End}!prism@{prism}}
\subsubsection[{\texorpdfstring{const\+End() const }{constEnd() const }}]{\setlength{\rightskip}{0pt plus 5cm}const\+\_\+iterator prism\+::const\+End (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_a61b5e8524d7d3106a0b01cd002af8f75}{}\label{namespaceprism_a61b5e8524d7d3106a0b01cd002af8f75}
\begin{DoxyReturn}{Returns}
Returns a const\+\_\+iterator that points to one position past the last element in the Deque. 
\end{DoxyReturn}
\index{prism@{prism}!construct@{construct}}
\index{construct@{construct}!prism@{prism}}
\subsubsection[{\texorpdfstring{construct(\+T $\ast$p, Args \&\&...\+args)}{construct(T *p, Args &&...args)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , typename... Args$>$ void prism\+::construct (
\begin{DoxyParamCaption}
\item[{T $\ast$}]{p, }
\item[{Args \&\&...}]{args}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af62c0c26668facbe5607e8915442010e}{}\label{namespaceprism_af62c0c26668facbe5607e8915442010e}
\index{prism@{prism}!contains@{contains}}
\index{contains@{contains}!prism@{prism}}
\subsubsection[{\texorpdfstring{contains(const T \&value) const }{contains(const T &value) const }}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::contains (
\begin{DoxyParamCaption}
\item[{const T \&}]{value}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_aec550341cf4587d3a0afaa9492e77503}{}\label{namespaceprism_aec550341cf4587d3a0afaa9492e77503}
\begin{DoxyReturn}{Returns}
Returns true if the Deque contains {\itshape value}, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!copy@{copy}}
\index{copy@{copy}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First)}{copy(InputIterator first, InputIterator last, OutputIterator otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator $>$ Output\+Iterator prism\+::copy (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}{}\label{namespaceprism_ae776f4cd825f79e7af1cf6ee1d90a209}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} into the range beginning at {\itshape other\+First}. \index{prism@{prism}!copy\+\_\+aux@{copy\+\_\+aux}}
\index{copy\+\_\+aux@{copy\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy\+\_\+aux(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First)}{copy_aux(InputIterator first, InputIterator last, OutputIterator otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator $>$ Output\+Iterator prism\+::copy\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8fc5dc440a705fbe80912a49ea6d899b}{}\label{namespaceprism_a8fc5dc440a705fbe80912a49ea6d899b}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} into the range beginning at {\itshape other\+First}. \index{prism@{prism}!copy\+\_\+backward@{copy\+\_\+backward}}
\index{copy\+\_\+backward@{copy\+\_\+backward}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy\+\_\+backward(\+Bidirectional\+Iterator1 first, Bidirectional\+Iterator1 last, Bidirectional\+Iterator2 other\+Last)}{copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 otherLast)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Bidirectional\+Iterator1 , class Bidirectional\+Iterator2 $>$ Bidirectional\+Iterator2 prism\+::copy\+\_\+backward (
\begin{DoxyParamCaption}
\item[{Bidirectional\+Iterator1}]{first, }
\item[{Bidirectional\+Iterator1}]{last, }
\item[{Bidirectional\+Iterator2}]{other\+Last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2564c63b76369cc81ff725a56e818046}{}\label{namespaceprism_a2564c63b76369cc81ff725a56e818046}
Copies the elements in the range \mbox{[}first,last\mbox{]} starting from {\itshape last} to the range ending at {\itshape other\+Last}. The elements copied are between {\itshape first} and {\itshape last}, including {\itshape first} but not {\itshape last}. {\itshape other\+Last} should point to the past-\/the-\/end position of the destination range. \index{prism@{prism}!copy\+\_\+backward\+\_\+aux@{copy\+\_\+backward\+\_\+aux}}
\index{copy\+\_\+backward\+\_\+aux@{copy\+\_\+backward\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy\+\_\+backward\+\_\+aux(\+Bidirectional\+Iterator1 first, Bidirectional\+Iterator1 last, Bidirectional\+Iterator2 other\+Last)}{copy_backward_aux(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 otherLast)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Bidirectional\+Iterator1 , class Bidirectional\+Iterator2 $>$ Bidirectional\+Iterator2 prism\+::copy\+\_\+backward\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Bidirectional\+Iterator1}]{first, }
\item[{Bidirectional\+Iterator1}]{last, }
\item[{Bidirectional\+Iterator2}]{other\+Last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af94bcd5517145cc7b62c59a84a776814}{}\label{namespaceprism_af94bcd5517145cc7b62c59a84a776814}
Copies the elements in the range \mbox{[}first,last\mbox{]} starting from {\itshape last} to the range ending at {\itshape other\+Last}. The elements copied are between {\itshape first} and {\itshape last}, including {\itshape first} but not {\itshape last}. {\itshape other\+Last} should point to the past-\/the-\/end position of the destination range. \index{prism@{prism}!copy\+\_\+if@{copy\+\_\+if}}
\index{copy\+\_\+if@{copy\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Predicate pred)}{copy_if(InputIterator first, InputIterator last, OutputIterator otherFirst, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class Predicate $>$ Output\+Iterator prism\+::copy\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_afbed55ae6769c2d88c125aedc2f3846e}{}\label{namespaceprism_afbed55ae6769c2d88c125aedc2f3846e}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} for which {\itshape pred} returns true to the range beginning at {\itshape other\+First}. \index{prism@{prism}!copy\+\_\+if\+\_\+aux@{copy\+\_\+if\+\_\+aux}}
\index{copy\+\_\+if\+\_\+aux@{copy\+\_\+if\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy\+\_\+if\+\_\+aux(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Predicate pred)}{copy_if_aux(InputIterator first, InputIterator last, OutputIterator otherFirst, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class Predicate $>$ Output\+Iterator prism\+::copy\+\_\+if\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a06d95b48370d6b89936a81e08f7ed8d7}{}\label{namespaceprism_a06d95b48370d6b89936a81e08f7ed8d7}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} for which {\itshape pred} returns true to the range beginning at {\itshape other\+First}. \index{prism@{prism}!copy\+\_\+n@{copy\+\_\+n}}
\index{copy\+\_\+n@{copy\+\_\+n}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy\+\_\+n(\+Input\+Iterator first, Size n, Output\+Iterator other\+First)}{copy_n(InputIterator first, Size n, OutputIterator otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Size , class Output\+Iterator $>$ Output\+Iterator prism\+::copy\+\_\+n (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{{\bf Size}}]{n, }
\item[{Output\+Iterator}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af907f3f5637d4ec056e9b833b6272953}{}\label{namespaceprism_af907f3f5637d4ec056e9b833b6272953}
Copies the first {\itshape n} elements from the range beginning at {\itshape first} into the range beginning at {\itshape other\+First}. \index{prism@{prism}!copy\+\_\+n\+\_\+aux@{copy\+\_\+n\+\_\+aux}}
\index{copy\+\_\+n\+\_\+aux@{copy\+\_\+n\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{copy\+\_\+n\+\_\+aux(\+Input\+Iterator first, Size n, Output\+Iterator other\+First)}{copy_n_aux(InputIterator first, Size n, OutputIterator otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Size , class Output\+Iterator $>$ Output\+Iterator prism\+::copy\+\_\+n\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{{\bf Size}}]{n, }
\item[{Output\+Iterator}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a305d5bebe30595a5d4705a6cef37b52a}{}\label{namespaceprism_a305d5bebe30595a5d4705a6cef37b52a}
Copies the first {\itshape n} elements from the range beginning at {\itshape first} into the range beginning at {\itshape other\+First}. \index{prism@{prism}!count@{count}}
\index{count@{count}!prism@{prism}}
\subsubsection[{\texorpdfstring{count(\+Input\+Iterator first, Input\+Iterator last, const T \&value)}{count(InputIterator first, InputIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class T $>$ int prism\+::count (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a024117fc3639cdf6598509edf22f034a}{}\label{namespaceprism_a024117fc3639cdf6598509edf22f034a}
Returns the number of elements in the range {\itshape }\mbox{[}first,last\mbox{]} that compare equal to {\itshape value}. \index{prism@{prism}!count@{count}}
\index{count@{count}!prism@{prism}}
\subsubsection[{\texorpdfstring{count(const T \&value) const }{count(const T &value) const }}]{\setlength{\rightskip}{0pt plus 5cm}const int prism\+::count (
\begin{DoxyParamCaption}
\item[{const T \&}]{value}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_a02873ae9088199948854cc05b20831c5}{}\label{namespaceprism_a02873ae9088199948854cc05b20831c5}
\index{prism@{prism}!count\+\_\+aux@{count\+\_\+aux}}
\index{count\+\_\+aux@{count\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{count\+\_\+aux(\+Input\+Iterator first, Input\+Iterator last, const T \&value)}{count_aux(InputIterator first, InputIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class T $>$ int prism\+::count\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a161f644c4e266d280a770bb0c9fbe045}{}\label{namespaceprism_a161f644c4e266d280a770bb0c9fbe045}
Returns the number of elements in the range {\itshape }\mbox{[}first,last\mbox{]} that compare equal to {\itshape value}. \index{prism@{prism}!count\+\_\+if@{count\+\_\+if}}
\index{count\+\_\+if@{count\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{count\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{count_if(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ int prism\+::count\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af0007d361beae18a930b6249752e509e}{}\label{namespaceprism_af0007d361beae18a930b6249752e509e}
Returns the number of elements in the range {\itshape }\mbox{[}first,last\mbox{]} for which {\itshape pred} is true. \index{prism@{prism}!count\+\_\+if\+\_\+aux@{count\+\_\+if\+\_\+aux}}
\index{count\+\_\+if\+\_\+aux@{count\+\_\+if\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{count\+\_\+if\+\_\+aux(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{count_if_aux(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ int prism\+::count\+\_\+if\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8d72a3b00c7e3e537c82829965732dad}{}\label{namespaceprism_a8d72a3b00c7e3e537c82829965732dad}
Returns the number of elements in the range {\itshape }\mbox{[}first,last\mbox{]} for which {\itshape pred} is true. \index{prism@{prism}!delete\+\_\+range@{delete\+\_\+range}}
\index{delete\+\_\+range@{delete\+\_\+range}!prism@{prism}}
\subsubsection[{\texorpdfstring{delete\+\_\+range(\+Forward\+Iterator first, Forward\+Iterator last)}{delete_range(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ void prism\+::delete\+\_\+range (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a83e62e5b148c55f949e5ea843d53ad67}{}\label{namespaceprism_a83e62e5b148c55f949e5ea843d53ad67}
Deletes the elements in the range {\itshape }\mbox{[}first, last\mbox{]} by using the c++ delete operator. The element that the iterator points to therefore must be a pointer. \index{prism@{prism}!delete\+\_\+range\+\_\+aux@{delete\+\_\+range\+\_\+aux}}
\index{delete\+\_\+range\+\_\+aux@{delete\+\_\+range\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{delete\+\_\+range\+\_\+aux(\+Forward\+Iterator first, Forward\+Iterator last)}{delete_range_aux(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ void prism\+::delete\+\_\+range\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a25e9f7e103a3f2ae15048eb75dc6af97}{}\label{namespaceprism_a25e9f7e103a3f2ae15048eb75dc6af97}
Deletes the elements in the range {\itshape }\mbox{[}first, last\mbox{]} by using the c++ delete operator. The element that the iterator points to therefore must be a pointer. \index{prism@{prism}!Deque@{Deque}}
\index{Deque@{Deque}!prism@{prism}}
\subsubsection[{\texorpdfstring{Deque()}{Deque()}}]{\setlength{\rightskip}{0pt plus 5cm}prism\+::\+Deque (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}{}\label{namespaceprism_a8e77ed12f9b3a35d81935362d3050d0c}
================================================================================ \subsection*{Deque\+Data }

/$\ast$$\ast$ 

 \subsection*{Deque }

template $<$class T, class Alloc = prism\+::\+Allocator$<$\+T$>$$>$ class Deque \{ public\+: typedef Alloc T\+\_\+\+Alloc; typedef Deque\+Data$<$\+T, T\+\_\+\+Alloc$>$ Data; typedef typename Data\+::iterator iterator; typedef typename Data\+::const\+\_\+iterator const\+\_\+iterator; typedef typename T\+\_\+\+Alloc\+::value\+\_\+type value\+\_\+type; typedef typename T\+\_\+\+Alloc\+::difference\+\_\+type difference\+\_\+type; typedef typename T\+\_\+\+Alloc\+::pointer pointer; typedef typename T\+\_\+\+Alloc\+::reference reference; typedef typename T\+\_\+\+Alloc\+::const\+\_\+pointer const\+\_\+pointer; typedef typename T\+\_\+\+Alloc\+::const\+\_\+reference const\+\_\+reference; typedef typename iterator\+::iterator\+\_\+category iterator\+\_\+category; private\+: Shared\+Data\+Pointer$<$\+Data$>$ d; public\+: /$\ast$$\ast$ Creates an empty Deque. \index{prism@{prism}!Deque@{Deque}}
\index{Deque@{Deque}!prism@{prism}}
\subsubsection[{\texorpdfstring{Deque(const int size, const T \&value=\+T())}{Deque(const int size, const T &value=T())}}]{\setlength{\rightskip}{0pt plus 5cm}prism\+::\+Deque (
\begin{DoxyParamCaption}
\item[{const int}]{size, }
\item[{const T \&}]{value = {\ttfamily T()}}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a73ec48544ee84c6327a63ac5c4c5cb60}{}\label{namespaceprism_a73ec48544ee84c6327a63ac5c4c5cb60}
Creates a Deque that contains {\itshape size} amount of elements initialized to {\itshape value}. \index{prism@{prism}!Deque@{Deque}}
\index{Deque@{Deque}!prism@{prism}}
\subsubsection[{\texorpdfstring{Deque(\+Forward\+Iterator first, Forward\+Iterator last)}{Deque(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ prism\+::\+Deque (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa7bbb75108907fb0573f35d3b82ddf3a}{}\label{namespaceprism_aa7bbb75108907fb0573f35d3b82ddf3a}
\index{prism@{prism}!Deque@{Deque}}
\index{Deque@{Deque}!prism@{prism}}
\subsubsection[{\texorpdfstring{Deque(std\+::initializer\+\_\+list$<$ T $>$ list)}{Deque(std::initializer_list< T > list)}}]{\setlength{\rightskip}{0pt plus 5cm}prism\+::\+Deque (
\begin{DoxyParamCaption}
\item[{std\+::initializer\+\_\+list$<$ T $>$}]{list}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6d8b2ede230218b04aa9b6f48c94f77d}{}\label{namespaceprism_a6d8b2ede230218b04aa9b6f48c94f77d}
Creates a Deque and assigns the elements in the initializer list to the Deque. \index{prism@{prism}!Deque@{Deque}}
\index{Deque@{Deque}!prism@{prism}}
\subsubsection[{\texorpdfstring{Deque(const Deque$<$ T, T\+\_\+\+Alloc $>$ \&copy)}{Deque(const Deque< T, T_Alloc > &copy)}}]{\setlength{\rightskip}{0pt plus 5cm}prism\+::\+Deque (
\begin{DoxyParamCaption}
\item[{const Deque$<$ T, T\+\_\+\+Alloc $>$ \&}]{copy}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af8a6c6b9242eb9a0c22af9e28ee4ae80}{}\label{namespaceprism_af8a6c6b9242eb9a0c22af9e28ee4ae80}
Creates a new Deque which is a copy of {\itshape copy}. \index{prism@{prism}!destroy@{destroy}}
\index{destroy@{destroy}!prism@{prism}}
\subsubsection[{\texorpdfstring{destroy(\+T $\ast$p)}{destroy(T *p)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ void prism\+::destroy (
\begin{DoxyParamCaption}
\item[{T $\ast$}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af889ac2726920ab1b4f5361e6563d041}{}\label{namespaceprism_af889ac2726920ab1b4f5361e6563d041}
\index{prism@{prism}!empty@{empty}}
\index{empty@{empty}!prism@{prism}}
\subsubsection[{\texorpdfstring{empty() const }{empty() const }}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::empty (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_a7441180af2d914cc54ac35aead6ed030}{}\label{namespaceprism_a7441180af2d914cc54ac35aead6ed030}
\begin{DoxyReturn}{Returns}
Returns true if the Deque is empty i.\+e. size == 0, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!end@{end}}
\index{end@{end}!prism@{prism}}
\subsubsection[{\texorpdfstring{end()}{end()}}]{\setlength{\rightskip}{0pt plus 5cm}const\+\_\+iterator prism\+::end (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8976ba2aea6612a03f75a390f40daef8}{}\label{namespaceprism_a8976ba2aea6612a03f75a390f40daef8}
\begin{DoxyReturn}{Returns}
Returns an iterator that points to one position past the last element in the Deque.

Returns a const\+\_\+iterator that points to one position past the last element in the Deque. 
\end{DoxyReturn}
\index{prism@{prism}!ends\+With@{ends\+With}}
\index{ends\+With@{ends\+With}!prism@{prism}}
\subsubsection[{\texorpdfstring{ends\+With(const T \&value) const }{endsWith(const T &value) const }}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::ends\+With (
\begin{DoxyParamCaption}
\item[{const T \&}]{value}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_abfc42fa48a8be97e541b137e9ae83c18}{}\label{namespaceprism_abfc42fa48a8be97e541b137e9ae83c18}
\index{prism@{prism}!equal@{equal}}
\index{equal@{equal}!prism@{prism}}
\subsubsection[{\texorpdfstring{equal(\+Input\+Iterator1 first, Input\+Iterator1 last, Input\+Iterator2 other\+First)}{equal(InputIterator1 first, InputIterator1 last, InputIterator2 otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator1 , class Input\+Iterator2 $>$ bool prism\+::equal (
\begin{DoxyParamCaption}
\item[{Input\+Iterator1}]{first, }
\item[{Input\+Iterator1}]{last, }
\item[{Input\+Iterator2}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad3bede9a0f2c648e93677b14c45b1b7b}{}\label{namespaceprism_ad3bede9a0f2c648e93677b14c45b1b7b}
Compares the elements in the range {\itshape }\mbox{[}first1,last1\mbox{]} with those in the range beginning at {\itshape other\+First}, and returns true if all of the elements in both ranges match. ~\newline
\begin{DoxyNote}{Note}
The elements being compared must support \hyperlink{namespaceprism_a47eb78b48fe05bc2087a1c5e70f4c373}{operator==()}. 
\end{DoxyNote}
\index{prism@{prism}!equal\+\_\+aux@{equal\+\_\+aux}}
\index{equal\+\_\+aux@{equal\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{equal\+\_\+aux(\+Input\+Iterator1 first, Input\+Iterator1 last, Input\+Iterator2 other\+First)}{equal_aux(InputIterator1 first, InputIterator1 last, InputIterator2 otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator1 , class Input\+Iterator2 $>$ bool prism\+::equal\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator1}]{first, }
\item[{Input\+Iterator1}]{last, }
\item[{Input\+Iterator2}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ac6dc9c68afaa8d8490148baf121bfc1c}{}\label{namespaceprism_ac6dc9c68afaa8d8490148baf121bfc1c}
Compares the elements in the range {\itshape }\mbox{[}first1,last1\mbox{]} with those in the range beginning at {\itshape other\+First}, and returns true if all of the elements in both ranges match. ~\newline
\begin{DoxyNote}{Note}
The elements being compared must support \hyperlink{namespaceprism_a47eb78b48fe05bc2087a1c5e70f4c373}{operator==()}. 
\end{DoxyNote}
\index{prism@{prism}!erase@{erase}}
\index{erase@{erase}!prism@{prism}}
\subsubsection[{\texorpdfstring{erase(iterator pos)}{erase(iterator pos)}}]{\setlength{\rightskip}{0pt plus 5cm}iterator prism\+::erase (
\begin{DoxyParamCaption}
\item[{iterator}]{pos}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a46f69cc5e78e0a7bcd2d9a7ed9c05a8b}{}\label{namespaceprism_a46f69cc5e78e0a7bcd2d9a7ed9c05a8b}
\index{prism@{prism}!erase@{erase}}
\index{erase@{erase}!prism@{prism}}
\subsubsection[{\texorpdfstring{erase(iterator first, iterator last)}{erase(iterator first, iterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}iterator prism\+::erase (
\begin{DoxyParamCaption}
\item[{iterator}]{first, }
\item[{iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab853ba84b4ed547730d02a8c21328e65}{}\label{namespaceprism_ab853ba84b4ed547730d02a8c21328e65}
\begin{DoxyReturn}{Returns}
Returns an iterator to the new position of the element that follows the last element erased. 
\begin{DoxyCode}
Deque<int> d(\{1,2,3,4,5,6\});
iterator it = d.erase(d.begin()+2, d.begin()+5);
\textcolor{comment}{// *it == 6 since the integers 3, 4 and 5 were erased}
\end{DoxyCode}
 
\end{DoxyReturn}
\index{prism@{prism}!fill@{fill}}
\index{fill@{fill}!prism@{prism}}
\subsubsection[{\texorpdfstring{fill(\+Forward\+Iterator first, Forward\+Iterator last, const T \&value)}{fill(ForwardIterator first, ForwardIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::fill (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{}\label{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}
Assigns {\itshape value} to all the elements in the range {\itshape }\mbox{[}first,last\mbox{]}. \index{prism@{prism}!fill@{fill}}
\index{fill@{fill}!prism@{prism}}
\subsubsection[{\texorpdfstring{fill(const T \&value)}{fill(const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::fill (
\begin{DoxyParamCaption}
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab76b40745e46fbda01eb55d8258ff498}{}\label{namespaceprism_ab76b40745e46fbda01eb55d8258ff498}
Sets each element in the Deque to {\itshape value}. \index{prism@{prism}!fill\+\_\+aux@{fill\+\_\+aux}}
\index{fill\+\_\+aux@{fill\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{fill\+\_\+aux(\+Forward\+Iterator first, Forward\+Iterator last, const T \&value)}{fill_aux(ForwardIterator first, ForwardIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::fill\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a76092b4faa3c2a98088678943ad23df4}{}\label{namespaceprism_a76092b4faa3c2a98088678943ad23df4}
Assigns {\itshape value} to all the elements in the range {\itshape }\mbox{[}first,last\mbox{]}. \index{prism@{prism}!fill\+\_\+n@{fill\+\_\+n}}
\index{fill\+\_\+n@{fill\+\_\+n}!prism@{prism}}
\subsubsection[{\texorpdfstring{fill\+\_\+n(\+Forward\+Iterator first, int size, const T \&value)}{fill_n(ForwardIterator first, int size, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::fill\+\_\+n (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{int}]{size, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aceb4b9c511a5edb706296b457427b226}{}\label{namespaceprism_aceb4b9c511a5edb706296b457427b226}
Assigns {\itshape value} to the first {\itshape n} elements of the sequence pointed by {\itshape first}. \index{prism@{prism}!fill\+\_\+n\+\_\+aux@{fill\+\_\+n\+\_\+aux}}
\index{fill\+\_\+n\+\_\+aux@{fill\+\_\+n\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{fill\+\_\+n\+\_\+aux(\+Forward\+Iterator first, int size, const T \&value)}{fill_n_aux(ForwardIterator first, int size, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::fill\+\_\+n\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{int}]{size, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad2e7f5f7dee0072f4741520356ebdaee}{}\label{namespaceprism_ad2e7f5f7dee0072f4741520356ebdaee}
Assigns {\itshape value} to the first {\itshape n} elements of the sequence pointed by {\itshape first}. \index{prism@{prism}!find@{find}}
\index{find@{find}!prism@{prism}}
\subsubsection[{\texorpdfstring{find(\+Input\+Iterator first, Input\+Iterator last, const T \&value)}{find(InputIterator first, InputIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class T $>$ Input\+Iterator prism\+::find (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1b543d9c2862a539cc8b770abda87561}{}\label{namespaceprism_a1b543d9c2862a539cc8b770abda87561}
Returns an iterator to the first element in the range {\itshape }\mbox{[}first,last\mbox{]} that compares equal to {\itshape value}. If no such element is found, the function returns {\itshape last}. \index{prism@{prism}!find\+\_\+aux@{find\+\_\+aux}}
\index{find\+\_\+aux@{find\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{find\+\_\+aux(\+Input\+Iterator first, Input\+Iterator last, const T \&value)}{find_aux(InputIterator first, InputIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class T $>$ Input\+Iterator prism\+::find\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af23b68308b7ec11222bd2bfb2904c595}{}\label{namespaceprism_af23b68308b7ec11222bd2bfb2904c595}
Returns an iterator to the first element in the range {\itshape }\mbox{[}first,last\mbox{]} that compares equal to {\itshape value}. If no such element is found, the function returns {\itshape last}. \index{prism@{prism}!find\+\_\+if@{find\+\_\+if}}
\index{find\+\_\+if@{find\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{find\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{find_if(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ Input\+Iterator prism\+::find\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa17e9e6c80f8a52479a52450a108a636}{}\label{namespaceprism_aa17e9e6c80f8a52479a52450a108a636}
Returns an iterator to the first element in the range {\itshape }\mbox{[}first,last\mbox{]} for which {\itshape pred} returns true. If no such element is found, the function returns {\itshape last}. \index{prism@{prism}!find\+\_\+if\+\_\+aux@{find\+\_\+if\+\_\+aux}}
\index{find\+\_\+if\+\_\+aux@{find\+\_\+if\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{find\+\_\+if\+\_\+aux(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{find_if_aux(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ Input\+Iterator prism\+::find\+\_\+if\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a91c456a075b03cfe290044281af93203}{}\label{namespaceprism_a91c456a075b03cfe290044281af93203}
Returns an iterator to the first element in the range {\itshape }\mbox{[}first,last\mbox{]} for which {\itshape pred} returns true. If no such element is found, the function returns {\itshape last}. \index{prism@{prism}!find\+\_\+last@{find\+\_\+last}}
\index{find\+\_\+last@{find\+\_\+last}!prism@{prism}}
\subsubsection[{\texorpdfstring{find\+\_\+last(\+Input\+Iterator first, Input\+Iterator last, const T \&value)}{find_last(InputIterator first, InputIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class T $>$ Input\+Iterator prism\+::find\+\_\+last (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a3189014b9fa31e0ef0d1933c6f616618}{}\label{namespaceprism_a3189014b9fa31e0ef0d1933c6f616618}
Returns an iterator to the last element in the range {\itshape }\mbox{[}first,last\mbox{]} that compares equal to {\itshape value}. The range searched is {\itshape }\mbox{[}first,last), which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. If no match is found then a null pointer is returned instead i.\+e. p=0; \index{prism@{prism}!find\+\_\+last\+\_\+aux@{find\+\_\+last\+\_\+aux}}
\index{find\+\_\+last\+\_\+aux@{find\+\_\+last\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{find\+\_\+last\+\_\+aux(\+Input\+Iterator first, Input\+Iterator last, const T \&value)}{find_last_aux(InputIterator first, InputIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class T $>$ Input\+Iterator prism\+::find\+\_\+last\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a66df70426cdeee37f0c06a90881f1f36}{}\label{namespaceprism_a66df70426cdeee37f0c06a90881f1f36}
Returns an iterator to the last element in the range {\itshape }\mbox{[}first,last\mbox{]} that compares equal to {\itshape value}. The range searched is {\itshape }\mbox{[}first,last), which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. If no match is found then a null pointer is returned instead i.\+e. p=0; \index{prism@{prism}!first@{first}}
\index{first@{first}!prism@{prism}}
\subsubsection[{\texorpdfstring{first()}{first()}}]{\setlength{\rightskip}{0pt plus 5cm}const\+\_\+reference prism\+::first (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}{}\label{namespaceprism_ae3fb7a1926a9e8e59300cd5e370470da}
\begin{DoxyReturn}{Returns}
Returns a reference to the first element in the Deque.

Returns a const reference to the first element in the Deque. 
\end{DoxyReturn}
\index{prism@{prism}!for\+\_\+each@{for\+\_\+each}}
\index{for\+\_\+each@{for\+\_\+each}!prism@{prism}}
\subsubsection[{\texorpdfstring{for\+\_\+each(\+Input\+Iterator first, Input\+Iterator last, Function func)}{for_each(InputIterator first, InputIterator last, Function func)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Function $>$ Function prism\+::for\+\_\+each (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Function}]{func}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aae062d5bfdc0e53ae49c56520aded906}{}\label{namespaceprism_aae062d5bfdc0e53ae49c56520aded906}
Applies function {\itshape func} to each of the elements in the range {\itshape }\mbox{[}first,last\mbox{]}. \index{prism@{prism}!for\+\_\+each\+\_\+aux@{for\+\_\+each\+\_\+aux}}
\index{for\+\_\+each\+\_\+aux@{for\+\_\+each\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{for\+\_\+each\+\_\+aux(\+Input\+Iterator first, Input\+Iterator last, Function func)}{for_each_aux(InputIterator first, InputIterator last, Function func)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Function $>$ Function prism\+::for\+\_\+each\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Function}]{func}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9adcafd2357df71bd906d85ffe9fdf85}{}\label{namespaceprism_a9adcafd2357df71bd906d85ffe9fdf85}
Applies function {\itshape func} to each of the elements in the range {\itshape }\mbox{[}first,last\mbox{]}. \index{prism@{prism}!front@{front}}
\index{front@{front}!prism@{prism}}
\subsubsection[{\texorpdfstring{front()}{front()}}]{\setlength{\rightskip}{0pt plus 5cm}const\+\_\+reference prism\+::front (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a0c27e6535264895614b87eefa337404d}{}\label{namespaceprism_a0c27e6535264895614b87eefa337404d}
\begin{DoxyReturn}{Returns}
Returns a reference to the first element in the Deque.

Returns a const reference to the first element in the Deque. 
\end{DoxyReturn}
\index{prism@{prism}!index\+Of@{index\+Of}}
\index{index\+Of@{index\+Of}!prism@{prism}}
\subsubsection[{\texorpdfstring{index\+Of(const T \&value, const int from=0) const }{indexOf(const T &value, const int from=0) const }}]{\setlength{\rightskip}{0pt plus 5cm}const int prism\+::index\+Of (
\begin{DoxyParamCaption}
\item[{const T \&}]{value, }
\item[{const int}]{from = {\ttfamily 0}}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_a78b6d3259343e632ab4e9d806498ac92}{}\label{namespaceprism_a78b6d3259343e632ab4e9d806498ac92}
Searches for the first index starting from index {\itshape from} that contains {\itshape value}. \begin{DoxyReturn}{Returns}
Returns the index of of the first occurrence of {\itshape value} or -\/1 if {\itshape value} does not occur in the Deque. 
\end{DoxyReturn}
\index{prism@{prism}!insert@{insert}}
\index{insert@{insert}!prism@{prism}}
\subsubsection[{\texorpdfstring{insert(const int index, const T \&value)}{insert(const int index, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::insert (
\begin{DoxyParamCaption}
\item[{const int}]{index, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af52510a241330236aa7202abf65c6dcb}{}\label{namespaceprism_af52510a241330236aa7202abf65c6dcb}
\index{prism@{prism}!insert@{insert}}
\index{insert@{insert}!prism@{prism}}
\subsubsection[{\texorpdfstring{insert(const int index, const int count, const T \&value)}{insert(const int index, const int count, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::insert (
\begin{DoxyParamCaption}
\item[{const int}]{index, }
\item[{const int}]{count, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_abd912a072952b08ebd1009abbede3ee5}{}\label{namespaceprism_abd912a072952b08ebd1009abbede3ee5}
\index{prism@{prism}!insert@{insert}}
\index{insert@{insert}!prism@{prism}}
\subsubsection[{\texorpdfstring{insert(iterator insert\+Before, const T \&value)}{insert(iterator insertBefore, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}iterator prism\+::insert (
\begin{DoxyParamCaption}
\item[{iterator}]{insert\+Before, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a391f88be142a74df98c77632bb8352af}{}\label{namespaceprism_a391f88be142a74df98c77632bb8352af}
\index{prism@{prism}!insert@{insert}}
\index{insert@{insert}!prism@{prism}}
\subsubsection[{\texorpdfstring{insert(iterator insert\+Before, const int count, const T \&value)}{insert(iterator insertBefore, const int count, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}iterator prism\+::insert (
\begin{DoxyParamCaption}
\item[{iterator}]{insert\+Before, }
\item[{const int}]{count, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a414531a413ed8c90d951f6fd94ac5535}{}\label{namespaceprism_a414531a413ed8c90d951f6fd94ac5535}
\index{prism@{prism}!is\+\_\+sorted@{is\+\_\+sorted}}
\index{is\+\_\+sorted@{is\+\_\+sorted}!prism@{prism}}
\subsubsection[{\texorpdfstring{is\+\_\+sorted(\+Forward\+Iterator first, Forward\+Iterator last)}{is_sorted(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ const bool prism\+::is\+\_\+sorted (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_acf5efbeb096446c47690b9e8bd2cc01a}{}\label{namespaceprism_acf5efbeb096446c47690b9e8bd2cc01a}
Returns true if the elements in the range {\itshape }\mbox{[}first,last\mbox{]} are sorted in ascending order, false otherwise. The range searched is {\itshape }\mbox{[}first,last), which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. \index{prism@{prism}!is\+\_\+sorted\+\_\+aux@{is\+\_\+sorted\+\_\+aux}}
\index{is\+\_\+sorted\+\_\+aux@{is\+\_\+sorted\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{is\+\_\+sorted\+\_\+aux(\+Forward\+Iterator first, Forward\+Iterator last)}{is_sorted_aux(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ const bool prism\+::is\+\_\+sorted\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a29c1478cf9a6f78fa511d96f93b22791}{}\label{namespaceprism_a29c1478cf9a6f78fa511d96f93b22791}
Returns true if the elements in the range {\itshape }\mbox{[}first,last\mbox{]} are sorted in ascending order, false otherwise. The range searched is {\itshape }\mbox{[}first,last), which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. \index{prism@{prism}!is\+Empty@{is\+Empty}}
\index{is\+Empty@{is\+Empty}!prism@{prism}}
\subsubsection[{\texorpdfstring{is\+Empty() const }{isEmpty() const }}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::is\+Empty (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_a538f7dd7bdd8d7963b39a9aea232a598}{}\label{namespaceprism_a538f7dd7bdd8d7963b39a9aea232a598}
\begin{DoxyReturn}{Returns}
Returns true if the Deque is empty i.\+e. size == 0, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!last@{last}}
\index{last@{last}!prism@{prism}}
\subsubsection[{\texorpdfstring{last()}{last()}}]{\setlength{\rightskip}{0pt plus 5cm}const\+\_\+reference prism\+::last (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}{}\label{namespaceprism_abe4956c4e865f55ca126b7fb973b5078}
\begin{DoxyReturn}{Returns}
Returns a reference to the last element in the Deque.

Returns a const reference to the last element in the Deque. 
\end{DoxyReturn}
\index{prism@{prism}!last\+Index\+Of@{last\+Index\+Of}}
\index{last\+Index\+Of@{last\+Index\+Of}!prism@{prism}}
\subsubsection[{\texorpdfstring{last\+Index\+Of(const T \&value, int from=-\/1) const }{lastIndexOf(const T &value, int from=-1) const }}]{\setlength{\rightskip}{0pt plus 5cm}const int prism\+::last\+Index\+Of (
\begin{DoxyParamCaption}
\item[{const T \&}]{value, }
\item[{int}]{from = {\ttfamily -\/1}}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_af0ed081bf6c17e965bfac0d207cd6c28}{}\label{namespaceprism_af0ed081bf6c17e965bfac0d207cd6c28}
\index{prism@{prism}!make\+\_\+heap@{make\+\_\+heap}}
\index{make\+\_\+heap@{make\+\_\+heap}!prism@{prism}}
\subsubsection[{\texorpdfstring{make\+\_\+heap(\+Random\+Access\+Iterator first, Random\+Access\+Iterator last)}{make_heap(RandomAccessIterator first, RandomAccessIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Random\+Access\+Iterator $>$ void prism\+::make\+\_\+heap (
\begin{DoxyParamCaption}
\item[{Random\+Access\+Iterator}]{first, }
\item[{Random\+Access\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af8e36230e6cb92a41aaca282772a9e6e}{}\label{namespaceprism_af8e36230e6cb92a41aaca282772a9e6e}
Rearranges the elements in the range {\itshape }\mbox{[}first,last\mbox{]} so that they satisfy the order conditions of a heap.~\newline
The range searched is {\itshape }\mbox{[}first,last), which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. \index{prism@{prism}!make\+\_\+heap\+\_\+aux@{make\+\_\+heap\+\_\+aux}}
\index{make\+\_\+heap\+\_\+aux@{make\+\_\+heap\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{make\+\_\+heap\+\_\+aux(\+Random\+Access\+Iterator first, Random\+Access\+Iterator last)}{make_heap_aux(RandomAccessIterator first, RandomAccessIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Random\+Access\+Iterator $>$ void prism\+::make\+\_\+heap\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Random\+Access\+Iterator}]{first, }
\item[{Random\+Access\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a567b63d0d3fa2bc8bdba883f152848be}{}\label{namespaceprism_a567b63d0d3fa2bc8bdba883f152848be}
Rearranges the elements in the range {\itshape }\mbox{[}first,last\mbox{]} so that they satisfy the order conditions of a heap.~\newline
The range searched is {\itshape }\mbox{[}first,last), which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. \index{prism@{prism}!max@{max}}
\index{max@{max}!prism@{prism}}
\subsubsection[{\texorpdfstring{max(const T \&a, const T \&b)}{max(const T &a, const T &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ const T\& prism\+::max (
\begin{DoxyParamCaption}
\item[{const T \&}]{a, }
\item[{const T \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a812456273adfa37979e79f07e731d412}{}\label{namespaceprism_a812456273adfa37979e79f07e731d412}
Returns the largest of {\itshape a} and {\itshape b}. If they are equivalent then {\itshape a} is returned. \index{prism@{prism}!max\+\_\+aux@{max\+\_\+aux}}
\index{max\+\_\+aux@{max\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{max\+\_\+aux(const T \&a, const T \&b)}{max_aux(const T &a, const T &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ const T\& prism\+::max\+\_\+aux (
\begin{DoxyParamCaption}
\item[{const T \&}]{a, }
\item[{const T \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9d5ae6f65d12dcb2e433ffdc95b733bb}{}\label{namespaceprism_a9d5ae6f65d12dcb2e433ffdc95b733bb}
Returns the largest of {\itshape a} and {\itshape b}. If they are equivalent then {\itshape a} is returned. \index{prism@{prism}!mid@{mid}}
\index{mid@{mid}!prism@{prism}}
\subsubsection[{\texorpdfstring{mid(const int start\+Index, const int count) const }{mid(const int startIndex, const int count) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Deque}$<$T, T\+\_\+\+Alloc$>$ prism\+::mid (
\begin{DoxyParamCaption}
\item[{const int}]{start\+Index, }
\item[{const int}]{count}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_aeb39a03321ba086c660e96bfa11d33c4}{}\label{namespaceprism_aeb39a03321ba086c660e96bfa11d33c4}
\index{prism@{prism}!min@{min}}
\index{min@{min}!prism@{prism}}
\subsubsection[{\texorpdfstring{min(const T \&a, const T \&b)}{min(const T &a, const T &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ const T\& prism\+::min (
\begin{DoxyParamCaption}
\item[{const T \&}]{a, }
\item[{const T \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a10aff0aca673fb1837069dd8967e4738}{}\label{namespaceprism_a10aff0aca673fb1837069dd8967e4738}
Returns the smallest of {\itshape a} and {\itshape b}. If they are equivalent then {\itshape a} is returned. \index{prism@{prism}!min\+\_\+aux@{min\+\_\+aux}}
\index{min\+\_\+aux@{min\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{min\+\_\+aux(const T \&a, const T \&b)}{min_aux(const T &a, const T &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ const T\& prism\+::min\+\_\+aux (
\begin{DoxyParamCaption}
\item[{const T \&}]{a, }
\item[{const T \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5ded05d282e95b0ab21c6aeaca2e8794}{}\label{namespaceprism_a5ded05d282e95b0ab21c6aeaca2e8794}
Returns the smallest of {\itshape a} and {\itshape b}. If they are equivalent then {\itshape a} is returned. \index{prism@{prism}!none\+\_\+of@{none\+\_\+of}}
\index{none\+\_\+of@{none\+\_\+of}!prism@{prism}}
\subsubsection[{\texorpdfstring{none\+\_\+of(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{none_of(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ bool prism\+::none\+\_\+of (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a10c83b433c7f98fd4513f1b68c6db594}{}\label{namespaceprism_a10c83b433c7f98fd4513f1b68c6db594}
Returns true if {\itshape pred} returns false for all the elements in the range {\itshape }\mbox{[}first,last\mbox{]} or if the range is empty, and false otherwise. \index{prism@{prism}!none\+\_\+of\+\_\+aux@{none\+\_\+of\+\_\+aux}}
\index{none\+\_\+of\+\_\+aux@{none\+\_\+of\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{none\+\_\+of\+\_\+aux(\+Input\+Iterator first, Input\+Iterator last, Predicate pred)}{none_of_aux(InputIterator first, InputIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Predicate $>$ bool prism\+::none\+\_\+of\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4333d241a3ee0f8bce307db84c7eba23}{}\label{namespaceprism_a4333d241a3ee0f8bce307db84c7eba23}
Returns true if {\itshape pred} returns false for all the elements in the range {\itshape }\mbox{[}first,last\mbox{]} or if the range is empty, and false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Shared\+Pointer$<$ U $>$ \&p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator!=(const SharedPointer< U > &p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9df924e4deb059bf1200701c8235410a}{}\label{namespaceprism_a9df924e4deb059bf1200701c8235410a}
Returns true if the managed pointers of p1 and p2 do not point to the same data, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Shared\+Pointer$<$ U $>$ \&p1, const U $\ast$p2)}{operator!=(const SharedPointer< U > &p1, const U *p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const U $\ast$}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad6391c124e006b0e3a3ec67f55e208b0}{}\label{namespaceprism_ad6391c124e006b0e3a3ec67f55e208b0}
Returns true if the managed pointer of p1 and the raw pointer p2 do not point to the same data, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Char \&c1, const Char \&c2)}{operator!=(const Char &c1, const Char &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Char} \&}]{c1, }
\item[{const {\bf Char} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a249b6933154570d808cdd405ab1fd89b}{}\label{namespaceprism_a249b6933154570d808cdd405ab1fd89b}
\begin{DoxyReturn}{Returns}
Returns true if the chars {\itshape c1} and {\itshape c2} are not equal, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const U $\ast$p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator!=(const U *p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const U $\ast$}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab8792dbd5cac5678390843bacdb69daa}{}\label{namespaceprism_ab8792dbd5cac5678390843bacdb69daa}
Returns true if the raw pointer p1 and the managed pointer of p2 do not point to the same data, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Pointf \&p1, const Pointf \&p2)}{operator!=(const Pointf &p1, const Pointf &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p1, }
\item[{const {\bf Pointf} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae010d5880eb7bcf5119f006e26bf473f}{}\label{namespaceprism_ae010d5880eb7bcf5119f006e26bf473f}
Returns true if x or y of p1 and p2 are not equal, false if not \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Size \&s1, const Size \&s2)}{operator!=(const Size &s1, const Size &s2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{s1, }
\item[{const {\bf Size} \&}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a63ab3c18ecc73e21e7281dbe180e07e8}{}\label{namespaceprism_a63ab3c18ecc73e21e7281dbe180e07e8}
Returns true if the widths are equal and the heights are not equal of both \hyperlink{classprism_1_1_size}{Size} objects. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Fraction \&f1, const Fraction \&f2)}{operator!=(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aea72179b12983e614f72acd2b3cbf0e0}{}\label{namespaceprism_aea72179b12983e614f72acd2b3cbf0e0}
Returns true if /em f1 does not equal /em f2 in value, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Point \&p1, const Point \&p2)}{operator!=(const Point &p1, const Point &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p1, }
\item[{const {\bf Point} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a75cab41d882d24ca064927f2390ef3a6}{}\label{namespaceprism_a75cab41d882d24ca064927f2390ef3a6}
Returns true if x or y of p1 and p2 are not equal, false if not \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Vector2 \&a, const Vector2 \&b)}{operator!=(const Vector2 &a, const Vector2 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{a, }
\item[{const {\bf Vector2} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7e9d0b027a9e7d9e313affe5af91dabc}{}\label{namespaceprism_a7e9d0b027a9e7d9e313affe5af91dabc}
Compares the vectors and returns true if a and b are not equal, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Vector4 \&a, const Vector4 \&b)}{operator!=(const Vector4 &a, const Vector4 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{a, }
\item[{const {\bf Vector4} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1ffa413af039c2bff07202dcfce55f05}{}\label{namespaceprism_a1ffa413af039c2bff07202dcfce55f05}
Compares the vectors and returns true if a and b are not equal, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Vector3 \&a, const Vector3 \&b)}{operator!=(const Vector3 &a, const Vector3 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{a, }
\item[{const {\bf Vector3} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa752c5d0210902dece31c2fcfc98a824}{}\label{namespaceprism_aa752c5d0210902dece31c2fcfc98a824}
Compares the vectors and returns true if a and b are not equal, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Quaternion \&q1, const Quaternion \&q2)}{operator!=(const Quaternion &q1, const Quaternion &q2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q1, }
\item[{const {\bf Quaternion} \&}]{q2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9e32551f997ae19dc52df146482405c1}{}\label{namespaceprism_a9e32551f997ae19dc52df146482405c1}
Compares q1 and q2 and returns true if they are not equal, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Bitvector \&bv1, const Bitvector \&bv2)}{operator!=(const Bitvector &bv1, const Bitvector &bv2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Bitvector} \&}]{bv1, }
\item[{const {\bf Bitvector} \&}]{bv2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aca663878d61686ef365f3e51efddc4b4}{}\label{namespaceprism_aca663878d61686ef365f3e51efddc4b4}
\begin{DoxyReturn}{Returns}
Returns true if the two Bitvectors are not equal to each other, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Circle \&c1, const Circle \&c2)}{operator!=(const Circle &c1, const Circle &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Circle} \&}]{c1, }
\item[{const {\bf Circle} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a58cbf7ef406800002b446a0f1e917745}{}\label{namespaceprism_a58cbf7ef406800002b446a0f1e917745}
\begin{DoxyReturn}{Returns}
Returns true if both circles are not equal, false otherwsie. 
\end{DoxyReturn}
\index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Rect \&r1, const Rect \&r2)}{operator!=(const Rect &r1, const Rect &r2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Rect} \&}]{r1, }
\item[{const {\bf Rect} \&}]{r2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad9f46c5ebd3cec844925173aaacbed9f}{}\label{namespaceprism_ad9f46c5ebd3cec844925173aaacbed9f}
Returns true if the rectangles {\itshape r1} and {\itshape r2} are not equal, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Matrix4 \&m1, const Matrix4 \&m2)}{operator!=(const Matrix4 &m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4d184994eec61a1511fc936a9facb69a}{}\label{namespaceprism_a4d184994eec61a1511fc936a9facb69a}
Compares the elements of the two matrices and returns true if they don\textquotesingle{}t contain the same data, false otherwise. \index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const String \&str1, const String \&str2)}{operator!=(const String &str1, const String &str2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf String} \&}]{str1, }
\item[{const {\bf String} \&}]{str2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5c2215edf9ab445c3c1791217d131b15}{}\label{namespaceprism_a5c2215edf9ab445c3c1791217d131b15}
\index{prism@{prism}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator"!=(const Deque$<$ T, T\+\_\+\+Alloc $>$ \&rhs)}{operator!=(const Deque< T, T_Alloc > &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Deque}$<$ T, T\+\_\+\+Alloc $>$ \&}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7410d6cd07f48e8495d2ac7196b2e609}{}\label{namespaceprism_a7410d6cd07f48e8495d2ac7196b2e609}
\index{prism@{prism}!operator\&@{operator\&}}
\index{operator\&@{operator\&}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator\&(const Bitvector \&bv1, const Bitvector \&bv2)}{operator&(const Bitvector &bv1, const Bitvector &bv2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Bitvector} prism\+::operator\& (
\begin{DoxyParamCaption}
\item[{const {\bf Bitvector} \&}]{bv1, }
\item[{const {\bf Bitvector} \&}]{bv2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a26b2b2b5b2c5f305badd964c24625b36}{}\label{namespaceprism_a26b2b2b5b2c5f305badd964c24625b36}
Performs a bitwise A\+ND on {\itshape bv1} and {\itshape bv2}. \begin{DoxyReturn}{Returns}
Returns a new \hyperlink{classprism_1_1_bitvector}{Bitvector} with the result of {\itshape }(bv1 \& bv2). 
\end{DoxyReturn}
\index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Fraction \&f1, const Fraction \&f2)}{operator*(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ac4f48e3429a86bafcc7c21a2bd6a7ae1}{}\label{namespaceprism_ac4f48e3429a86bafcc7c21a2bd6a7ae1}
Multiplies /em f1 and /em f2 together and returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. \hyperlink{classprism_1_1_fraction}{Fraction} multiplication is the easiest arithmetical operation. Simply multiply the two numerators together to form the new numerator and multiply the two denominators together to form the new denominator. e.\+g. 2 8 2x8 16 4 --- x --- = --- = --- = --- 5 4 5x4 20 5 \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Fraction \&fraction, const int i)}{operator*(const Fraction &fraction, const int i)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{fraction, }
\item[{const int}]{i}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1f5007702b28b447f62c3b9df62f2aa4}{}\label{namespaceprism_a1f5007702b28b447f62c3b9df62f2aa4}
Multiplies the \hyperlink{classprism_1_1_fraction}{Fraction} /em fraction by the whole number /em i. Returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Pointf \&p, const float factor)}{operator*(const Pointf &p, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pointf} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ade1984e58679ef4d8fcdd37726ee6483}{}\label{namespaceprism_ade1984e58679ef4d8fcdd37726ee6483}
Returns a \hyperlink{classprism_1_1_pointf}{Pointf} object that is formed by multiplying the components of p by the float factor \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Pointf \&p)}{operator*(const float factor, const Pointf &p)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pointf} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Pointf} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a409aa6b61b79f029d78f6d4c3aba2df5}{}\label{namespaceprism_a409aa6b61b79f029d78f6d4c3aba2df5}
\index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const int i, const Fraction \&fraction)}{operator*(const int i, const Fraction &fraction)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const int}]{i, }
\item[{const {\bf Fraction} \&}]{fraction}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af1ff5871f65565a84b886c5013bcd50a}{}\label{namespaceprism_af1ff5871f65565a84b886c5013bcd50a}
Multiplies the whole number /em i by the \hyperlink{classprism_1_1_fraction}{Fraction} /em fraction. Returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Point \&p, const int factor)}{operator*(const Point &p, const int factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p, }
\item[{const int}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a40976ce143923309d4c737bb8288d9e5}{}\label{namespaceprism_a40976ce143923309d4c737bb8288d9e5}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by multiplying the components of p by the int factor \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Point \&p, const float factor)}{operator*(const Point &p, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a96e41c0858ff4149eafa1bc878dabb7c}{}\label{namespaceprism_a96e41c0858ff4149eafa1bc878dabb7c}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by multiplying the components of p by the float factor Note\+: the x and y components are rounded to the nearest integer as they are stored as ints internally. Use \hyperlink{classprism_1_1_pointf}{Pointf} for floating point accuracy instead. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const int factor, const Point \&p)}{operator*(const int factor, const Point &p)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const int}]{factor, }
\item[{const {\bf Point} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa46a547ddc48425588986b0840d026a4}{}\label{namespaceprism_aa46a547ddc48425588986b0840d026a4}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by multiplying the components of p by the int factor \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Point \&p)}{operator*(const float factor, const Point &p)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Point} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1ec2671f1e6c155a79740a8556baecc0}{}\label{namespaceprism_a1ec2671f1e6c155a79740a8556baecc0}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by multiplying the components of p by the float factor Note\+: the x and y components are rounded to the nearest integer as they are stored as ints internally. Use \hyperlink{classprism_1_1_pointf}{Pointf} for floating point accuracy instead. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Size \&size, const int factor)}{operator*(const Size &size, const int factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Size} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{size, }
\item[{const int}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a3d8e53ee3208e09e8736a77be3f485c9}{}\label{namespaceprism_a3d8e53ee3208e09e8736a77be3f485c9}
Multiplies {\itshape size} by {\itshape factor} and returns a new \hyperlink{classprism_1_1_size}{Size} object. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const int factor, const Size \&size)}{operator*(const int factor, const Size &size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Size} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const int}]{factor, }
\item[{const {\bf Size} \&}]{size}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_acd79758984cccce0dddfb459af65f6e1}{}\label{namespaceprism_acd79758984cccce0dddfb459af65f6e1}
Multiplies {\itshape size} by {\itshape factor} and returns a new \hyperlink{classprism_1_1_size}{Size} object. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Vector2 \&v)}{operator*(const float factor, const Vector2 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Vector2} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6528ec4496096e8ccde186bb01fbeed3}{}\label{namespaceprism_a6528ec4496096e8ccde186bb01fbeed3}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Vector2 \&v, const float factor)}{operator*(const Vector2 &v, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{v, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1de3bc1dbc3fd33f26d580bce3520854}{}\label{namespaceprism_a1de3bc1dbc3fd33f26d580bce3520854}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Quaternion \&q1, const Quaternion \&q2)}{operator*(const Quaternion &q1, const Quaternion &q2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q1, }
\item[{const {\bf Quaternion} \&}]{q2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a74c3eeec91c3a178711b6f05a5487d70}{}\label{namespaceprism_a74c3eeec91c3a178711b6f05a5487d70}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the product of q1 and q2. Note\+: quaternion multiplication is associative so a(bc) = (ab)c but is not commutitive so q1q2 does not always equal q2q1. Order matters! \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Vector4 \&v)}{operator*(const float factor, const Vector4 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Vector4} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa652a61fe96302693aa0279e832360c7}{}\label{namespaceprism_aa652a61fe96302693aa0279e832360c7}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Vector4 \&v, const float factor)}{operator*(const Vector4 &v, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{v, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab3b4a59d9247143b49db3c2778838895}{}\label{namespaceprism_ab3b4a59d9247143b49db3c2778838895}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Vector3 \&v)}{operator*(const float factor, const Vector3 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Vector3} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a429cccc5eee454ba019045afb4a01e93}{}\label{namespaceprism_a429cccc5eee454ba019045afb4a01e93}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Vector3 \&v, const float factor)}{operator*(const Vector3 &v, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{v, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa1f2f6de8bf1b584cbb82062a607e167}{}\label{namespaceprism_aa1f2f6de8bf1b584cbb82062a607e167}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} that has had each vector component of v multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Quaternion \&q, const float factor)}{operator*(const Quaternion &q, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a45806b1a58ec5aae0db87d399d4d832b}{}\label{namespaceprism_a45806b1a58ec5aae0db87d399d4d832b}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the result of multiplying each component of q by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Quaternion \&q)}{operator*(const float factor, const Quaternion &q)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Quaternion} \&}]{q}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad9f03413053b1efa6851344eb39a5982}{}\label{namespaceprism_ad9f03413053b1efa6851344eb39a5982}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the result of multiplying each component of q by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Quaternion \&q, const Vector3 \&v)}{operator*(const Quaternion &q, const Vector3 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q, }
\item[{const {\bf Vector3} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8aebd3615ba448915f37140515a37b05}{}\label{namespaceprism_a8aebd3615ba448915f37140515a37b05}
Multiplies a quaternion and vector3 together and returns a quaternion as a result. The vector is just transformed into a quaternion (setting w = 0) and then the two quaternions are multiplied. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Quaternion \&q, const Vector4 \&v)}{operator*(const Quaternion &q, const Vector4 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q, }
\item[{const {\bf Vector4} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2c4c5e120d8c4de9891f2261a50f100e}{}\label{namespaceprism_a2c4c5e120d8c4de9891f2261a50f100e}
Multiplies a quaternion and \hyperlink{classprism_1_1_vector4}{Vector4} together and returns a quaternion as a result. The vector is just transformed into a quaternion and then the two quaternions are multiplied. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m1, const Matrix4 \&m2)}{operator*(const Matrix4 &m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9ae44fb46bb709a5c8f4d592baf65522}{}\label{namespaceprism_a9ae44fb46bb709a5c8f4d592baf65522}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} that is the product of m1 and m2 i.\+e. m1m2 \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float factor, const Matrix4 \&m)}{operator*(const float factor, const Matrix4 &m)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float}]{factor, }
\item[{const {\bf Matrix4} \&}]{m}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab3639f7bd46a54726522dfe406841ea9}{}\label{namespaceprism_ab3639f7bd46a54726522dfe406841ea9}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} where each component of m is multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m, const float factor)}{operator*(const Matrix4 &m, const float factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4073983f089695c40b6fd20d892175f9}{}\label{namespaceprism_a4073983f089695c40b6fd20d892175f9}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} where each component of m is multiplied by factor. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m1, const float $\ast$m2)}{operator*(const Matrix4 &m1, const float *m2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const float $\ast$}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa2859acb8e8dd6fea8678e14249e561d}{}\label{namespaceprism_aa2859acb8e8dd6fea8678e14249e561d}
Returns a \hyperlink{classprism_1_1_matrix4}{Matrix4} that is the result of multiplying a \hyperlink{classprism_1_1_matrix4}{Matrix4} with a float array. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const float $\ast$m1, const Matrix4 \&m2)}{operator*(const float *m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const float $\ast$}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5e83bcd69595728106bed838aeb32f70}{}\label{namespaceprism_a5e83bcd69595728106bed838aeb32f70}
Returns a \hyperlink{classprism_1_1_matrix4}{Matrix4} that is the result of multiplying a \hyperlink{classprism_1_1_matrix4}{Matrix4} with a float array. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Vector3 \&v, const Matrix4 \&m)}{operator*(const Vector3 &v, const Matrix4 &m)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{v, }
\item[{const {\bf Matrix4} \&}]{m}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a95ceb3342a808c88d0bb7c1f7e0ef82b}{}\label{namespaceprism_a95ceb3342a808c88d0bb7c1f7e0ef82b}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} which has been transformed by the matrix M in the order of vM. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m, const Vector3 \&v)}{operator*(const Matrix4 &m, const Vector3 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m, }
\item[{const {\bf Vector3} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a04f1e6e0f84169fce23b236e0312d6a0}{}\label{namespaceprism_a04f1e6e0f84169fce23b236e0312d6a0}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} which has been transformed by the matrix M in the order of Mv. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Vector4 \&v, const Matrix4 \&m)}{operator*(const Vector4 &v, const Matrix4 &m)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{v, }
\item[{const {\bf Matrix4} \&}]{m}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5a10d8ea1e63b19d02bd294e4ebabb1b}{}\label{namespaceprism_a5a10d8ea1e63b19d02bd294e4ebabb1b}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} which has been transformed by the matrix M in the order of vM. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m, const Vector4 \&v)}{operator*(const Matrix4 &m, const Vector4 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m, }
\item[{const {\bf Vector4} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad125bd8304d577b6f879fb973f774eb8}{}\label{namespaceprism_ad125bd8304d577b6f879fb973f774eb8}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} which has been transformed by the matrix M in the order of Mv. \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Point \&p, const Matrix4 \&m)}{operator*(const Point &p, const Matrix4 &m)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p, }
\item[{const {\bf Matrix4} \&}]{m}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a44373b8bda7131a90d04eef7e455ea6f}{}\label{namespaceprism_a44373b8bda7131a90d04eef7e455ea6f}
Returns a \hyperlink{classprism_1_1_point}{Point} which has been transformed by the matrix m in the order of pM \index{prism@{prism}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Matrix4 \&m, const Point \&p)}{operator*(const Matrix4 &m, const Point &p)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m, }
\item[{const {\bf Point} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a82522932359d2381607cf1fe0c898011}{}\label{namespaceprism_a82522932359d2381607cf1fe0c898011}
Returns a \hyperlink{classprism_1_1_point}{Point} which has been transformed by the matrix M in the order of Mp \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Fraction \&f1, const Fraction \&f2)}{operator+(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ac1b5b2765c314b2baa2dba5c57419829}{}\label{namespaceprism_ac1b5b2765c314b2baa2dba5c57419829}
Adds the fractions /em f1 and /em f2 together and returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. If the two denominators are the same then the two numerators are added together to form the new numerator and the original denominator is kept the same. e.\+g. 1 1 2 --- + --- = --- 4 4 4 If the denominators are different then we alter the fractions in order to make both denominators the same value. We make a whole fraction out of the second fraction\textquotesingle{}s denominator and multiply it by the first fraction. Then make a whole fraction from the first fraction\textquotesingle{}s denominator and multiply it by the second fraction. Now we can simply add together the two numerators and keep the denominator the same. 1 1 $\vert$ 4 1 $\vert$ $\vert$ 1 2 $\vert$ 4 2 6 3 --- + --- = $\vert$--- x ---$\vert$ + $\vert$--- x ---$\vert$ = --- + --- = --- = --- 2 4 $\vert$ 4 2 $\vert$ $\vert$ 4 2 $\vert$ 8 8 8 4 \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Pointf \&p1, const Pointf \&p2)}{operator+(const Pointf &p1, const Pointf &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pointf} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p1, }
\item[{const {\bf Pointf} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a64243aa2d4cf6ddb70526aaeda396f82}{}\label{namespaceprism_a64243aa2d4cf6ddb70526aaeda396f82}
Returns a \hyperlink{classprism_1_1_pointf}{Pointf} object that is the sum of the components of p1 and p2 \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Point \&p1, const Point \&p2)}{operator+(const Point &p1, const Point &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p1, }
\item[{const {\bf Point} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a49e983b5c32c93114583309eda19dc2b}{}\label{namespaceprism_a49e983b5c32c93114583309eda19dc2b}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is the sum of the components of p1 and p2 \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Size \&s1, const Size \&s2)}{operator+(const Size &s1, const Size &s2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Size} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{s1, }
\item[{const {\bf Size} \&}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7141aeb35db81548155e44d60c05530e}{}\label{namespaceprism_a7141aeb35db81548155e44d60c05530e}
Adds {\itshape s1} and {\itshape s2} together and returns a new \hyperlink{classprism_1_1_size}{Size} object. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Vector2 \&a, const Vector2 \&b)}{operator+(const Vector2 &a, const Vector2 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{a, }
\item[{const {\bf Vector2} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae482804c32b466401a9ecdf26bc1e6de}{}\label{namespaceprism_ae482804c32b466401a9ecdf26bc1e6de}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} that is the result of adding the components of vector a and vector b. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Time \&t1, const Time \&t2)}{operator+(const Time &t1, const Time &t2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Time} \&}]{t1, }
\item[{const {\bf Time} \&}]{t2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_afd483f03b731881b25da5612b1213e5f}{}\label{namespaceprism_afd483f03b731881b25da5612b1213e5f}
Adds the two \hyperlink{classprism_1_1_time}{Time} objects together to produce a new \hyperlink{classprism_1_1_time}{Time} object. If the new time would be later than midnight then the time wraps round. 
\begin{DoxyCode}
Time time(20,0); \textcolor{comment}{// 8pm}
Time offset1 = \hyperlink{classprism_1_1_time_a380242e03982df8bf4af3eaa2296c808}{Time::hour}(2);
Time offset2 = \hyperlink{classprism_1_1_time_a380242e03982df8bf4af3eaa2296c808}{Time::hour}(5);

Time result;

result = time+offset1; \textcolor{comment}{// Time object set to 22:00:00:000}
result = time+offset2; \textcolor{comment}{// Time object set to 01:00:00:000}
\end{DoxyCode}
 \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Quaternion \&q1, const Quaternion \&q2)}{operator+(const Quaternion &q1, const Quaternion &q2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q1, }
\item[{const {\bf Quaternion} \&}]{q2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad81bceaddc25922e571b4bf427ffe296}{}\label{namespaceprism_ad81bceaddc25922e571b4bf427ffe296}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the sum of q1 and q2 i.\+e. each component of q1 is added to the corresponding component of q2. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Vector4 \&a, const Vector4 \&b)}{operator+(const Vector4 &a, const Vector4 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{a, }
\item[{const {\bf Vector4} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4ac9ebc0ce1449793eb8f521c64929a9}{}\label{namespaceprism_a4ac9ebc0ce1449793eb8f521c64929a9}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} that is the result of adding the components of vector a and vector b. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Vector3 \&a, const Vector3 \&b)}{operator+(const Vector3 &a, const Vector3 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{a, }
\item[{const {\bf Vector3} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7ac90b31f235390d6feb818e3f88ecf0}{}\label{namespaceprism_a7ac90b31f235390d6feb818e3f88ecf0}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} that is the result of adding the components of vector a and vector b. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Matrix4 \&m1, const Matrix4 \&m2)}{operator+(const Matrix4 &m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a33537d30f01f996f8a05fc5b1b49ba3b}{}\label{namespaceprism_a33537d30f01f996f8a05fc5b1b49ba3b}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} which is the sum of m1 and m2. \index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const String \&str1, const String \&str2)}{operator+(const String &str1, const String &str2)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf String} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf String} \&}]{str1, }
\item[{const {\bf String} \&}]{str2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a433f7afd310d95a93cf8c03d1f831812}{}\label{namespaceprism_a433f7afd310d95a93cf8c03d1f831812}
\index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const String \&str1, const char $\ast$str2)}{operator+(const String &str1, const char *str2)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf String} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf String} \&}]{str1, }
\item[{const char $\ast$}]{str2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a50879e9455a36b7762514951ca0f47f7}{}\label{namespaceprism_a50879e9455a36b7762514951ca0f47f7}
\index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const char $\ast$str1, const String \&str2)}{operator+(const char *str1, const String &str2)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf String} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{str1, }
\item[{const {\bf String} \&}]{str2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7d59729f69eafd3bc9f4d30ad9dd06b6}{}\label{namespaceprism_a7d59729f69eafd3bc9f4d30ad9dd06b6}
\index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const char c, const String \&str)}{operator+(const char c, const String &str)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf String} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const char}]{c, }
\item[{const {\bf String} \&}]{str}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa0fce6a8b93050fcb6db327e68b701e3}{}\label{namespaceprism_aa0fce6a8b93050fcb6db327e68b701e3}
\index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const String \&str, const char c)}{operator+(const String &str, const char c)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf String} prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf String} \&}]{str, }
\item[{const char}]{c}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8ae68ccc6eb3a47a748671c1a7af88ca}{}\label{namespaceprism_a8ae68ccc6eb3a47a748671c1a7af88ca}
\index{prism@{prism}!operator+@{operator+}}
\index{operator+@{operator+}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+(const Deque$<$ T, Alloc $>$ \&rhs)}{operator+(const Deque< T, Alloc > &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Deque}$<$T, Alloc$>$ prism\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Deque}$<$ T, Alloc $>$ \&}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a769b9ece349795edbfeb8e33cbf276e5}{}\label{namespaceprism_a769b9ece349795edbfeb8e33cbf276e5}
\index{prism@{prism}!operator+=@{operator+=}}
\index{operator+=@{operator+=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator+=(const Deque$<$ T, Alloc $>$ \&rhs)}{operator+=(const Deque< T, Alloc > &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Deque}$<$T, Alloc$>$\& prism\+::operator+= (
\begin{DoxyParamCaption}
\item[{const {\bf Deque}$<$ T, Alloc $>$ \&}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1619579754dfe66f3fe3559f2e4495e5}{}\label{namespaceprism_a1619579754dfe66f3fe3559f2e4495e5}
\index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Fraction \&f1, const Fraction \&f2)}{operator-(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2daf470e5f35f8450447deb2634c22c1}{}\label{namespaceprism_a2daf470e5f35f8450447deb2634c22c1}
Subtracts the fractions /em f1 and /em f2 and returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. If the two denominators are the same then the two numerators are subtracted to form the new numerator and the original denominator is kept the same. e.\+g. 3 1 2 --- -\/ --- = --- 4 4 4 If the denominators are different then we alter the fractions in order to make both denominators the same value. We make a whole fraction out of the second fraction\textquotesingle{}s denominator and multiply it by the first fraction. Then make a whole fraction from the first fraction\textquotesingle{}s denominator and multiply it by the second fraction. Now we can simply subtract the two numerators and keep the denominator the same. 3 1 $\vert$ 2 3 $\vert$ $\vert$ 1 4 $\vert$ 6 4 2 1 --- -\/ --- = $\vert$--- x ---$\vert$ -\/ $\vert$--- x ---$\vert$ = --- -\/ --- = --- = --- 4 2 $\vert$ 2 4 $\vert$ $\vert$ 2 4 $\vert$ 8 8 8 4 \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Pointf \&p1, const Pointf \&p2)}{operator-(const Pointf &p1, const Pointf &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pointf} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p1, }
\item[{const {\bf Pointf} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a435d5c45d873875f2c5092d102eddb78}{}\label{namespaceprism_a435d5c45d873875f2c5092d102eddb78}
Returns a \hyperlink{classprism_1_1_pointf}{Pointf} object that is formed by subtracting the components of p2 from p1 \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Point \&p1, const Point \&p2)}{operator-(const Point &p1, const Point &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p1, }
\item[{const {\bf Point} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a505cbd94f024ad80136afe0b751da08a}{}\label{namespaceprism_a505cbd94f024ad80136afe0b751da08a}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by subtracting the components of p2 from p1 \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Size \&s1, const Size \&s2)}{operator-(const Size &s1, const Size &s2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Size} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{s1, }
\item[{const {\bf Size} \&}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab170e3ca42d85a6766cbc7950ddfb0c4}{}\label{namespaceprism_ab170e3ca42d85a6766cbc7950ddfb0c4}
Subtracts {\itshape s2} from {\itshape s1} and returns a new \hyperlink{classprism_1_1_size}{Size} object. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector2 \&a, const Vector2 \&b)}{operator-(const Vector2 &a, const Vector2 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{a, }
\item[{const {\bf Vector2} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a86359a88dc5245847de48575a1f969e8}{}\label{namespaceprism_a86359a88dc5245847de48575a1f969e8}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} that is the result of subtracting the components of vector b from vector a. Note\+: vector subtraction is not commutitive so a-\/b does not always equal b-\/a \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector2 \&v)}{operator-(const Vector2 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a124f1081b3a9bbc441dac9927f8a0fc5}{}\label{namespaceprism_a124f1081b3a9bbc441dac9927f8a0fc5}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} object where each vector component of v has been negated. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Time \&t1, const Time \&t2)}{operator-(const Time &t1, const Time &t2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Time} \&}]{t1, }
\item[{const {\bf Time} \&}]{t2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa18009df22007fbbde08ab44b16a9a31}{}\label{namespaceprism_aa18009df22007fbbde08ab44b16a9a31}
Subtracts the \hyperlink{classprism_1_1_time}{Time} object {\itshape t2} from {\itshape t1} to produce a new \hyperlink{classprism_1_1_time}{Time} object. If the new time would be before midnight then the time wraps round. 
\begin{DoxyCode}
Time time(5,0); \textcolor{comment}{// 5am}
Time offset1 = \hyperlink{classprism_1_1_time_a380242e03982df8bf4af3eaa2296c808}{Time::hour}(2);
Time offset2 = \hyperlink{classprism_1_1_time_a380242e03982df8bf4af3eaa2296c808}{Time::hour}(7);

Time result;

result = time-offset1; \textcolor{comment}{// Time object set to 03:00:00:000 (3am)}
result = time-offset2; \textcolor{comment}{// Time object set to 22:00:00:000 (10pm)}
\end{DoxyCode}
 \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Quaternion \&q1, const Quaternion \&q2)}{operator-(const Quaternion &q1, const Quaternion &q2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q1, }
\item[{const {\bf Quaternion} \&}]{q2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5eae37b5dc73c544572686f215cea89d}{}\label{namespaceprism_a5eae37b5dc73c544572686f215cea89d}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the result of subtracting q2 from q1 i.\+e. each component of q2 is subtracted from the corresponding component of q1. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector4 \&a, const Vector4 \&b)}{operator-(const Vector4 &a, const Vector4 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{a, }
\item[{const {\bf Vector4} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a038a64f530d1c50bf72cf1a23886ecca}{}\label{namespaceprism_a038a64f530d1c50bf72cf1a23886ecca}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} that is the result of subtracting the components of vector b from vector a. Note\+: vector subtraction is not commutitive so a-\/b does not always equal b-\/a \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(\+Quaternion \&q)}{operator-(Quaternion &q)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{{\bf Quaternion} \&}]{q}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae04c2e5eae2242c58a967086ecad8ff4}{}\label{namespaceprism_ae04c2e5eae2242c58a967086ecad8ff4}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} which has had each component of q negated. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector4 \&v)}{operator-(const Vector4 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a147712ae50c37618cbc61f20efe6729f}{}\label{namespaceprism_a147712ae50c37618cbc61f20efe6729f}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} object where each vector component of v has been negated. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector3 \&a, const Vector3 \&b)}{operator-(const Vector3 &a, const Vector3 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{a, }
\item[{const {\bf Vector3} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a3beb56b334423e027f1ab185785695f8}{}\label{namespaceprism_a3beb56b334423e027f1ab185785695f8}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} that is the result of subtracting the components of vector b from vector a. Note\+: vector subtraction is not commutitive so a-\/b does not always equal b-\/a \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Vector3 \&v)}{operator-(const Vector3 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8f7cf835ff415e187e6881169803f502}{}\label{namespaceprism_a8f7cf835ff415e187e6881169803f502}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} object where each vector component of v has been negated. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Matrix4 \&m1, const Matrix4 \&m2)}{operator-(const Matrix4 &m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a34a2f64f209065f753bed62a880b75b6}{}\label{namespaceprism_a34a2f64f209065f753bed62a880b75b6}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} which is the result of subtracting m2 from m1. \index{prism@{prism}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator-\/(const Matrix4 \&m)}{operator-(const Matrix4 &m)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a879d3410d690b5722a9af17297f38fbb}{}\label{namespaceprism_a879d3410d690b5722a9af17297f38fbb}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} where each component of matrix m has been negated (multiplyed by -\/1). \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Pointf \&p, const float divisor)}{operator/(const Pointf &p, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pointf} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a71504f6dd299e8bc788e07d11d29dc5e}{}\label{namespaceprism_a71504f6dd299e8bc788e07d11d29dc5e}
Returns a \hyperlink{classprism_1_1_pointf}{Pointf} object that is formed by dividing the components of p by divisor \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Fraction \&f1, const Fraction \&f2)}{operator/(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fraction} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7ba7b5cc9750f0d6cda50f0cb874da6f}{}\label{namespaceprism_a7ba7b5cc9750f0d6cda50f0cb874da6f}
Divides /em f1 by /em f2 and returns a new \hyperlink{classprism_1_1_fraction}{Fraction}. \hyperlink{classprism_1_1_fraction}{Fraction} division is achieved by taking the reciprocal of the second fraction and multiplying it against the first fraction. See /em \hyperlink{classprism_1_1_fraction_aab12f13967ca16e8956618f9d0641c31}{Fraction\+::reciprocal()} for more information. 3 2 3 7 21 --- / --- = --- $\ast$ --- = --- 4 7 4 2 8 \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Point \&p, const float divisor)}{operator/(const Point &p, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5f73aee33931e5b9977da32e50d47c0e}{}\label{namespaceprism_a5f73aee33931e5b9977da32e50d47c0e}
Returns a \hyperlink{classprism_1_1_point}{Point} object that is formed by dividing the components of p1 by the components of p2 \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Size \&size, const int factor)}{operator/(const Size &size, const int factor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Size} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{size, }
\item[{const int}]{factor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad7e100bd6b1730deaab53d1218e29a67}{}\label{namespaceprism_ad7e100bd6b1730deaab53d1218e29a67}
Divides {\itshape size} by {\itshape factor} rounding to integer precision and returns a new \hyperlink{classprism_1_1_size}{Size} object. \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Vector2 \&v, const float divisor)}{operator/(const Vector2 &v, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector2} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{v, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aea1ab02785c9d4d5ea560face252b75e}{}\label{namespaceprism_aea1ab02785c9d4d5ea560face252b75e}
Returns a \hyperlink{classprism_1_1_vector2}{Vector2} where each component of vector v has been divided by divisor. If divisor is 0 then a zero vector is returned instead. \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Vector4 \&v, const float divisor)}{operator/(const Vector4 &v, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector4} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{v, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4aa2b9a75c3d5134fc80cc6afc1be443}{}\label{namespaceprism_a4aa2b9a75c3d5134fc80cc6afc1be443}
Returns a \hyperlink{classprism_1_1_vector4}{Vector4} where each component of vector v has been divided by divisor. If divisor is 0 then a zero vector is returned instead. \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Vector3 \&v, const float divisor)}{operator/(const Vector3 &v, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Vector3} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{v, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a87e022748076586917c38e83430df284}{}\label{namespaceprism_a87e022748076586917c38e83430df284}
Returns a \hyperlink{classprism_1_1_vector3}{Vector3} where each component of vector v has been divided by divisor. If divisor is 0 then a zero vector is returned instead. \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Quaternion \&q, const float divisor)}{operator/(const Quaternion &q, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Quaternion} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aec648937a53338bcd9879670877d0425}{}\label{namespaceprism_aec648937a53338bcd9879670877d0425}
Returns a \hyperlink{classprism_1_1_quaternion}{Quaternion} that is the result of dividing each component of q by divisor. If divisor is 0 then a identity quaternion is returned instead. \index{prism@{prism}!operator/@{operator/}}
\index{operator/@{operator/}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator/(const Matrix4 \&m, const float divisor)}{operator/(const Matrix4 &m, const float divisor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix4} prism\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m, }
\item[{const float}]{divisor}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a517b4bc9b0ccc23f79b744d93b540fa6}{}\label{namespaceprism_a517b4bc9b0ccc23f79b744d93b540fa6}
Returns a new \hyperlink{classprism_1_1_matrix4}{Matrix4} where each component of matrix m is divided by divisor. If divisor is 0 a new \hyperlink{classprism_1_1_matrix4}{Matrix4} is returned set to the identity matrix instead. \index{prism@{prism}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$(const Char \&c1, const Char \&c2)}{operator<(const Char &c1, const Char &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Char} \&}]{c1, }
\item[{const {\bf Char} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2fc3e64ba36a16f24cb0ae387c83f35f}{}\label{namespaceprism_a2fc3e64ba36a16f24cb0ae387c83f35f}
\begin{DoxyReturn}{Returns}
Returns true if the unicode value of {\itshape c1} is less than {\itshape c2}, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$(const Fraction \&f1, const Fraction \&f2)}{operator<(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a105ac9995ade66ebb2a039ef90751c7a}{}\label{namespaceprism_a105ac9995ade66ebb2a039ef90751c7a}
Returns true if /em f1 is less than /em f2, false otherwise. \index{prism@{prism}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$(const Circle \&c1, const Circle \&c2)}{operator<(const Circle &c1, const Circle &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Circle} \&}]{c1, }
\item[{const {\bf Circle} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8e662d15b162ca76912c491798caefd3}{}\label{namespaceprism_a8e662d15b162ca76912c491798caefd3}
\begin{DoxyReturn}{Returns}
Returns true if {\itshape c1} has a smaller radius than {\itshape c2}, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Pointf \&p)}{operator<<(std::ostream &out, const Pointf &p)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Pointf} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_acad408bf2576dfc62a573cb44aa895fb}{}\label{namespaceprism_acad408bf2576dfc62a573cb44aa895fb}
Returns an ostream object that allows this object to printed with std\+::cout \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Point \&p)}{operator<<(std::ostream &out, const Point &p)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Point} \&}]{p}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_acb9fe7ab8ef5f1ee0338e3b057624393}{}\label{namespaceprism_acb9fe7ab8ef5f1ee0338e3b057624393}
Returns an ostream object that allows this object to printed with std\+::cout \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Char \&c)}{operator<<(std::ostream &out, const Char &c)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Char} \&}]{c}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa67ea1154a35dabe9c2c232aff65e930}{}\label{namespaceprism_aa67ea1154a35dabe9c2c232aff65e930}
Allows an instance of \hyperlink{classprism_1_1_char}{Char} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Fraction \&f)}{operator<<(std::ostream &out, const Fraction &f)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Fraction} \&}]{f}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9c2d182a77a92e6cba7917dbd58f9d87}{}\label{namespaceprism_a9c2d182a77a92e6cba7917dbd58f9d87}
Allows an instance of \hyperlink{classprism_1_1_fraction}{Fraction} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Size \&size)}{operator<<(std::ostream &out, const Size &size)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Size} \&}]{size}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad6335168e27f481d86ae42da444006d1}{}\label{namespaceprism_ad6335168e27f481d86ae42da444006d1}
Allows an instance of \hyperlink{classprism_1_1_size}{Size} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Time \&t)}{operator<<(std::ostream &out, const Time &t)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Time} \&}]{t}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7c24ead13d51c13dcadde1b6df4a4967}{}\label{namespaceprism_a7c24ead13d51c13dcadde1b6df4a4967}
Allows an instance of \hyperlink{classprism_1_1_time}{Time} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Vector2 \&v)}{operator<<(std::ostream &out, const Vector2 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Vector2} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4616180b97f4288a3b3e28304efee020}{}\label{namespaceprism_a4616180b97f4288a3b3e28304efee020}
Allows an instance of \hyperlink{classprism_1_1_vector2}{Vector2} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Vector4 \&v)}{operator<<(std::ostream &out, const Vector4 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Vector4} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aeb86919d9ba71747d21fbd6e28671692}{}\label{namespaceprism_aeb86919d9ba71747d21fbd6e28671692}
Allows an instance of \hyperlink{classprism_1_1_vector4}{Vector4} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Vector3 \&v)}{operator<<(std::ostream &out, const Vector3 &v)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Vector3} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa7b9367a483153af865552ba486f1196}{}\label{namespaceprism_aa7b9367a483153af865552ba486f1196}
Allows an instance of \hyperlink{classprism_1_1_vector3}{Vector3} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Quaternion \&q)}{operator<<(std::ostream &out, const Quaternion &q)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Quaternion} \&}]{q}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad2beaed7a837821f0abc608cf6ac6c0f}{}\label{namespaceprism_ad2beaed7a837821f0abc608cf6ac6c0f}
Returns a reference to a stream which allows an instance of \hyperlink{classprism_1_1_quaternion}{Quaternion} to be written to the stream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Array$<$ T $>$ \&array)}{operator<<(std::ostream &out, const Array< T > &array)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Array}$<$ T $>$ \&}]{array}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a403ca8f79c481a89132691c0fd8c3a06}{}\label{namespaceprism_a403ca8f79c481a89132691c0fd8c3a06}
\index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Bitvector \&bv)}{operator<<(std::ostream &out, const Bitvector &bv)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Bitvector} \&}]{bv}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a0b98ff0fee78022242292f24158ad1f0}{}\label{namespaceprism_a0b98ff0fee78022242292f24158ad1f0}
Allows an instance of \hyperlink{classprism_1_1_bitvector}{Bitvector} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Circle \&c)}{operator<<(std::ostream &out, const Circle &c)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Circle} \&}]{c}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa63d3d39d3fad8fa5c5966cc4f306324}{}\label{namespaceprism_aa63d3d39d3fad8fa5c5966cc4f306324}
Allows an instance of \hyperlink{classprism_1_1_circle}{Circle} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Rect \&rect)}{operator<<(std::ostream &out, const Rect &rect)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Rect} \&}]{rect}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a52fd2a97b66b06ba6e451e1890136ff4}{}\label{namespaceprism_a52fd2a97b66b06ba6e451e1890136ff4}
Allows an instance of \hyperlink{classprism_1_1_rect}{Rect} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const List$<$ T $>$ \&list)}{operator<<(std::ostream &out, const List< T > &list)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf List}$<$ T $>$ \&}]{list}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a50da64555d454821545fe0311fde6a62}{}\label{namespaceprism_a50da64555d454821545fe0311fde6a62}
Outputs a human-\/friendly summary of {\itshape list} to the stream {\itshape out}. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Matrix4 \&matrix)}{operator<<(std::ostream &out, const Matrix4 &matrix)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Matrix4} \&}]{matrix}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab65e15b3e601e0570beb49a11610c671}{}\label{namespaceprism_ab65e15b3e601e0570beb49a11610c671}
Allows an instance of Matrx4x4 to be written to the ostream out and returns a reference to the ostream. i.\+e. std\+::cout $<$$<$ matrix $<$$<$ std\+::endl; \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const String \&s)}{operator<<(std::ostream &out, const String &s)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf String} \&}]{s}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a0a166bbf645cc854542cc0fc50324670}{}\label{namespaceprism_a0a166bbf645cc854542cc0fc50324670}
Allows an instance of \hyperlink{classprism_1_1_string}{String} to be written to the ostream and returns a reference to the ostream. \index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(const Deque$<$ T, T\+\_\+\+Alloc $>$ \&rhs)}{operator<<(const Deque< T, T_Alloc > &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Deque}$<$T, T\+\_\+\+Alloc$>$\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Deque}$<$ T, T\+\_\+\+Alloc $>$ \&}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a602c194731bf182cf114b7d297bbff51}{}\label{namespaceprism_a602c194731bf182cf114b7d297bbff51}
\index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(const T \&value)}{operator<<(const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Deque}$<$T, T\+\_\+\+Alloc$>$\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a40203d2e776fe0acf317a98ef08f8be7}{}\label{namespaceprism_a40203d2e776fe0acf317a98ef08f8be7}
\index{prism@{prism}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&out, const Deque$<$ T, T\+\_\+\+Alloc $>$ \&d)}{operator<<(std::ostream &out, const Deque< T, T_Alloc > &d)}}]{\setlength{\rightskip}{0pt plus 5cm}friend std\+::ostream\& prism\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Deque}$<$ T, T\+\_\+\+Alloc $>$ \&}]{d}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a554e40f4cee7980e001683ea75b16cd9}{}\label{namespaceprism_a554e40f4cee7980e001683ea75b16cd9}
\index{prism@{prism}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$<$=(const Char \&c1, const Char \&c2)}{operator<=(const Char &c1, const Char &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$<$= (
\begin{DoxyParamCaption}
\item[{const {\bf Char} \&}]{c1, }
\item[{const {\bf Char} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a87d86e9266469c8a40537e12a560b066}{}\label{namespaceprism_a87d86e9266469c8a40537e12a560b066}
\begin{DoxyReturn}{Returns}
Returns true if the unicode value of {\itshape c1} is less than or equal to {\itshape c2}, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator=@{operator=}}
\index{operator=@{operator=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator=(const Deque$<$ T, T\+\_\+\+Alloc $>$ \&rhs)}{operator=(const Deque< T, T_Alloc > &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Deque}$<$T, T\+\_\+\+Alloc$>$\& prism\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Deque}$<$ T, T\+\_\+\+Alloc $>$ \&}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab5a3ba3d60ef11974d02f7941fa9a263}{}\label{namespaceprism_ab5a3ba3d60ef11974d02f7941fa9a263}
\index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Char \&c1, const Char \&c2)}{operator==(const Char &c1, const Char &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Char} \&}]{c1, }
\item[{const {\bf Char} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1ba68b64a6cfdcff9e144b8c2476cddb}{}\label{namespaceprism_a1ba68b64a6cfdcff9e144b8c2476cddb}
\begin{DoxyReturn}{Returns}
Returns true if the chars {\itshape c1} and {\itshape c2} are equal, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Pointf \&p1, const Pointf \&p2)}{operator==(const Pointf &p1, const Pointf &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Pointf} \&}]{p1, }
\item[{const {\bf Pointf} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a13ab889958edc08eea9a5bea056cd9c1}{}\label{namespaceprism_a13ab889958edc08eea9a5bea056cd9c1}
Returns true if x and y of p1 and p2 are equal, false if not \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Size \&s1, const Size \&s2)}{operator==(const Size &s1, const Size &s2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Size} \&}]{s1, }
\item[{const {\bf Size} \&}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2a7baeb09cd2ee29251667ad18a2bd00}{}\label{namespaceprism_a2a7baeb09cd2ee29251667ad18a2bd00}
========================================================== \subsection*{Related non-\/members }

Returns true if the widths are equal and the heights are equal of both \hyperlink{classprism_1_1_size}{Size} objects. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Shared\+Pointer$<$ U $>$ \&p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator==(const SharedPointer< U > &p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae53d52e8a36ec7ca58ea1731cc18f1d8}{}\label{namespaceprism_ae53d52e8a36ec7ca58ea1731cc18f1d8}
Returns true if the managed pointers of p1 and p2 point to the same data, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Shared\+Pointer$<$ U $>$ \&p1, const U $\ast$p2)}{operator==(const SharedPointer< U > &p1, const U *p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p1, }
\item[{const U $\ast$}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2b73e87f080646696ed6b595a3900119}{}\label{namespaceprism_a2b73e87f080646696ed6b595a3900119}
Returns true if the managed pointer of p1 and the raw pointer p2 point to the same data, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Fraction \&f1, const Fraction \&f2)}{operator==(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5b9e84008b9eaa99d29d4b74cd150cd8}{}\label{namespaceprism_a5b9e84008b9eaa99d29d4b74cd150cd8}
Returns true if /em f1 and /em f2 are equal in value. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const U $\ast$p1, const Shared\+Pointer$<$ U $>$ \&p2)}{operator==(const U *p1, const SharedPointer< U > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class U $>$ const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const U $\ast$}]{p1, }
\item[{const {\bf Shared\+Pointer}$<$ U $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1f29b22985dc0ec1fc548a551ce313ed}{}\label{namespaceprism_a1f29b22985dc0ec1fc548a551ce313ed}
Returns true if the raw pointer p1 and the managed pointer of p2 point to the same data, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Point \&p1, const Point \&p2)}{operator==(const Point &p1, const Point &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Point} \&}]{p1, }
\item[{const {\bf Point} \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a739baa4e75c1ca83624d486eec1d45e9}{}\label{namespaceprism_a739baa4e75c1ca83624d486eec1d45e9}
Returns true if x and y of p1 and p2 are equal, false if not \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Vector2 \&a, const Vector2 \&b)}{operator==(const Vector2 &a, const Vector2 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Vector2} \&}]{a, }
\item[{const {\bf Vector2} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a311fc983ec89876189643e840d781974}{}\label{namespaceprism_a311fc983ec89876189643e840d781974}
Compares the two vectors and if each of the corresponding components are equal in value then true is returned, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Vector4 \&a, const Vector4 \&b)}{operator==(const Vector4 &a, const Vector4 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Vector4} \&}]{a, }
\item[{const {\bf Vector4} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a80bdef743a64c754bf1a2b217c82f60a}{}\label{namespaceprism_a80bdef743a64c754bf1a2b217c82f60a}
Compares the two vectors and if each of the corresponding components are equal in value then true is returned, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Vector3 \&a, const Vector3 \&b)}{operator==(const Vector3 &a, const Vector3 &b)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Vector3} \&}]{a, }
\item[{const {\bf Vector3} \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2fc2a483f2e3ec622ad2c0ac9699fbcb}{}\label{namespaceprism_a2fc2a483f2e3ec622ad2c0ac9699fbcb}
Compares the two vectors and if each of the corresponding components are equal in value then true is returned, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Quaternion \&q1, const Quaternion \&q2)}{operator==(const Quaternion &q1, const Quaternion &q2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Quaternion} \&}]{q1, }
\item[{const {\bf Quaternion} \&}]{q2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ac4ae112433b9ab32c801cccc9c3f74f0}{}\label{namespaceprism_ac4ae112433b9ab32c801cccc9c3f74f0}
Compares q1 and q2 and returns true if they are equal, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Bitvector \&bv1, const Bitvector \&bv2)}{operator==(const Bitvector &bv1, const Bitvector &bv2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Bitvector} \&}]{bv1, }
\item[{const {\bf Bitvector} \&}]{bv2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aca036c7f0f8a5aaf98b46b4879189bcc}{}\label{namespaceprism_aca036c7f0f8a5aaf98b46b4879189bcc}
\begin{DoxyReturn}{Returns}
Returns true if the two Bitvectors are equal to each other, false otherwise. The Bitvectors are considered equal if they are the same size and each corresponding bit is set to the same value. 
\end{DoxyReturn}
\index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Circle \&c1, const Circle \&c2)}{operator==(const Circle &c1, const Circle &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Circle} \&}]{c1, }
\item[{const {\bf Circle} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a0ce1ad6e6392618212d5ab3bebb8e585}{}\label{namespaceprism_a0ce1ad6e6392618212d5ab3bebb8e585}
\begin{DoxyReturn}{Returns}
Returns true if both circles have the same radius and (x,y) centre point, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Rect \&r1, const Rect \&r2)}{operator==(const Rect &r1, const Rect &r2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Rect} \&}]{r1, }
\item[{const {\bf Rect} \&}]{r2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_abe409fa2ef458a2d477ed7845cf4b6a6}{}\label{namespaceprism_abe409fa2ef458a2d477ed7845cf4b6a6}
===================================================================== \subsection*{Related non-\/members }

Returns true if the rectangles {\itshape r1} and {\itshape r2} are equal, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Matrix4 \&m1, const Matrix4 \&m2)}{operator==(const Matrix4 &m1, const Matrix4 &m2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Matrix4} \&}]{m1, }
\item[{const {\bf Matrix4} \&}]{m2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8804ec2ab8dda9441d64e947f05e293c}{}\label{namespaceprism_a8804ec2ab8dda9441d64e947f05e293c}
Compares the elements of the two matrices and returns true if they contain the same data, false otherwise. \index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const String \&str1, const String \&str2)}{operator==(const String &str1, const String &str2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf String} \&}]{str1, }
\item[{const {\bf String} \&}]{str2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a0e7bfee93ae735b5af7e566ddd8c4f65}{}\label{namespaceprism_a0e7bfee93ae735b5af7e566ddd8c4f65}
\index{prism@{prism}!operator==@{operator==}}
\index{operator==@{operator==}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator==(const Deque$<$ T, T\+\_\+\+Alloc $>$ \&rhs)}{operator==(const Deque< T, T_Alloc > &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Deque}$<$ T, T\+\_\+\+Alloc $>$ \&}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a47eb78b48fe05bc2087a1c5e70f4c373}{}\label{namespaceprism_a47eb78b48fe05bc2087a1c5e70f4c373}
\index{prism@{prism}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$>$(const Char \&c1, const Char \&c2)}{operator>(const Char &c1, const Char &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{const {\bf Char} \&}]{c1, }
\item[{const {\bf Char} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab8a312729c4c9ae72836d0034a6f0758}{}\label{namespaceprism_ab8a312729c4c9ae72836d0034a6f0758}
\begin{DoxyReturn}{Returns}
Returns true if the unicode value of {\itshape c1} is greater than {\itshape c2}, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$>$(const Fraction \&f1, const Fraction \&f2)}{operator>(const Fraction &f1, const Fraction &f2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{const {\bf Fraction} \&}]{f1, }
\item[{const {\bf Fraction} \&}]{f2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7122a7ff43fc6aba9cef9d31fe8c7559}{}\label{namespaceprism_a7122a7ff43fc6aba9cef9d31fe8c7559}
Returns true if /em f1 is less than /em f2, false otherwise. \index{prism@{prism}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$>$(const Circle \&c1, const Circle \&c2)}{operator>(const Circle &c1, const Circle &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{const {\bf Circle} \&}]{c1, }
\item[{const {\bf Circle} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a671739ac8567654dba563c34af92213f}{}\label{namespaceprism_a671739ac8567654dba563c34af92213f}
\begin{DoxyReturn}{Returns}
Returns true if {\itshape c1} has a greater radius than {\itshape c2}, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$>$=(const Char \&c1, const Char \&c2)}{operator>=(const Char &c1, const Char &c2)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::operator$>$= (
\begin{DoxyParamCaption}
\item[{const {\bf Char} \&}]{c1, }
\item[{const {\bf Char} \&}]{c2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aad049ddef9beb3fec3e7057a7f651280}{}\label{namespaceprism_aad049ddef9beb3fec3e7057a7f651280}
\begin{DoxyReturn}{Returns}
Returns true if the unicode value of {\itshape c1} is greater than or equal to {\itshape c2}, false otherwise. 
\end{DoxyReturn}
\index{prism@{prism}!operator\mbox{[}$\,$\mbox{]}@{operator[]}}
\index{operator\mbox{[}$\,$\mbox{]}@{operator[]}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator[](const int i)}{operator[](const int i)}}]{\setlength{\rightskip}{0pt plus 5cm}const\+\_\+reference prism\+::operator\mbox{[}$\,$\mbox{]} (
\begin{DoxyParamCaption}
\item[{const int}]{i}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae5cdc796ecf7df67ce6377bfe9eadb7c}{}\label{namespaceprism_ae5cdc796ecf7df67ce6377bfe9eadb7c}
\begin{DoxyReturn}{Returns}
Returns a reference to the element at index {\itshape i}. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Note that no bounds checking is performed on {\itshape i}.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
Returns a const reference to the element at index {\itshape i}. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Note that no bounds checking is performed on {\itshape i}. 
\end{DoxyNote}
\index{prism@{prism}!operator$^\wedge$@{operator$^\wedge$}}
\index{operator$^\wedge$@{operator$^\wedge$}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator$^\wedge$(const Bitvector \&bv1, const Bitvector \&bv2)}{operator^(const Bitvector &bv1, const Bitvector &bv2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Bitvector} prism\+::operator$^\wedge$ (
\begin{DoxyParamCaption}
\item[{const {\bf Bitvector} \&}]{bv1, }
\item[{const {\bf Bitvector} \&}]{bv2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6a18ff84f30ae8056d6807056a24ef14}{}\label{namespaceprism_a6a18ff84f30ae8056d6807056a24ef14}
Performs a bitwise X\+OR on {\itshape bv1} and {\itshape bv2}. \begin{DoxyReturn}{Returns}
Returns a new \hyperlink{classprism_1_1_bitvector}{Bitvector} with the result of {\itshape }(bv1 $^\wedge$ bv2). 
\end{DoxyReturn}
\index{prism@{prism}!operator\texttt{"|}@{operator\texttt{"|}}}
\index{operator\texttt{"|}@{operator\texttt{"|}}!prism@{prism}}
\subsubsection[{\texorpdfstring{operator\texttt{"|}(const Bitvector \&bv1, const Bitvector \&bv2)}{operator|(const Bitvector &bv1, const Bitvector &bv2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Bitvector} prism\+::operator$\vert$ (
\begin{DoxyParamCaption}
\item[{const {\bf Bitvector} \&}]{bv1, }
\item[{const {\bf Bitvector} \&}]{bv2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a145d1e196c14cdbdc4eccb01c60c9275}{}\label{namespaceprism_a145d1e196c14cdbdc4eccb01c60c9275}
Performs a bitwise OR on {\itshape bv1} and {\itshape bv2}. \begin{DoxyReturn}{Returns}
Returns a new \hyperlink{classprism_1_1_bitvector}{Bitvector} with the result of {\itshape }(bv1 $\vert$ bv2). 
\end{DoxyReturn}
\index{prism@{prism}!p\+\_\+heapify@{p\+\_\+heapify}}
\index{p\+\_\+heapify@{p\+\_\+heapify}!prism@{prism}}
\subsubsection[{\texorpdfstring{p\+\_\+heapify(\+Random\+Access\+Iterator node, Random\+Access\+Iterator first, Random\+Access\+Iterator last)}{p_heapify(RandomAccessIterator node, RandomAccessIterator first, RandomAccessIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Random\+Access\+Iterator $>$ void prism\+::p\+\_\+heapify (
\begin{DoxyParamCaption}
\item[{Random\+Access\+Iterator}]{node, }
\item[{Random\+Access\+Iterator}]{first, }
\item[{Random\+Access\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5f2c83ae0d89a6581d1c42ba6fd79de0}{}\label{namespaceprism_a5f2c83ae0d89a6581d1c42ba6fd79de0}
\index{prism@{prism}!p\+\_\+heapify\+\_\+aux@{p\+\_\+heapify\+\_\+aux}}
\index{p\+\_\+heapify\+\_\+aux@{p\+\_\+heapify\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{p\+\_\+heapify\+\_\+aux(\+Random\+Access\+Iterator node, Random\+Access\+Iterator first, Random\+Access\+Iterator last)}{p_heapify_aux(RandomAccessIterator node, RandomAccessIterator first, RandomAccessIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Random\+Access\+Iterator $>$ void prism\+::p\+\_\+heapify\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Random\+Access\+Iterator}]{node, }
\item[{Random\+Access\+Iterator}]{first, }
\item[{Random\+Access\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a95d95c728950cef3542d8b1dd27eb344}{}\label{namespaceprism_a95d95c728950cef3542d8b1dd27eb344}
Private recursive function called by \hyperlink{namespaceprism_a567b63d0d3fa2bc8bdba883f152848be}{make\+\_\+heap\+\_\+aux()}. Compares a node with its two children (if it has any) and ensures that the largest of the three nodes is the parent node. \index{prism@{prism}!pop\+\_\+back@{pop\+\_\+back}}
\index{pop\+\_\+back@{pop\+\_\+back}!prism@{prism}}
\subsubsection[{\texorpdfstring{pop\+\_\+back()}{pop_back()}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::pop\+\_\+back (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a682dc15d5493595804b4cf818b16281d}{}\label{namespaceprism_a682dc15d5493595804b4cf818b16281d}
\index{prism@{prism}!pop\+\_\+front@{pop\+\_\+front}}
\index{pop\+\_\+front@{pop\+\_\+front}!prism@{prism}}
\subsubsection[{\texorpdfstring{pop\+\_\+front()}{pop_front()}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::pop\+\_\+front (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a407f71f548b4930e7880b44cd695b33d}{}\label{namespaceprism_a407f71f548b4930e7880b44cd695b33d}
\index{prism@{prism}!prepend@{prepend}}
\index{prepend@{prepend}!prism@{prism}}
\subsubsection[{\texorpdfstring{prepend(const T \&value)}{prepend(const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::prepend (
\begin{DoxyParamCaption}
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ac5a9a7c94d57bb61f25a61ef10d74b80}{}\label{namespaceprism_ac5a9a7c94d57bb61f25a61ef10d74b80}
\index{prism@{prism}!push\+\_\+back@{push\+\_\+back}}
\index{push\+\_\+back@{push\+\_\+back}!prism@{prism}}
\subsubsection[{\texorpdfstring{push\+\_\+back(const T \&value)}{push_back(const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::push\+\_\+back (
\begin{DoxyParamCaption}
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aae03a861ef55e15b5a64c5cb2a727667}{}\label{namespaceprism_aae03a861ef55e15b5a64c5cb2a727667}
\index{prism@{prism}!push\+\_\+front@{push\+\_\+front}}
\index{push\+\_\+front@{push\+\_\+front}!prism@{prism}}
\subsubsection[{\texorpdfstring{push\+\_\+front(const T \&value)}{push_front(const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::push\+\_\+front (
\begin{DoxyParamCaption}
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9a451a8db591d6c4fc315b05f9bff515}{}\label{namespaceprism_a9a451a8db591d6c4fc315b05f9bff515}
\index{prism@{prism}!remove@{remove}}
\index{remove@{remove}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove(\+Forward\+Iterator first, Forward\+Iterator last, const T \&value)}{remove(ForwardIterator first, ForwardIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ Forward\+Iterator prism\+::remove (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aeddd21943bcf811c56f7d9d1bd4784f6}{}\label{namespaceprism_aeddd21943bcf811c56f7d9d1bd4784f6}
Transforms the range {\itshape }\mbox{[}first,last\mbox{]} into a range with all the elements that compare equal to {\itshape value} removed, and returns an iterator to the new end of that range. \index{prism@{prism}!remove@{remove}}
\index{remove@{remove}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove(const int index)}{remove(const int index)}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::remove (
\begin{DoxyParamCaption}
\item[{const int}]{index}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5b180b06c92cd65b70d2e565878e5d06}{}\label{namespaceprism_a5b180b06c92cd65b70d2e565878e5d06}
\index{prism@{prism}!remove@{remove}}
\index{remove@{remove}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove(const int index, const int count)}{remove(const int index, const int count)}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::remove (
\begin{DoxyParamCaption}
\item[{const int}]{index, }
\item[{const int}]{count}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2a67eb6dd63f426b2837aebb07940b0b}{}\label{namespaceprism_a2a67eb6dd63f426b2837aebb07940b0b}
\index{prism@{prism}!remove\+\_\+aux@{remove\+\_\+aux}}
\index{remove\+\_\+aux@{remove\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+\_\+aux(\+Forward\+Iterator first, Forward\+Iterator last, const T \&value)}{remove_aux(ForwardIterator first, ForwardIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ Forward\+Iterator prism\+::remove\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_acb7d8d4b86592081686e15ee7a18f856}{}\label{namespaceprism_acb7d8d4b86592081686e15ee7a18f856}
Transforms the range {\itshape }\mbox{[}first,last\mbox{]} into a range with all the elements that compare equal to {\itshape value} removed, and returns an iterator to the new end of that range. \index{prism@{prism}!remove\+\_\+copy@{remove\+\_\+copy}}
\index{remove\+\_\+copy@{remove\+\_\+copy}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+\_\+copy(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, const T \&value)}{remove_copy(InputIterator first, InputIterator last, OutputIterator otherFirst, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ Output\+Iterator prism\+::remove\+\_\+copy (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab7b6fb407340e51749169560b48fb20c}{}\label{namespaceprism_ab7b6fb407340e51749169560b48fb20c}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} to the range beginning at {\itshape other\+First}, except those elements that compare equal to {\itshape value}. \index{prism@{prism}!remove\+\_\+copy\+\_\+aux@{remove\+\_\+copy\+\_\+aux}}
\index{remove\+\_\+copy\+\_\+aux@{remove\+\_\+copy\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+\_\+copy\+\_\+aux(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, const T \&value)}{remove_copy_aux(InputIterator first, InputIterator last, OutputIterator otherFirst, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ Output\+Iterator prism\+::remove\+\_\+copy\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ae3f41bf6d9ab98a87d693fba69f138dc}{}\label{namespaceprism_ae3f41bf6d9ab98a87d693fba69f138dc}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} to the range beginning at {\itshape other\+First}, except those elements that compare equal to {\itshape value}. \index{prism@{prism}!remove\+\_\+copy\+\_\+if@{remove\+\_\+copy\+\_\+if}}
\index{remove\+\_\+copy\+\_\+if@{remove\+\_\+copy\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+\_\+copy\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Unary\+Predicate pred)}{remove_copy_if(InputIterator first, InputIterator last, OutputIterator otherFirst, UnaryPredicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class Unary\+Predicate $>$ Output\+Iterator prism\+::remove\+\_\+copy\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{Unary\+Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_abfc7da1f951e480a26d58fc098b78844}{}\label{namespaceprism_abfc7da1f951e480a26d58fc098b78844}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} to the range beginning at {\itshape other\+First}, except those elements for which {\itshape pred} returns true. \index{prism@{prism}!remove\+\_\+copy\+\_\+if\+\_\+aux@{remove\+\_\+copy\+\_\+if\+\_\+aux}}
\index{remove\+\_\+copy\+\_\+if\+\_\+aux@{remove\+\_\+copy\+\_\+if\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+\_\+copy\+\_\+if\+\_\+aux(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Unary\+Predicate pred)}{remove_copy_if_aux(InputIterator first, InputIterator last, OutputIterator otherFirst, UnaryPredicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class Unary\+Predicate $>$ Output\+Iterator prism\+::remove\+\_\+copy\+\_\+if\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{Unary\+Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a198b599ea535deb9fdf28c46c8658bd4}{}\label{namespaceprism_a198b599ea535deb9fdf28c46c8658bd4}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} to the range beginning at {\itshape other\+First}, except those elements for which {\itshape pred} returns true. \index{prism@{prism}!remove\+\_\+if@{remove\+\_\+if}}
\index{remove\+\_\+if@{remove\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+\_\+if(\+Forward\+Iterator first, Forward\+Iterator last, Predicate pred)}{remove_if(ForwardIterator first, ForwardIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class Predicate $>$ Forward\+Iterator prism\+::remove\+\_\+if (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a2e9d25191ed83ea0a193f16d9c0a00b7}{}\label{namespaceprism_a2e9d25191ed83ea0a193f16d9c0a00b7}
Transforms the range {\itshape }\mbox{[}first,last\mbox{]} into a range with all the elements for which {\itshape pred} returns true removed, and returns an iterator to the new end of that range. \index{prism@{prism}!remove\+\_\+if\+\_\+aux@{remove\+\_\+if\+\_\+aux}}
\index{remove\+\_\+if\+\_\+aux@{remove\+\_\+if\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+\_\+if\+\_\+aux(\+Forward\+Iterator first, Forward\+Iterator last, Predicate pred)}{remove_if_aux(ForwardIterator first, ForwardIterator last, Predicate pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class Predicate $>$ Forward\+Iterator prism\+::remove\+\_\+if\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{Predicate}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a95e9f5186670e27472aa7d8cd02397eb}{}\label{namespaceprism_a95e9f5186670e27472aa7d8cd02397eb}
Transforms the range {\itshape }\mbox{[}first,last\mbox{]} into a range with all the elements for which {\itshape pred} returns true removed, and returns an iterator to the new end of that range. \index{prism@{prism}!remove\+All@{remove\+All}}
\index{remove\+All@{remove\+All}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+All(const T \&value)}{removeAll(const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::remove\+All (
\begin{DoxyParamCaption}
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a91a96073d835746d48ba0a145c33b29e}{}\label{namespaceprism_a91a96073d835746d48ba0a145c33b29e}
\index{prism@{prism}!remove\+First@{remove\+First}}
\index{remove\+First@{remove\+First}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+First()}{removeFirst()}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::remove\+First (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a32a0d96bc03a45529e399cd39c48cb66}{}\label{namespaceprism_a32a0d96bc03a45529e399cd39c48cb66}
\index{prism@{prism}!remove\+Last@{remove\+Last}}
\index{remove\+Last@{remove\+Last}!prism@{prism}}
\subsubsection[{\texorpdfstring{remove\+Last()}{removeLast()}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::remove\+Last (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7dd774edd9e5b7398334440070da6bdd}{}\label{namespaceprism_a7dd774edd9e5b7398334440070da6bdd}
\index{prism@{prism}!replace@{replace}}
\index{replace@{replace}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace(\+Forward\+Iterator first, Forward\+Iterator last, const T \&old\+Value, const T \&new\+Value)}{replace(ForwardIterator first, ForwardIterator last, const T &oldValue, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::replace (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{const T \&}]{old\+Value, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6156070b98de7130b8c912ae3a6d333f}{}\label{namespaceprism_a6156070b98de7130b8c912ae3a6d333f}
Assigns {\itshape new\+Value} to all the elements in the range {\itshape }\mbox{[}first,last\mbox{]} that compare equal to {\itshape old\+Value}. \index{prism@{prism}!replace@{replace}}
\index{replace@{replace}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace(const int index, const T \&value)}{replace(const int index, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::replace (
\begin{DoxyParamCaption}
\item[{const int}]{index, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_acac76605957b60675b2859cef694c61f}{}\label{namespaceprism_acac76605957b60675b2859cef694c61f}
\index{prism@{prism}!replace\+\_\+aux@{replace\+\_\+aux}}
\index{replace\+\_\+aux@{replace\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace\+\_\+aux(\+Forward\+Iterator first, Forward\+Iterator last, const T \&old\+Value, const T \&new\+Value)}{replace_aux(ForwardIterator first, ForwardIterator last, const T &oldValue, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::replace\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{const T \&}]{old\+Value, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad053e45daef65797bc1cff18dfcd8dc0}{}\label{namespaceprism_ad053e45daef65797bc1cff18dfcd8dc0}
Assigns {\itshape new\+Value} to all the elements in the range {\itshape }\mbox{[}first,last\mbox{]} that compare equal to {\itshape old\+Value}. \index{prism@{prism}!replace\+\_\+copy@{replace\+\_\+copy}}
\index{replace\+\_\+copy@{replace\+\_\+copy}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace\+\_\+copy(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, const T \&old\+Value, const T \&new\+Value)}{replace_copy(InputIterator first, InputIterator last, OutputIterator otherFirst, const T &oldValue, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ Output\+Iterator prism\+::replace\+\_\+copy (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{const T \&}]{old\+Value, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a16d85ecb70d2f216714a0146a057a105}{}\label{namespaceprism_a16d85ecb70d2f216714a0146a057a105}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} to the range beginning at {\itshape other\+First}, replacing the appearances of {\itshape old\+Value} by {\itshape new\+Value}. \index{prism@{prism}!replace\+\_\+copy\+\_\+aux@{replace\+\_\+copy\+\_\+aux}}
\index{replace\+\_\+copy\+\_\+aux@{replace\+\_\+copy\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace\+\_\+copy\+\_\+aux(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, const T \&old\+Value, const T \&new\+Value)}{replace_copy_aux(InputIterator first, InputIterator last, OutputIterator otherFirst, const T &oldValue, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class T $>$ Output\+Iterator prism\+::replace\+\_\+copy\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{const T \&}]{old\+Value, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7055d91bb6279fa78b8b498297a11eab}{}\label{namespaceprism_a7055d91bb6279fa78b8b498297a11eab}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} to the range beginning at {\itshape other\+First}, replacing the appearances of {\itshape old\+Value} by {\itshape new\+Value}. \index{prism@{prism}!replace\+\_\+copy\+\_\+if@{replace\+\_\+copy\+\_\+if}}
\index{replace\+\_\+copy\+\_\+if@{replace\+\_\+copy\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace\+\_\+copy\+\_\+if(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Predicate pred, const T \&new\+Value)}{replace_copy_if(InputIterator first, InputIterator last, OutputIterator otherFirst, Predicate pred, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class Predicate , class T $>$ Output\+Iterator prism\+::replace\+\_\+copy\+\_\+if (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{Predicate}]{pred, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a55d702599739f7137516dcd095119f15}{}\label{namespaceprism_a55d702599739f7137516dcd095119f15}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} to the range beginning at {\itshape other\+First}, replacing those for which {\itshape pred} returns true by new\+Value. \index{prism@{prism}!replace\+\_\+copy\+\_\+if\+\_\+aux@{replace\+\_\+copy\+\_\+if\+\_\+aux}}
\index{replace\+\_\+copy\+\_\+if\+\_\+aux@{replace\+\_\+copy\+\_\+if\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace\+\_\+copy\+\_\+if\+\_\+aux(\+Input\+Iterator first, Input\+Iterator last, Output\+Iterator other\+First, Predicate pred, const T \&new\+Value)}{replace_copy_if_aux(InputIterator first, InputIterator last, OutputIterator otherFirst, Predicate pred, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Input\+Iterator , class Output\+Iterator , class Predicate , class T $>$ Output\+Iterator prism\+::replace\+\_\+copy\+\_\+if\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Input\+Iterator}]{first, }
\item[{Input\+Iterator}]{last, }
\item[{Output\+Iterator}]{other\+First, }
\item[{Predicate}]{pred, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1e660997b10ccb0985b35999c84a9bbf}{}\label{namespaceprism_a1e660997b10ccb0985b35999c84a9bbf}
Copies the elements in the range {\itshape }\mbox{[}first,last\mbox{]} to the range beginning at {\itshape other\+First}, replacing those for which {\itshape pred} returns true by new\+Value. \index{prism@{prism}!replace\+\_\+if@{replace\+\_\+if}}
\index{replace\+\_\+if@{replace\+\_\+if}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace\+\_\+if(\+Forward\+Iterator first, Forward\+Iterator last, Predicate pred, const T \&new\+Value)}{replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class Predicate , class T $>$ void prism\+::replace\+\_\+if (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{Predicate}]{pred, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af118c19f6b5448319eb3aaf2d556ac54}{}\label{namespaceprism_af118c19f6b5448319eb3aaf2d556ac54}
Assigns {\itshape new\+Value} to all the elements in the range {\itshape }\mbox{[}first,last\mbox{]} for which {\itshape pred} returns true. \index{prism@{prism}!replace\+\_\+if\+\_\+aux@{replace\+\_\+if\+\_\+aux}}
\index{replace\+\_\+if\+\_\+aux@{replace\+\_\+if\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{replace\+\_\+if\+\_\+aux(\+Forward\+Iterator first, Forward\+Iterator last, Predicate pred, const T \&new\+Value)}{replace_if_aux(ForwardIterator first, ForwardIterator last, Predicate pred, const T &newValue)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class Predicate , class T $>$ void prism\+::replace\+\_\+if\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{Predicate}]{pred, }
\item[{const T \&}]{new\+Value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad23d44d30470aed0ee16e931514bd727}{}\label{namespaceprism_ad23d44d30470aed0ee16e931514bd727}
Assigns {\itshape new\+Value} to all the elements in the range {\itshape }\mbox{[}first,last\mbox{]} for which {\itshape pred} returns true. \index{prism@{prism}!resize@{resize}}
\index{resize@{resize}!prism@{prism}}
\subsubsection[{\texorpdfstring{resize(const int new\+Size, const T \&value=\+T())}{resize(const int newSize, const T &value=T())}}]{\setlength{\rightskip}{0pt plus 5cm}void prism\+::resize (
\begin{DoxyParamCaption}
\item[{const int}]{new\+Size, }
\item[{const T \&}]{value = {\ttfamily T()}}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7236cdb4e2661bd63c2fe4ee5c3452f9}{}\label{namespaceprism_a7236cdb4e2661bd63c2fe4ee5c3452f9}
\index{prism@{prism}!search@{search}}
\index{search@{search}!prism@{prism}}
\subsubsection[{\texorpdfstring{search(\+Forward\+Iterator1 first, Forward\+Iterator1 last, Forward\+Iterator2 other\+First, Forward\+Iterator2 other\+Last)}{search(ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 otherFirst, ForwardIterator2 otherLast)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ Forward\+Iterator1 prism\+::search (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator1}]{first, }
\item[{Forward\+Iterator1}]{last, }
\item[{Forward\+Iterator2}]{other\+First, }
\item[{Forward\+Iterator2}]{other\+Last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a03dbb806369b062fd90909fd826c2ee4}{}\label{namespaceprism_a03dbb806369b062fd90909fd826c2ee4}
Searches the range \mbox{[}first1,last1\mbox{]} for the first occurrence of the sequence defined by \mbox{[}first2,last2\mbox{]}, and returns an iterator to its first element, or last1 if no occurrences are found. The range used is \mbox{[}first1,last1\mbox{]}, which contains all the elements between first1 and last1, including the element pointed by first1 but not the element pointed by last1. \index{prism@{prism}!search\+\_\+aux@{search\+\_\+aux}}
\index{search\+\_\+aux@{search\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{search\+\_\+aux(\+Forward\+Iterator1 first1, Forward\+Iterator1 last1, Forward\+Iterator2 first2, Forward\+Iterator2 last2)}{search_aux(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ Forward\+Iterator1 prism\+::search\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator1}]{first1, }
\item[{Forward\+Iterator1}]{last1, }
\item[{Forward\+Iterator2}]{first2, }
\item[{Forward\+Iterator2}]{last2}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab6f8ed8b450ff281e02218e10d5643a7}{}\label{namespaceprism_ab6f8ed8b450ff281e02218e10d5643a7}
Searches the range \mbox{[}first1,last1\mbox{]} for the first occurrence of the sequence defined by \mbox{[}first2,last2\mbox{]}, and returns an iterator to its first element, or last1 if no occurrences are found. The range used is \mbox{[}first1,last1\mbox{]}, which contains all the elements between first1 and last1, including the element pointed by first1 but not the element pointed by last1. \index{prism@{prism}!size@{size}}
\index{size@{size}!prism@{prism}}
\subsubsection[{\texorpdfstring{size() const }{size() const }}]{\setlength{\rightskip}{0pt plus 5cm}const int prism\+::size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_acd3c0f96adf158a29387191d79c4d874}{}\label{namespaceprism_acd3c0f96adf158a29387191d79c4d874}
\begin{DoxyReturn}{Returns}
Returns the number of elements currently in the Deque. 
\end{DoxyReturn}
\index{prism@{prism}!sort@{sort}}
\index{sort@{sort}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort(\+Forward\+Iterator first, Forward\+Iterator last)}{sort(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ void prism\+::sort (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9bf397cad0a67b67fbd1ecddf40d405e}{}\label{namespaceprism_a9bf397cad0a67b67fbd1ecddf40d405e}
Sorts the elements in the range {\itshape }\mbox{[}first,last\mbox{]} in ascending order using the quicksort algorithm. The range used is \mbox{[}first1,last1\mbox{]}, which contains all the elements between first1 and last1, including the element pointed by first1 but not the element pointed by last1. ~\newline
Currently {\itshape \hyperlink{namespaceprism_a9bf397cad0a67b67fbd1ecddf40d405e}{sort()}} is implemented using the quicksort algorithm which averages a reasonable O(n log(n)) complexity. \index{prism@{prism}!sort\+\_\+aux@{sort\+\_\+aux}}
\index{sort\+\_\+aux@{sort\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort\+\_\+aux(\+Forward\+Iterator first, Forward\+Iterator last)}{sort_aux(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ void prism\+::sort\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a9e7b2f97895db323cbefbc4af311ccb9}{}\label{namespaceprism_a9e7b2f97895db323cbefbc4af311ccb9}
Sorts the elements in the range {\itshape }\mbox{[}first,last\mbox{]} in ascending order using the quicksort algorithm. The range used is \mbox{[}first1,last1\mbox{]}, which contains all the elements between first1 and last1, including the element pointed by first1 but not the element pointed by last1. ~\newline
Currently {\itshape \hyperlink{namespaceprism_a9bf397cad0a67b67fbd1ecddf40d405e}{sort()}} is implemented using the quicksort algorithm which averages a reasonable O(n log(n)) complexity. \index{prism@{prism}!sort\+\_\+bubble@{sort\+\_\+bubble}}
\index{sort\+\_\+bubble@{sort\+\_\+bubble}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort\+\_\+bubble(\+Random\+Access\+Iterator first, Random\+Access\+Iterator last)}{sort_bubble(RandomAccessIterator first, RandomAccessIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Random\+Access\+Iterator $>$ void prism\+::sort\+\_\+bubble (
\begin{DoxyParamCaption}
\item[{Random\+Access\+Iterator}]{first, }
\item[{Random\+Access\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa597d262eb2f9ef80703c883a2d18d1e}{}\label{namespaceprism_aa597d262eb2f9ef80703c883a2d18d1e}
Sorts the elements in the range {\itshape }\mbox{[}first, last\mbox{]} in ascending order using the Bubble Sort algorithm. ~\newline
The range used is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. \begin{DoxyNote}{Note}
The objects being sorted must support \hyperlink{namespaceprism_ab8a312729c4c9ae72836d0034a6f0758}{operator$>$()}. 
\end{DoxyNote}
\index{prism@{prism}!sort\+\_\+bubble\+\_\+aux@{sort\+\_\+bubble\+\_\+aux}}
\index{sort\+\_\+bubble\+\_\+aux@{sort\+\_\+bubble\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort\+\_\+bubble\+\_\+aux(\+Random\+Access\+Iterator first, Random\+Access\+Iterator last)}{sort_bubble_aux(RandomAccessIterator first, RandomAccessIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Random\+Access\+Iterator $>$ void prism\+::sort\+\_\+bubble\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Random\+Access\+Iterator}]{first, }
\item[{Random\+Access\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_af3a66e1051c4c7874f305ad2a5f0b37e}{}\label{namespaceprism_af3a66e1051c4c7874f305ad2a5f0b37e}
Sorts the elements in the range {\itshape }\mbox{[}first, last\mbox{]} in ascending order using the Bubble Sort algorithm. ~\newline
The range used is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. ~\newline
\begin{DoxyNote}{Note}
The objects being sorted must support \hyperlink{namespaceprism_ab8a312729c4c9ae72836d0034a6f0758}{operator$>$()}. 
\end{DoxyNote}
\index{prism@{prism}!sort\+\_\+heap@{sort\+\_\+heap}}
\index{sort\+\_\+heap@{sort\+\_\+heap}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort\+\_\+heap(\+Random\+Access\+Iterator first, Random\+Access\+Iterator last)}{sort_heap(RandomAccessIterator first, RandomAccessIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Random\+Access\+Iterator $>$ void prism\+::sort\+\_\+heap (
\begin{DoxyParamCaption}
\item[{Random\+Access\+Iterator}]{first, }
\item[{Random\+Access\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a1e9fe74c5dcee70bf5dd5c89f1234a02}{}\label{namespaceprism_a1e9fe74c5dcee70bf5dd5c89f1234a02}
Sorts the elements in the range {\itshape }\mbox{[}first,last\mbox{]} using the heapsort algorithm. ~\newline
The elements are first rearranged so that they satisfy the ordering of a heap (by a call to \hyperlink{namespaceprism_af8e36230e6cb92a41aaca282772a9e6e}{make\+\_\+heap()}).~\newline
The range used is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. \index{prism@{prism}!sort\+\_\+heap\+\_\+aux@{sort\+\_\+heap\+\_\+aux}}
\index{sort\+\_\+heap\+\_\+aux@{sort\+\_\+heap\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort\+\_\+heap\+\_\+aux(\+Random\+Access\+Iterator first, Random\+Access\+Iterator last)}{sort_heap_aux(RandomAccessIterator first, RandomAccessIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Random\+Access\+Iterator $>$ void prism\+::sort\+\_\+heap\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Random\+Access\+Iterator}]{first, }
\item[{Random\+Access\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ab289bdf7cde130b0aeea21a9711770f4}{}\label{namespaceprism_ab289bdf7cde130b0aeea21a9711770f4}
Sorts the elements in the range {\itshape }\mbox{[}first,last\mbox{]} using the heapsort algorithm. ~\newline
The elements are first rearranged so that they satisfy the ordering of a heap (by a call to \hyperlink{namespaceprism_af8e36230e6cb92a41aaca282772a9e6e}{make\+\_\+heap()}).~\newline
The range used is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. \index{prism@{prism}!sort\+\_\+quicksort@{sort\+\_\+quicksort}}
\index{sort\+\_\+quicksort@{sort\+\_\+quicksort}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort\+\_\+quicksort(\+Forward\+Iterator first, Forward\+Iterator last)}{sort_quicksort(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ void prism\+::sort\+\_\+quicksort (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a720fbbcb3f399b006969bb00a66686f9}{}\label{namespaceprism_a720fbbcb3f399b006969bb00a66686f9}
Sorts the elements in the range {\itshape }\mbox{[}first, last\mbox{]} in ascending order using the Quicksort algorithm. ~\newline
The range used is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. \begin{DoxyNote}{Note}
The objects being sorted must support \hyperlink{namespaceprism_a87d86e9266469c8a40537e12a560b066}{operator$<$=()}. 
\end{DoxyNote}
\index{prism@{prism}!sort\+\_\+quicksort\+\_\+aux@{sort\+\_\+quicksort\+\_\+aux}}
\index{sort\+\_\+quicksort\+\_\+aux@{sort\+\_\+quicksort\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{sort\+\_\+quicksort\+\_\+aux(\+Forward\+Iterator first, Forward\+Iterator last)}{sort_quicksort_aux(ForwardIterator first, ForwardIterator last)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator $>$ void prism\+::sort\+\_\+quicksort\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a46e0e235fa71938e5ebf29387b917057}{}\label{namespaceprism_a46e0e235fa71938e5ebf29387b917057}
Sorts the elements in the range {\itshape }\mbox{[}first, last\mbox{]} in ascending order using the Quicksort algorithm. ~\newline
The range used is {\itshape }\mbox{[}first,last\mbox{]}, which contains all the elements between {\itshape first} and {\itshape last}, including the element pointed by {\itshape first} but not the element pointed by {\itshape last}. \begin{DoxyNote}{Note}
The objects being sorted must support \hyperlink{namespaceprism_a87d86e9266469c8a40537e12a560b066}{operator$<$=()}. 
\end{DoxyNote}
\index{prism@{prism}!starts\+With@{starts\+With}}
\index{starts\+With@{starts\+With}!prism@{prism}}
\subsubsection[{\texorpdfstring{starts\+With(const T \&value) const }{startsWith(const T &value) const }}]{\setlength{\rightskip}{0pt plus 5cm}const bool prism\+::starts\+With (
\begin{DoxyParamCaption}
\item[{const T \&}]{value}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_a92e90ca54b9fa627213076f93d44ca2d}{}\label{namespaceprism_a92e90ca54b9fa627213076f93d44ca2d}
\index{prism@{prism}!swap@{swap}}
\index{swap@{swap}!prism@{prism}}
\subsubsection[{\texorpdfstring{swap(\+T \&a, T \&b)}{swap(T &a, T &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ void prism\+::swap (
\begin{DoxyParamCaption}
\item[{T \&}]{a, }
\item[{T \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6430516ab4f2e2a7f43323acb6b559d8}{}\label{namespaceprism_a6430516ab4f2e2a7f43323acb6b559d8}
Exchanges the values of {\itshape a} and {\itshape b}. \index{prism@{prism}!swap\+\_\+aux@{swap\+\_\+aux}}
\index{swap\+\_\+aux@{swap\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{swap\+\_\+aux(\+T \&a, T \&b)}{swap_aux(T &a, T &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ void prism\+::swap\+\_\+aux (
\begin{DoxyParamCaption}
\item[{T \&}]{a, }
\item[{T \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6d3a7129cc6ab5d9a80301436e4d2e48}{}\label{namespaceprism_a6d3a7129cc6ab5d9a80301436e4d2e48}
Exchanges the values of {\itshape a} and {\itshape b}. \index{prism@{prism}!swap\+\_\+ranges@{swap\+\_\+ranges}}
\index{swap\+\_\+ranges@{swap\+\_\+ranges}!prism@{prism}}
\subsubsection[{\texorpdfstring{swap\+\_\+ranges(\+Forward\+Iterator1 first, Forward\+Iterator1 last, Forward\+Iterator2 other\+First)}{swap_ranges(ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ Forward\+Iterator2 prism\+::swap\+\_\+ranges (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator1}]{first, }
\item[{Forward\+Iterator1}]{last, }
\item[{Forward\+Iterator2}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a4661f2c0c4dca098c137179b4d93f3dc}{}\label{namespaceprism_a4661f2c0c4dca098c137179b4d93f3dc}
Exchanges the values of each of the elements in the range {\itshape }\mbox{[}first1,last1\mbox{]} with those of their respective elements in the range beginning at {\itshape other\+First}. \index{prism@{prism}!swap\+\_\+ranges\+\_\+aux@{swap\+\_\+ranges\+\_\+aux}}
\index{swap\+\_\+ranges\+\_\+aux@{swap\+\_\+ranges\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{swap\+\_\+ranges\+\_\+aux(\+Forward\+Iterator1 first, Forward\+Iterator1 last, Forward\+Iterator2 other\+First)}{swap_ranges_aux(ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ Forward\+Iterator2 prism\+::swap\+\_\+ranges\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator1}]{first, }
\item[{Forward\+Iterator1}]{last, }
\item[{Forward\+Iterator2}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a7ca4ae3ad4c2e21d6fe48b6fae6930c3}{}\label{namespaceprism_a7ca4ae3ad4c2e21d6fe48b6fae6930c3}
Exchanges the values of each of the elements in the range {\itshape }\mbox{[}first1,last1\mbox{]} with those of their respective elements in the range beginning at {\itshape other\+First}. \index{prism@{prism}!to\+List@{to\+List}}
\index{to\+List@{to\+List}!prism@{prism}}
\subsubsection[{\texorpdfstring{to\+List() const }{toList() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$T$>$ prism\+::to\+List (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_a07654e91e7474a3ccdcd95bb5e57baea}{}\label{namespaceprism_a07654e91e7474a3ccdcd95bb5e57baea}
\index{prism@{prism}!to\+Std\+Deque@{to\+Std\+Deque}}
\index{to\+Std\+Deque@{to\+Std\+Deque}!prism@{prism}}
\subsubsection[{\texorpdfstring{to\+Std\+Deque() const }{toStdDeque() const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::deque$<$T$>$ prism\+::to\+Std\+Deque (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{namespaceprism_a770640a1fe99095d96e9295b225ac93d}{}\label{namespaceprism_a770640a1fe99095d96e9295b225ac93d}
\index{prism@{prism}!uninitialized\+\_\+copy@{uninitialized\+\_\+copy}}
\index{uninitialized\+\_\+copy@{uninitialized\+\_\+copy}!prism@{prism}}
\subsubsection[{\texorpdfstring{uninitialized\+\_\+copy(\+Forward\+Iterator1 first, Forward\+Iterator1 last, Forward\+Iterator2 other\+First)}{uninitialized_copy(ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ Forward\+Iterator2 prism\+::uninitialized\+\_\+copy (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator1}]{first, }
\item[{Forward\+Iterator1}]{last, }
\item[{Forward\+Iterator2}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5ff56f151fea6e709350a0e9fbdb70a8}{}\label{namespaceprism_a5ff56f151fea6e709350a0e9fbdb70a8}
The range \mbox{[}first,last\mbox{]} represents a block of memory that has been allocated but not initialized i.\+e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{prism\+::fill} algorithm). This algorithm takes that memory block and initializes each element by copy-\/constructing each element in place. This algorithm differs from \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{prism\+::fill} because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn\textquotesingle{}t. It copy-\/constructs in place instead. \index{prism@{prism}!uninitialized\+\_\+copy\+\_\+aux@{uninitialized\+\_\+copy\+\_\+aux}}
\index{uninitialized\+\_\+copy\+\_\+aux@{uninitialized\+\_\+copy\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{uninitialized\+\_\+copy\+\_\+aux(\+Forward\+Iterator1 first, Forward\+Iterator1 last, Forward\+Iterator2 other\+First)}{uninitialized_copy_aux(ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ Forward\+Iterator2 prism\+::uninitialized\+\_\+copy\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator1}]{first, }
\item[{Forward\+Iterator1}]{last, }
\item[{Forward\+Iterator2}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a6ef07b731fbaecb8abe1ad8faabaab1e}{}\label{namespaceprism_a6ef07b731fbaecb8abe1ad8faabaab1e}
The range \mbox{[}first,last\mbox{]} represents a block of memory that has been allocated but not initialized i.\+e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{prism\+::fill} algorithm). This algorithm takes that memory block and initializes each element by copy-\/constructing each element in place. This algorithm differs from \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{prism\+::fill} because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn\textquotesingle{}t. It copy-\/constructs in place instead. \index{prism@{prism}!uninitialized\+\_\+copy\+\_\+n@{uninitialized\+\_\+copy\+\_\+n}}
\index{uninitialized\+\_\+copy\+\_\+n@{uninitialized\+\_\+copy\+\_\+n}!prism@{prism}}
\subsubsection[{\texorpdfstring{uninitialized\+\_\+copy\+\_\+n(\+Forward\+Iterator1 first, const int size, Forward\+Iterator2 other\+First)}{uninitialized_copy_n(ForwardIterator1 first, const int size, ForwardIterator2 otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ Forward\+Iterator2 prism\+::uninitialized\+\_\+copy\+\_\+n (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator1}]{first, }
\item[{const int}]{size, }
\item[{Forward\+Iterator2}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_ad1c7d8eb38174ba66d98321b68047e6e}{}\label{namespaceprism_ad1c7d8eb38174ba66d98321b68047e6e}
The range \mbox{[}first,last\mbox{]} represents a block of memory that has been allocated but not initialized i.\+e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{prism\+::fill} algorithm). This algorithm takes that memory block and initializes each element by copy-\/constructing each element in place. This algorithm differs from \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{prism\+::fill} because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn\textquotesingle{}t. It copy-\/constructs in place instead. \index{prism@{prism}!uninitialized\+\_\+copy\+\_\+n\+\_\+aux@{uninitialized\+\_\+copy\+\_\+n\+\_\+aux}}
\index{uninitialized\+\_\+copy\+\_\+n\+\_\+aux@{uninitialized\+\_\+copy\+\_\+n\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{uninitialized\+\_\+copy\+\_\+n\+\_\+aux(\+Forward\+Iterator1 first, const int size, Forward\+Iterator2 other\+First)}{uninitialized_copy_n_aux(ForwardIterator1 first, const int size, ForwardIterator2 otherFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator1 , class Forward\+Iterator2 $>$ Forward\+Iterator2 prism\+::uninitialized\+\_\+copy\+\_\+n\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator1}]{first, }
\item[{const int}]{size, }
\item[{Forward\+Iterator2}]{other\+First}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a85d1fe2d10e98f9de7aec30799f2eec0}{}\label{namespaceprism_a85d1fe2d10e98f9de7aec30799f2eec0}
The range \mbox{[}first,last\mbox{]} represents a block of memory that has been allocated but not initialized i.\+e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{prism\+::fill} algorithm). This algorithm takes that memory block and initializes each element by copy-\/constructing each element in place. This algorithm differs from \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{prism\+::fill} because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn\textquotesingle{}t. It copy-\/constructs in place instead. \index{prism@{prism}!uninitialized\+\_\+fill@{uninitialized\+\_\+fill}}
\index{uninitialized\+\_\+fill@{uninitialized\+\_\+fill}!prism@{prism}}
\subsubsection[{\texorpdfstring{uninitialized\+\_\+fill(\+Forward\+Iterator first, Forward\+Iterator last, const T \&value)}{uninitialized_fill(ForwardIterator first, ForwardIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::uninitialized\+\_\+fill (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a8234c2c7917f750db94bb068d6fd554e}{}\label{namespaceprism_a8234c2c7917f750db94bb068d6fd554e}
The range \mbox{[}first,last\mbox{]} represents a block of memory that has been allocated but not initialized i.\+e. no elements have been constructed. This algorithm takes that memory block and initializes each element by copy-\/constructing each element in place. \index{prism@{prism}!uninitialized\+\_\+fill\+\_\+aux@{uninitialized\+\_\+fill\+\_\+aux}}
\index{uninitialized\+\_\+fill\+\_\+aux@{uninitialized\+\_\+fill\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{uninitialized\+\_\+fill\+\_\+aux(\+Forward\+Iterator first, Forward\+Iterator last, const T \&value)}{uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::uninitialized\+\_\+fill\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{Forward\+Iterator}]{last, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aaa8fcd4a3943bfa624f77fc8f3af5916}{}\label{namespaceprism_aaa8fcd4a3943bfa624f77fc8f3af5916}
The range \mbox{[}first,last\mbox{]} represents a block of memory that has been allocated but not initialized i.\+e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{prism\+::fill} algorithm). This algorithm takes that memory block and initializes each element by copy-\/constructing each element in place. This algorithm differs from \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{prism\+::fill} because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn\textquotesingle{}t. It copy-\/constructs in place instead. \index{prism@{prism}!uninitialized\+\_\+fill\+\_\+n@{uninitialized\+\_\+fill\+\_\+n}}
\index{uninitialized\+\_\+fill\+\_\+n@{uninitialized\+\_\+fill\+\_\+n}!prism@{prism}}
\subsubsection[{\texorpdfstring{uninitialized\+\_\+fill\+\_\+n(\+Forward\+Iterator first, const int size, const T \&value)}{uninitialized_fill_n(ForwardIterator first, const int size, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::uninitialized\+\_\+fill\+\_\+n (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{const int}]{size, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a5485ae7bad862f6ff0ab363ed4697b61}{}\label{namespaceprism_a5485ae7bad862f6ff0ab363ed4697b61}
The range \mbox{[}first,last\mbox{]} represents a block of memory that has been allocated but not initialized i.\+e. no elements have been constructed. This algorithm takes that memory block and initializes each element by copy-\/constructing each element in place. \index{prism@{prism}!uninitialized\+\_\+fill\+\_\+n\+\_\+aux@{uninitialized\+\_\+fill\+\_\+n\+\_\+aux}}
\index{uninitialized\+\_\+fill\+\_\+n\+\_\+aux@{uninitialized\+\_\+fill\+\_\+n\+\_\+aux}!prism@{prism}}
\subsubsection[{\texorpdfstring{uninitialized\+\_\+fill\+\_\+n\+\_\+aux(\+Forward\+Iterator first, const int size, const T \&value)}{uninitialized_fill_n_aux(ForwardIterator first, const int size, const T &value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Forward\+Iterator , class T $>$ void prism\+::uninitialized\+\_\+fill\+\_\+n\+\_\+aux (
\begin{DoxyParamCaption}
\item[{Forward\+Iterator}]{first, }
\item[{const int}]{size, }
\item[{const T \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_aa02596d3361c57f312168ffac621e421}{}\label{namespaceprism_aa02596d3361c57f312168ffac621e421}
The range \mbox{[}first,last\mbox{]} represents a block of memory that has been allocated but not initialized i.\+e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{prism\+::fill} algorithm). This algorithm takes that memory block and initializes each element by copy-\/constructing each element in place. This algorithm differs from \hyperlink{namespaceprism_a7c33653a5b4a07b31f5bde15e9085b45}{prism\+::fill} because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn\textquotesingle{}t. It copy-\/constructs in place instead. \index{prism@{prism}!````~Deque@{$\sim$\+Deque}}
\index{````~Deque@{$\sim$\+Deque}!prism@{prism}}
\subsubsection[{\texorpdfstring{$\sim$\+Deque()}{~Deque()}}]{\setlength{\rightskip}{0pt plus 5cm}prism\+::$\sim$\+Deque (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceprism_a331c22c8877ca45c3f9504b1fbfb711c}{}\label{namespaceprism_a331c22c8877ca45c3f9504b1fbfb711c}
Destroys this Deque. 