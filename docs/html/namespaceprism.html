<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Prism: prism Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Prism
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceprism.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">prism Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_array.html">Array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_bitvector.html">Bitvector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_char.html">Char</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_circle.html">Circle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_exception.html">Exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_flag.html">Flag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_flags.html">Flags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_fraction.html">Fraction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_list.html">List</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_list_const_iterator.html">ListConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_list_iterator.html">ListIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_mathf.html">Mathf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_out_of_bounds_exception.html">OutOfBoundsException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_point.html">Point</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_pointf.html">Pointf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_queue.html">Queue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_rect.html">Rect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_reference_counter.html">ReferenceCounter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_shared_data.html">SharedData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_shared_data_pointer.html">SharedDataPointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_size.html">Size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_stack.html">Stack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_stack_data.html">StackData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_string.html">String</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_vector.html">Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_vector2.html">Vector2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_vector3.html">Vector3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_vector4.html">Vector4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a403ca8f79c481a89132691c0fd8c3a06"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a403ca8f79c481a89132691c0fd8c3a06"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a403ca8f79c481a89132691c0fd8c3a06">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_array.html">Array</a>&lt; T &gt; &amp;array)</td></tr>
<tr class="separator:a403ca8f79c481a89132691c0fd8c3a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50da64555d454821545fe0311fde6a62"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a50da64555d454821545fe0311fde6a62"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a50da64555d454821545fe0311fde6a62">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_list.html">List</a>&lt; T &gt; &amp;list)</td></tr>
<tr class="separator:a50da64555d454821545fe0311fde6a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df924e4deb059bf1200701c8235410a"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a9df924e4deb059bf1200701c8235410a"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9df924e4deb059bf1200701c8235410a">operator!=</a> (const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p1, const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p2)</td></tr>
<tr class="separator:a9df924e4deb059bf1200701c8235410a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6391c124e006b0e3a3ec67f55e208b0"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ad6391c124e006b0e3a3ec67f55e208b0"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad6391c124e006b0e3a3ec67f55e208b0">operator!=</a> (const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p1, const U *p2)</td></tr>
<tr class="separator:ad6391c124e006b0e3a3ec67f55e208b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8792dbd5cac5678390843bacdb69daa"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ab8792dbd5cac5678390843bacdb69daa"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab8792dbd5cac5678390843bacdb69daa">operator!=</a> (const U *p1, const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p2)</td></tr>
<tr class="separator:ab8792dbd5cac5678390843bacdb69daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53d52e8a36ec7ca58ea1731cc18f1d8"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ae53d52e8a36ec7ca58ea1731cc18f1d8"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae53d52e8a36ec7ca58ea1731cc18f1d8">operator==</a> (const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p1, const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p2)</td></tr>
<tr class="separator:ae53d52e8a36ec7ca58ea1731cc18f1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b73e87f080646696ed6b595a3900119"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a2b73e87f080646696ed6b595a3900119"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2b73e87f080646696ed6b595a3900119">operator==</a> (const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p1, const U *p2)</td></tr>
<tr class="separator:a2b73e87f080646696ed6b595a3900119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f29b22985dc0ec1fc548a551ce313ed"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a1f29b22985dc0ec1fc548a551ce313ed"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1f29b22985dc0ec1fc548a551ce313ed">operator==</a> (const U *p1, const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p2)</td></tr>
<tr class="separator:a1f29b22985dc0ec1fc548a551ce313ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6430516ab4f2e2a7f43323acb6b559d8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6430516ab4f2e2a7f43323acb6b559d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a6430516ab4f2e2a7f43323acb6b559d8">swap</a> (T &amp;a, T &amp;b)</td></tr>
<tr class="separator:a6430516ab4f2e2a7f43323acb6b559d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2c83ae0d89a6581d1c42ba6fd79de0"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator &gt; </td></tr>
<tr class="memitem:a5f2c83ae0d89a6581d1c42ba6fd79de0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5f2c83ae0d89a6581d1c42ba6fd79de0">p_heapify</a> (RandomAccessIterator node, RandomAccessIterator first, RandomAccessIterator last)</td></tr>
<tr class="separator:a5f2c83ae0d89a6581d1c42ba6fd79de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82052418345794a13044c15d8e32dd89"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a82052418345794a13044c15d8e32dd89"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a82052418345794a13044c15d8e32dd89">adjacent_find</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="separator:a82052418345794a13044c15d8e32dd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba366b328f3b6161e6115c16b7153c6d"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:aba366b328f3b6161e6115c16b7153c6d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aba366b328f3b6161e6115c16b7153c6d">all_of</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr class="separator:aba366b328f3b6161e6115c16b7153c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0e3ddb9f698759635572f1220ec0ca"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:a5d0e3ddb9f698759635572f1220ec0ca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5d0e3ddb9f698759635572f1220ec0ca">any_of</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr class="separator:a5d0e3ddb9f698759635572f1220ec0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae776f4cd825f79e7af1cf6ee1d90a209"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ae776f4cd825f79e7af1cf6ee1d90a209"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae776f4cd825f79e7af1cf6ee1d90a209">copy</a> (InputIterator first, InputIterator last, OutputIterator otherFirst)</td></tr>
<tr class="separator:ae776f4cd825f79e7af1cf6ee1d90a209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2564c63b76369cc81ff725a56e818046"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator1 , class BidirectionalIterator2 &gt; </td></tr>
<tr class="memitem:a2564c63b76369cc81ff725a56e818046"><td class="memTemplItemLeft" align="right" valign="top">BidirectionalIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2564c63b76369cc81ff725a56e818046">copy_backward</a> (BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 otherLast)</td></tr>
<tr class="separator:a2564c63b76369cc81ff725a56e818046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbed55ae6769c2d88c125aedc2f3846e"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:afbed55ae6769c2d88c125aedc2f3846e"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#afbed55ae6769c2d88c125aedc2f3846e">copy_if</a> (InputIterator first, InputIterator last, OutputIterator otherFirst, Predicate pred)</td></tr>
<tr class="separator:afbed55ae6769c2d88c125aedc2f3846e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af907f3f5637d4ec056e9b833b6272953"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Size , class OutputIterator &gt; </td></tr>
<tr class="memitem:af907f3f5637d4ec056e9b833b6272953"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af907f3f5637d4ec056e9b833b6272953">copy_n</a> (InputIterator first, <a class="el" href="classprism_1_1_size.html">Size</a> n, OutputIterator otherFirst)</td></tr>
<tr class="separator:af907f3f5637d4ec056e9b833b6272953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024117fc3639cdf6598509edf22f034a"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class T &gt; </td></tr>
<tr class="memitem:a024117fc3639cdf6598509edf22f034a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a024117fc3639cdf6598509edf22f034a">count</a> (InputIterator first, InputIterator last, const T &amp;value)</td></tr>
<tr class="separator:a024117fc3639cdf6598509edf22f034a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0007d361beae18a930b6249752e509e"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:af0007d361beae18a930b6249752e509e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af0007d361beae18a930b6249752e509e">count_if</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr class="separator:af0007d361beae18a930b6249752e509e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e62e5b148c55f949e5ea843d53ad67"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a83e62e5b148c55f949e5ea843d53ad67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a83e62e5b148c55f949e5ea843d53ad67">delete_range</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="separator:a83e62e5b148c55f949e5ea843d53ad67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bede9a0f2c648e93677b14c45b1b7b"><td class="memTemplParams" colspan="2">template&lt;class InputIterator1 , class InputIterator2 &gt; </td></tr>
<tr class="memitem:ad3bede9a0f2c648e93677b14c45b1b7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad3bede9a0f2c648e93677b14c45b1b7b">equal</a> (InputIterator1 first, InputIterator1 last, InputIterator2 otherFirst)</td></tr>
<tr class="separator:ad3bede9a0f2c648e93677b14c45b1b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c33653a5b4a07b31f5bde15e9085b45"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:a7c33653a5b4a07b31f5bde15e9085b45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45">fill</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>
<tr class="separator:a7c33653a5b4a07b31f5bde15e9085b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb4b9c511a5edb706296b457427b226"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:aceb4b9c511a5edb706296b457427b226"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aceb4b9c511a5edb706296b457427b226">fill_n</a> (ForwardIterator first, int size, const T &amp;value)</td></tr>
<tr class="separator:aceb4b9c511a5edb706296b457427b226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b543d9c2862a539cc8b770abda87561"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class T &gt; </td></tr>
<tr class="memitem:a1b543d9c2862a539cc8b770abda87561"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1b543d9c2862a539cc8b770abda87561">find</a> (InputIterator first, InputIterator last, const T &amp;value)</td></tr>
<tr class="separator:a1b543d9c2862a539cc8b770abda87561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17e9e6c80f8a52479a52450a108a636"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:aa17e9e6c80f8a52479a52450a108a636"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa17e9e6c80f8a52479a52450a108a636">find_if</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr class="separator:aa17e9e6c80f8a52479a52450a108a636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3189014b9fa31e0ef0d1933c6f616618"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class T &gt; </td></tr>
<tr class="memitem:a3189014b9fa31e0ef0d1933c6f616618"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a3189014b9fa31e0ef0d1933c6f616618">find_last</a> (InputIterator first, InputIterator last, const T &amp;value)</td></tr>
<tr class="separator:a3189014b9fa31e0ef0d1933c6f616618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae062d5bfdc0e53ae49c56520aded906"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Function &gt; </td></tr>
<tr class="memitem:aae062d5bfdc0e53ae49c56520aded906"><td class="memTemplItemLeft" align="right" valign="top">Function&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aae062d5bfdc0e53ae49c56520aded906">for_each</a> (InputIterator first, InputIterator last, Function func)</td></tr>
<tr class="separator:aae062d5bfdc0e53ae49c56520aded906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5efbeb096446c47690b9e8bd2cc01a"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:acf5efbeb096446c47690b9e8bd2cc01a"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#acf5efbeb096446c47690b9e8bd2cc01a">is_sorted</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="separator:acf5efbeb096446c47690b9e8bd2cc01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e36230e6cb92a41aaca282772a9e6e"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator &gt; </td></tr>
<tr class="memitem:af8e36230e6cb92a41aaca282772a9e6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af8e36230e6cb92a41aaca282772a9e6e">make_heap</a> (RandomAccessIterator first, RandomAccessIterator last)</td></tr>
<tr class="separator:af8e36230e6cb92a41aaca282772a9e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812456273adfa37979e79f07e731d412"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a812456273adfa37979e79f07e731d412"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a812456273adfa37979e79f07e731d412">max</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a812456273adfa37979e79f07e731d412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aff0aca673fb1837069dd8967e4738"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a10aff0aca673fb1837069dd8967e4738"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a10aff0aca673fb1837069dd8967e4738">min</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a10aff0aca673fb1837069dd8967e4738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c83b433c7f98fd4513f1b68c6db594"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:a10c83b433c7f98fd4513f1b68c6db594"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a10c83b433c7f98fd4513f1b68c6db594">none_of</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr class="separator:a10c83b433c7f98fd4513f1b68c6db594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddd21943bcf811c56f7d9d1bd4784f6"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:aeddd21943bcf811c56f7d9d1bd4784f6"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aeddd21943bcf811c56f7d9d1bd4784f6">remove</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>
<tr class="separator:aeddd21943bcf811c56f7d9d1bd4784f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b6fb407340e51749169560b48fb20c"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class T &gt; </td></tr>
<tr class="memitem:ab7b6fb407340e51749169560b48fb20c"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab7b6fb407340e51749169560b48fb20c">remove_copy</a> (InputIterator first, InputIterator last, OutputIterator otherFirst, const T &amp;value)</td></tr>
<tr class="separator:ab7b6fb407340e51749169560b48fb20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc7da1f951e480a26d58fc098b78844"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:abfc7da1f951e480a26d58fc098b78844"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#abfc7da1f951e480a26d58fc098b78844">remove_copy_if</a> (InputIterator first, InputIterator last, OutputIterator otherFirst, UnaryPredicate pred)</td></tr>
<tr class="separator:abfc7da1f951e480a26d58fc098b78844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9d25191ed83ea0a193f16d9c0a00b7"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class Predicate &gt; </td></tr>
<tr class="memitem:a2e9d25191ed83ea0a193f16d9c0a00b7"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2e9d25191ed83ea0a193f16d9c0a00b7">remove_if</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>
<tr class="separator:a2e9d25191ed83ea0a193f16d9c0a00b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6156070b98de7130b8c912ae3a6d333f"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:a6156070b98de7130b8c912ae3a6d333f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a6156070b98de7130b8c912ae3a6d333f">replace</a> (ForwardIterator first, ForwardIterator last, const T &amp;oldValue, const T &amp;newValue)</td></tr>
<tr class="separator:a6156070b98de7130b8c912ae3a6d333f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d85ecb70d2f216714a0146a057a105"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class T &gt; </td></tr>
<tr class="memitem:a16d85ecb70d2f216714a0146a057a105"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a16d85ecb70d2f216714a0146a057a105">replace_copy</a> (InputIterator first, InputIterator last, OutputIterator otherFirst, const T &amp;oldValue, const T &amp;newValue)</td></tr>
<tr class="separator:a16d85ecb70d2f216714a0146a057a105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d702599739f7137516dcd095119f15"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class Predicate , class T &gt; </td></tr>
<tr class="memitem:a55d702599739f7137516dcd095119f15"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a55d702599739f7137516dcd095119f15">replace_copy_if</a> (InputIterator first, InputIterator last, OutputIterator otherFirst, Predicate pred, const T &amp;newValue)</td></tr>
<tr class="separator:a55d702599739f7137516dcd095119f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af118c19f6b5448319eb3aaf2d556ac54"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class Predicate , class T &gt; </td></tr>
<tr class="memitem:af118c19f6b5448319eb3aaf2d556ac54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af118c19f6b5448319eb3aaf2d556ac54">replace_if</a> (ForwardIterator first, ForwardIterator last, Predicate pred, const T &amp;newValue)</td></tr>
<tr class="separator:af118c19f6b5448319eb3aaf2d556ac54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcb3e5150d72d9f79b85b9ea4eb41e2"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </td></tr>
<tr class="memitem:affcb3e5150d72d9f79b85b9ea4eb41e2"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#affcb3e5150d72d9f79b85b9ea4eb41e2">search</a> (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)</td></tr>
<tr class="separator:affcb3e5150d72d9f79b85b9ea4eb41e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf397cad0a67b67fbd1ecddf40d405e"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a9bf397cad0a67b67fbd1ecddf40d405e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9bf397cad0a67b67fbd1ecddf40d405e">sort</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="separator:a9bf397cad0a67b67fbd1ecddf40d405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa597d262eb2f9ef80703c883a2d18d1e"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator &gt; </td></tr>
<tr class="memitem:aa597d262eb2f9ef80703c883a2d18d1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa597d262eb2f9ef80703c883a2d18d1e">sort_bubble</a> (RandomAccessIterator first, RandomAccessIterator last)</td></tr>
<tr class="separator:aa597d262eb2f9ef80703c883a2d18d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9fe74c5dcee70bf5dd5c89f1234a02"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator &gt; </td></tr>
<tr class="memitem:a1e9fe74c5dcee70bf5dd5c89f1234a02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1e9fe74c5dcee70bf5dd5c89f1234a02">sort_heap</a> (RandomAccessIterator first, RandomAccessIterator last)</td></tr>
<tr class="separator:a1e9fe74c5dcee70bf5dd5c89f1234a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720fbbcb3f399b006969bb00a66686f9"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a720fbbcb3f399b006969bb00a66686f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a720fbbcb3f399b006969bb00a66686f9">sort_quicksort</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="separator:a720fbbcb3f399b006969bb00a66686f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4661f2c0c4dca098c137179b4d93f3dc"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </td></tr>
<tr class="memitem:a4661f2c0c4dca098c137179b4d93f3dc"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a4661f2c0c4dca098c137179b4d93f3dc">swap_ranges</a> (ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 otherFirst)</td></tr>
<tr class="separator:a4661f2c0c4dca098c137179b4d93f3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba68b64a6cfdcff9e144b8c2476cddb"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1ba68b64a6cfdcff9e144b8c2476cddb">operator==</a> (const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c1, const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c2)</td></tr>
<tr class="separator:a1ba68b64a6cfdcff9e144b8c2476cddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249b6933154570d808cdd405ab1fd89b"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a249b6933154570d808cdd405ab1fd89b">operator!=</a> (const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c1, const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c2)</td></tr>
<tr class="separator:a249b6933154570d808cdd405ab1fd89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc3e64ba36a16f24cb0ae387c83f35f"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2fc3e64ba36a16f24cb0ae387c83f35f">operator&lt;</a> (const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c1, const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c2)</td></tr>
<tr class="separator:a2fc3e64ba36a16f24cb0ae387c83f35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a312729c4c9ae72836d0034a6f0758"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab8a312729c4c9ae72836d0034a6f0758">operator&gt;</a> (const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c1, const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c2)</td></tr>
<tr class="separator:ab8a312729c4c9ae72836d0034a6f0758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d86e9266469c8a40537e12a560b066"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a87d86e9266469c8a40537e12a560b066">operator&lt;=</a> (const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c1, const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c2)</td></tr>
<tr class="separator:a87d86e9266469c8a40537e12a560b066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad049ddef9beb3fec3e7057a7f651280"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aad049ddef9beb3fec3e7057a7f651280">operator&gt;=</a> (const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c1, const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c2)</td></tr>
<tr class="separator:aad049ddef9beb3fec3e7057a7f651280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67ea1154a35dabe9c2c232aff65e930"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa67ea1154a35dabe9c2c232aff65e930">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c)</td></tr>
<tr class="separator:aa67ea1154a35dabe9c2c232aff65e930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce1ad6e6392618212d5ab3bebb8e585"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a0ce1ad6e6392618212d5ab3bebb8e585">operator==</a> (const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c1, const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c2)</td></tr>
<tr class="separator:a0ce1ad6e6392618212d5ab3bebb8e585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cbf7ef406800002b446a0f1e917745"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a58cbf7ef406800002b446a0f1e917745">operator!=</a> (const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c1, const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c2)</td></tr>
<tr class="separator:a58cbf7ef406800002b446a0f1e917745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e662d15b162ca76912c491798caefd3"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8e662d15b162ca76912c491798caefd3">operator&lt;</a> (const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c1, const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c2)</td></tr>
<tr class="separator:a8e662d15b162ca76912c491798caefd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671739ac8567654dba563c34af92213f"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a671739ac8567654dba563c34af92213f">operator&gt;</a> (const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c1, const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c2)</td></tr>
<tr class="separator:a671739ac8567654dba563c34af92213f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63d3d39d3fad8fa5c5966cc4f306324"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa63d3d39d3fad8fa5c5966cc4f306324">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c)</td></tr>
<tr class="separator:aa63d3d39d3fad8fa5c5966cc4f306324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b5b2765c314b2baa2dba5c57419829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_fraction.html">Fraction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ac1b5b2765c314b2baa2dba5c57419829">operator+</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:ac1b5b2765c314b2baa2dba5c57419829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2daf470e5f35f8450447deb2634c22c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_fraction.html">Fraction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2daf470e5f35f8450447deb2634c22c1">operator-</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:a2daf470e5f35f8450447deb2634c22c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f48e3429a86bafcc7c21a2bd6a7ae1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_fraction.html">Fraction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ac4f48e3429a86bafcc7c21a2bd6a7ae1">operator*</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:ac4f48e3429a86bafcc7c21a2bd6a7ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5007702b28b447f62c3b9df62f2aa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_fraction.html">Fraction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1f5007702b28b447f62c3b9df62f2aa4">operator*</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;fraction, const int i)</td></tr>
<tr class="separator:a1f5007702b28b447f62c3b9df62f2aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ff5871f65565a84b886c5013bcd50a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_fraction.html">Fraction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af1ff5871f65565a84b886c5013bcd50a">operator*</a> (const int i, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;fraction)</td></tr>
<tr class="separator:af1ff5871f65565a84b886c5013bcd50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba7b5cc9750f0d6cda50f0cb874da6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_fraction.html">Fraction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7ba7b5cc9750f0d6cda50f0cb874da6f">operator/</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:a7ba7b5cc9750f0d6cda50f0cb874da6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105ac9995ade66ebb2a039ef90751c7a"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a105ac9995ade66ebb2a039ef90751c7a">operator&lt;</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:a105ac9995ade66ebb2a039ef90751c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7122a7ff43fc6aba9cef9d31fe8c7559"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7122a7ff43fc6aba9cef9d31fe8c7559">operator&gt;</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:a7122a7ff43fc6aba9cef9d31fe8c7559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9e84008b9eaa99d29d4b74cd150cd8"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5b9e84008b9eaa99d29d4b74cd150cd8">operator==</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:a5b9e84008b9eaa99d29d4b74cd150cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea72179b12983e614f72acd2b3cbf0e0"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aea72179b12983e614f72acd2b3cbf0e0">operator!=</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:aea72179b12983e614f72acd2b3cbf0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2d182a77a92e6cba7917dbd58f9d87"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9c2d182a77a92e6cba7917dbd58f9d87">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f)</td></tr>
<tr class="separator:a9c2d182a77a92e6cba7917dbd58f9d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33537d30f01f996f8a05fc5b1b49ba3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a33537d30f01f996f8a05fc5b1b49ba3b">operator+</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m1, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m2)</td></tr>
<tr class="separator:a33537d30f01f996f8a05fc5b1b49ba3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a2f64f209065f753bed62a880b75b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a34a2f64f209065f753bed62a880b75b6">operator-</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m1, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m2)</td></tr>
<tr class="separator:a34a2f64f209065f753bed62a880b75b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879d3410d690b5722a9af17297f38fbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a879d3410d690b5722a9af17297f38fbb">operator-</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m)</td></tr>
<tr class="separator:a879d3410d690b5722a9af17297f38fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae44fb46bb709a5c8f4d592baf65522"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9ae44fb46bb709a5c8f4d592baf65522">operator*</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m1, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m2)</td></tr>
<tr class="separator:a9ae44fb46bb709a5c8f4d592baf65522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3639f7bd46a54726522dfe406841ea9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab3639f7bd46a54726522dfe406841ea9">operator*</a> (const float factor, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m)</td></tr>
<tr class="separator:ab3639f7bd46a54726522dfe406841ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4073983f089695c40b6fd20d892175f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a4073983f089695c40b6fd20d892175f9">operator*</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m, const float factor)</td></tr>
<tr class="separator:a4073983f089695c40b6fd20d892175f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2859acb8e8dd6fea8678e14249e561d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa2859acb8e8dd6fea8678e14249e561d">operator*</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m1, const float *m2)</td></tr>
<tr class="separator:aa2859acb8e8dd6fea8678e14249e561d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e83bcd69595728106bed838aeb32f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5e83bcd69595728106bed838aeb32f70">operator*</a> (const float *m1, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m2)</td></tr>
<tr class="separator:a5e83bcd69595728106bed838aeb32f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ceb3342a808c88d0bb7c1f7e0ef82b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a95ceb3342a808c88d0bb7c1f7e0ef82b">operator*</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m)</td></tr>
<tr class="separator:a95ceb3342a808c88d0bb7c1f7e0ef82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f1e6e0f84169fce23b236e0312d6a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a04f1e6e0f84169fce23b236e0312d6a0">operator*</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v)</td></tr>
<tr class="separator:a04f1e6e0f84169fce23b236e0312d6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a10d8ea1e63b19d02bd294e4ebabb1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5a10d8ea1e63b19d02bd294e4ebabb1b">operator*</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m)</td></tr>
<tr class="separator:a5a10d8ea1e63b19d02bd294e4ebabb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad125bd8304d577b6f879fb973f774eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad125bd8304d577b6f879fb973f774eb8">operator*</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v)</td></tr>
<tr class="separator:ad125bd8304d577b6f879fb973f774eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44373b8bda7131a90d04eef7e455ea6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a44373b8bda7131a90d04eef7e455ea6f">operator*</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m)</td></tr>
<tr class="separator:a44373b8bda7131a90d04eef7e455ea6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82522932359d2381607cf1fe0c898011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a82522932359d2381607cf1fe0c898011">operator*</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p)</td></tr>
<tr class="separator:a82522932359d2381607cf1fe0c898011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517b4bc9b0ccc23f79b744d93b540fa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a517b4bc9b0ccc23f79b744d93b540fa6">operator/</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m, const float divisor)</td></tr>
<tr class="separator:a517b4bc9b0ccc23f79b744d93b540fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8804ec2ab8dda9441d64e947f05e293c"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8804ec2ab8dda9441d64e947f05e293c">operator==</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m1, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m2)</td></tr>
<tr class="separator:a8804ec2ab8dda9441d64e947f05e293c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d184994eec61a1511fc936a9facb69a"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a4d184994eec61a1511fc936a9facb69a">operator!=</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m1, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m2)</td></tr>
<tr class="separator:a4d184994eec61a1511fc936a9facb69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65e15b3e601e0570beb49a11610c671"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab65e15b3e601e0570beb49a11610c671">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;matrix)</td></tr>
<tr class="separator:ab65e15b3e601e0570beb49a11610c671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9fe7ab8ef5f1ee0338e3b057624393"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#acb9fe7ab8ef5f1ee0338e3b057624393">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p)</td></tr>
<tr class="separator:acb9fe7ab8ef5f1ee0338e3b057624393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e983b5c32c93114583309eda19dc2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a49e983b5c32c93114583309eda19dc2b">operator+</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p1, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p2)</td></tr>
<tr class="separator:a49e983b5c32c93114583309eda19dc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505cbd94f024ad80136afe0b751da08a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a505cbd94f024ad80136afe0b751da08a">operator-</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p1, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p2)</td></tr>
<tr class="separator:a505cbd94f024ad80136afe0b751da08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40976ce143923309d4c737bb8288d9e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a40976ce143923309d4c737bb8288d9e5">operator*</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p, const int factor)</td></tr>
<tr class="separator:a40976ce143923309d4c737bb8288d9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e41c0858ff4149eafa1bc878dabb7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a96e41c0858ff4149eafa1bc878dabb7c">operator*</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p, const float factor)</td></tr>
<tr class="separator:a96e41c0858ff4149eafa1bc878dabb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46a547ddc48425588986b0840d026a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa46a547ddc48425588986b0840d026a4">operator*</a> (const int factor, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p)</td></tr>
<tr class="separator:aa46a547ddc48425588986b0840d026a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec2671f1e6c155a79740a8556baecc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1ec2671f1e6c155a79740a8556baecc0">operator*</a> (const float factor, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p)</td></tr>
<tr class="separator:a1ec2671f1e6c155a79740a8556baecc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f73aee33931e5b9977da32e50d47c0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5f73aee33931e5b9977da32e50d47c0e">operator/</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p, const float divisor)</td></tr>
<tr class="separator:a5f73aee33931e5b9977da32e50d47c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739baa4e75c1ca83624d486eec1d45e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a739baa4e75c1ca83624d486eec1d45e9">operator==</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p1, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p2)</td></tr>
<tr class="separator:a739baa4e75c1ca83624d486eec1d45e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cab41d882d24ca064927f2390ef3a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a75cab41d882d24ca064927f2390ef3a6">operator!=</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p1, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p2)</td></tr>
<tr class="separator:a75cab41d882d24ca064927f2390ef3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad408bf2576dfc62a573cb44aa895fb"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#acad408bf2576dfc62a573cb44aa895fb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p)</td></tr>
<tr class="separator:acad408bf2576dfc62a573cb44aa895fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64243aa2d4cf6ddb70526aaeda396f82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_pointf.html">Pointf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a64243aa2d4cf6ddb70526aaeda396f82">operator+</a> (const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p1, const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p2)</td></tr>
<tr class="separator:a64243aa2d4cf6ddb70526aaeda396f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435d5c45d873875f2c5092d102eddb78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_pointf.html">Pointf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a435d5c45d873875f2c5092d102eddb78">operator-</a> (const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p1, const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p2)</td></tr>
<tr class="separator:a435d5c45d873875f2c5092d102eddb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1984e58679ef4d8fcdd37726ee6483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_pointf.html">Pointf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ade1984e58679ef4d8fcdd37726ee6483">operator*</a> (const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p, const float factor)</td></tr>
<tr class="separator:ade1984e58679ef4d8fcdd37726ee6483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409aa6b61b79f029d78f6d4c3aba2df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_pointf.html">Pointf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a409aa6b61b79f029d78f6d4c3aba2df5">operator*</a> (const float factor, const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p)</td></tr>
<tr class="separator:a409aa6b61b79f029d78f6d4c3aba2df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71504f6dd299e8bc788e07d11d29dc5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_pointf.html">Pointf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a71504f6dd299e8bc788e07d11d29dc5e">operator/</a> (const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p, const float divisor)</td></tr>
<tr class="separator:a71504f6dd299e8bc788e07d11d29dc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ab889958edc08eea9a5bea056cd9c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a13ab889958edc08eea9a5bea056cd9c1">operator==</a> (const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p1, const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p2)</td></tr>
<tr class="separator:a13ab889958edc08eea9a5bea056cd9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae010d5880eb7bcf5119f006e26bf473f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae010d5880eb7bcf5119f006e26bf473f">operator!=</a> (const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p1, const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p2)</td></tr>
<tr class="separator:ae010d5880eb7bcf5119f006e26bf473f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81bceaddc25922e571b4bf427ffe296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad81bceaddc25922e571b4bf427ffe296">operator+</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q1, const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q2)</td></tr>
<tr class="separator:ad81bceaddc25922e571b4bf427ffe296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eae37b5dc73c544572686f215cea89d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5eae37b5dc73c544572686f215cea89d">operator-</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q1, const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q2)</td></tr>
<tr class="separator:a5eae37b5dc73c544572686f215cea89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04c2e5eae2242c58a967086ecad8ff4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae04c2e5eae2242c58a967086ecad8ff4">operator-</a> (<a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr class="separator:ae04c2e5eae2242c58a967086ecad8ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c3eeec91c3a178711b6f05a5487d70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a74c3eeec91c3a178711b6f05a5487d70">operator*</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q1, const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q2)</td></tr>
<tr class="separator:a74c3eeec91c3a178711b6f05a5487d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45806b1a58ec5aae0db87d399d4d832b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a45806b1a58ec5aae0db87d399d4d832b">operator*</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q, const float factor)</td></tr>
<tr class="separator:a45806b1a58ec5aae0db87d399d4d832b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f03413053b1efa6851344eb39a5982"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad9f03413053b1efa6851344eb39a5982">operator*</a> (const float factor, const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr class="separator:ad9f03413053b1efa6851344eb39a5982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aebd3615ba448915f37140515a37b05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8aebd3615ba448915f37140515a37b05">operator*</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v)</td></tr>
<tr class="separator:a8aebd3615ba448915f37140515a37b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4c5e120d8c4de9891f2261a50f100e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2c4c5e120d8c4de9891f2261a50f100e">operator*</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v)</td></tr>
<tr class="separator:a2c4c5e120d8c4de9891f2261a50f100e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec648937a53338bcd9879670877d0425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aec648937a53338bcd9879670877d0425">operator/</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q, const float divisor)</td></tr>
<tr class="separator:aec648937a53338bcd9879670877d0425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ae112433b9ab32c801cccc9c3f74f0"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ac4ae112433b9ab32c801cccc9c3f74f0">operator==</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q1, const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q2)</td></tr>
<tr class="separator:ac4ae112433b9ab32c801cccc9c3f74f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e32551f997ae19dc52df146482405c1"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9e32551f997ae19dc52df146482405c1">operator!=</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q1, const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q2)</td></tr>
<tr class="separator:a9e32551f997ae19dc52df146482405c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2beaed7a837821f0abc608cf6ac6c0f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad2beaed7a837821f0abc608cf6ac6c0f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr class="separator:ad2beaed7a837821f0abc608cf6ac6c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe409fa2ef458a2d477ed7845cf4b6a6"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#abe409fa2ef458a2d477ed7845cf4b6a6">operator==</a> (const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;r1, const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;r2)</td></tr>
<tr class="separator:abe409fa2ef458a2d477ed7845cf4b6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f46c5ebd3cec844925173aaacbed9f"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad9f46c5ebd3cec844925173aaacbed9f">operator!=</a> (const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;r1, const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;r2)</td></tr>
<tr class="separator:ad9f46c5ebd3cec844925173aaacbed9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fd2a97b66b06ba6e451e1890136ff4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a52fd2a97b66b06ba6e451e1890136ff4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="separator:a52fd2a97b66b06ba6e451e1890136ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7baeb09cd2ee29251667ad18a2bd00"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2a7baeb09cd2ee29251667ad18a2bd00">operator==</a> (const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s1, const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s2)</td></tr>
<tr class="separator:a2a7baeb09cd2ee29251667ad18a2bd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ab3c18ecc73e21e7281dbe180e07e8"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a63ab3c18ecc73e21e7281dbe180e07e8">operator!=</a> (const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s1, const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s2)</td></tr>
<tr class="separator:a63ab3c18ecc73e21e7281dbe180e07e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7141aeb35db81548155e44d60c05530e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7141aeb35db81548155e44d60c05530e">operator+</a> (const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s1, const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s2)</td></tr>
<tr class="separator:a7141aeb35db81548155e44d60c05530e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab170e3ca42d85a6766cbc7950ddfb0c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab170e3ca42d85a6766cbc7950ddfb0c4">operator-</a> (const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s1, const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s2)</td></tr>
<tr class="separator:ab170e3ca42d85a6766cbc7950ddfb0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8e53ee3208e09e8736a77be3f485c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a3d8e53ee3208e09e8736a77be3f485c9">operator*</a> (const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;size, const int factor)</td></tr>
<tr class="separator:a3d8e53ee3208e09e8736a77be3f485c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd79758984cccce0dddfb459af65f6e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#acd79758984cccce0dddfb459af65f6e1">operator*</a> (const int factor, const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;size)</td></tr>
<tr class="separator:acd79758984cccce0dddfb459af65f6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e100bd6b1730deaab53d1218e29a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad7e100bd6b1730deaab53d1218e29a67">operator/</a> (const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;size, const int factor)</td></tr>
<tr class="separator:ad7e100bd6b1730deaab53d1218e29a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6335168e27f481d86ae42da444006d1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad6335168e27f481d86ae42da444006d1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;size)</td></tr>
<tr class="separator:ad6335168e27f481d86ae42da444006d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7bfee93ae735b5af7e566ddd8c4f65"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a0e7bfee93ae735b5af7e566ddd8c4f65">operator==</a> (const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str1, const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str2)</td></tr>
<tr class="separator:a0e7bfee93ae735b5af7e566ddd8c4f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2215edf9ab445c3c1791217d131b15"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5c2215edf9ab445c3c1791217d131b15">operator!=</a> (const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str1, const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str2)</td></tr>
<tr class="separator:a5c2215edf9ab445c3c1791217d131b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433f7afd310d95a93cf8c03d1f831812"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classprism_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a433f7afd310d95a93cf8c03d1f831812">operator+</a> (const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str1, const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str2)</td></tr>
<tr class="separator:a433f7afd310d95a93cf8c03d1f831812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50879e9455a36b7762514951ca0f47f7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classprism_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a50879e9455a36b7762514951ca0f47f7">operator+</a> (const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str1, const char *str2)</td></tr>
<tr class="separator:a50879e9455a36b7762514951ca0f47f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d59729f69eafd3bc9f4d30ad9dd06b6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classprism_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7d59729f69eafd3bc9f4d30ad9dd06b6">operator+</a> (const char *str1, const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str2)</td></tr>
<tr class="separator:a7d59729f69eafd3bc9f4d30ad9dd06b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fce6a8b93050fcb6db327e68b701e3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classprism_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa0fce6a8b93050fcb6db327e68b701e3">operator+</a> (const char c, const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str)</td></tr>
<tr class="separator:aa0fce6a8b93050fcb6db327e68b701e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae68ccc6eb3a47a748671c1a7af88ca"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classprism_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8ae68ccc6eb3a47a748671c1a7af88ca">operator+</a> (const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str, const char c)</td></tr>
<tr class="separator:a8ae68ccc6eb3a47a748671c1a7af88ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a166bbf645cc854542cc0fc50324670"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a0a166bbf645cc854542cc0fc50324670">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_string.html">String</a> &amp;s)</td></tr>
<tr class="separator:a0a166bbf645cc854542cc0fc50324670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae482804c32b466401a9ecdf26bc1e6de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae482804c32b466401a9ecdf26bc1e6de">operator+</a> (const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;a, const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;b)</td></tr>
<tr class="separator:ae482804c32b466401a9ecdf26bc1e6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86359a88dc5245847de48575a1f969e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a86359a88dc5245847de48575a1f969e8">operator-</a> (const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;a, const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;b)</td></tr>
<tr class="separator:a86359a88dc5245847de48575a1f969e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124f1081b3a9bbc441dac9927f8a0fc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a124f1081b3a9bbc441dac9927f8a0fc5">operator-</a> (const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;v)</td></tr>
<tr class="separator:a124f1081b3a9bbc441dac9927f8a0fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6528ec4496096e8ccde186bb01fbeed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a6528ec4496096e8ccde186bb01fbeed3">operator*</a> (const float factor, const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;v)</td></tr>
<tr class="separator:a6528ec4496096e8ccde186bb01fbeed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de3bc1dbc3fd33f26d580bce3520854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1de3bc1dbc3fd33f26d580bce3520854">operator*</a> (const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;v, const float factor)</td></tr>
<tr class="separator:a1de3bc1dbc3fd33f26d580bce3520854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1ab02785c9d4d5ea560face252b75e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aea1ab02785c9d4d5ea560face252b75e">operator/</a> (const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;v, const float divisor)</td></tr>
<tr class="separator:aea1ab02785c9d4d5ea560face252b75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311fc983ec89876189643e840d781974"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a311fc983ec89876189643e840d781974">operator==</a> (const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;a, const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;b)</td></tr>
<tr class="separator:a311fc983ec89876189643e840d781974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9d0b027a9e7d9e313affe5af91dabc"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7e9d0b027a9e7d9e313affe5af91dabc">operator!=</a> (const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;a, const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;b)</td></tr>
<tr class="separator:a7e9d0b027a9e7d9e313affe5af91dabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4616180b97f4288a3b3e28304efee020"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a4616180b97f4288a3b3e28304efee020">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;v)</td></tr>
<tr class="separator:a4616180b97f4288a3b3e28304efee020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac90b31f235390d6feb818e3f88ecf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7ac90b31f235390d6feb818e3f88ecf0">operator+</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;a, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;b)</td></tr>
<tr class="separator:a7ac90b31f235390d6feb818e3f88ecf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3beb56b334423e027f1ab185785695f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a3beb56b334423e027f1ab185785695f8">operator-</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;a, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;b)</td></tr>
<tr class="separator:a3beb56b334423e027f1ab185785695f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7cf835ff415e187e6881169803f502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8f7cf835ff415e187e6881169803f502">operator-</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v)</td></tr>
<tr class="separator:a8f7cf835ff415e187e6881169803f502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429cccc5eee454ba019045afb4a01e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a429cccc5eee454ba019045afb4a01e93">operator*</a> (const float factor, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v)</td></tr>
<tr class="separator:a429cccc5eee454ba019045afb4a01e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f2f6de8bf1b584cbb82062a607e167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa1f2f6de8bf1b584cbb82062a607e167">operator*</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v, const float factor)</td></tr>
<tr class="separator:aa1f2f6de8bf1b584cbb82062a607e167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e022748076586917c38e83430df284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a87e022748076586917c38e83430df284">operator/</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v, const float divisor)</td></tr>
<tr class="separator:a87e022748076586917c38e83430df284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc2a483f2e3ec622ad2c0ac9699fbcb"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2fc2a483f2e3ec622ad2c0ac9699fbcb">operator==</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;a, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;b)</td></tr>
<tr class="separator:a2fc2a483f2e3ec622ad2c0ac9699fbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa752c5d0210902dece31c2fcfc98a824"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa752c5d0210902dece31c2fcfc98a824">operator!=</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;a, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;b)</td></tr>
<tr class="separator:aa752c5d0210902dece31c2fcfc98a824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b9367a483153af865552ba486f1196"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa7b9367a483153af865552ba486f1196">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v)</td></tr>
<tr class="separator:aa7b9367a483153af865552ba486f1196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac9ebc0ce1449793eb8f521c64929a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a4ac9ebc0ce1449793eb8f521c64929a9">operator+</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;a, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;b)</td></tr>
<tr class="separator:a4ac9ebc0ce1449793eb8f521c64929a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038a64f530d1c50bf72cf1a23886ecca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a038a64f530d1c50bf72cf1a23886ecca">operator-</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;a, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;b)</td></tr>
<tr class="separator:a038a64f530d1c50bf72cf1a23886ecca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147712ae50c37618cbc61f20efe6729f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a147712ae50c37618cbc61f20efe6729f">operator-</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v)</td></tr>
<tr class="separator:a147712ae50c37618cbc61f20efe6729f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa652a61fe96302693aa0279e832360c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa652a61fe96302693aa0279e832360c7">operator*</a> (const float factor, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v)</td></tr>
<tr class="separator:aa652a61fe96302693aa0279e832360c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b4a59d9247143b49db3c2778838895"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab3b4a59d9247143b49db3c2778838895">operator*</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v, const float factor)</td></tr>
<tr class="separator:ab3b4a59d9247143b49db3c2778838895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa2b9a75c3d5134fc80cc6afc1be443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a4aa2b9a75c3d5134fc80cc6afc1be443">operator/</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v, const float divisor)</td></tr>
<tr class="separator:a4aa2b9a75c3d5134fc80cc6afc1be443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bdef743a64c754bf1a2b217c82f60a"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a80bdef743a64c754bf1a2b217c82f60a">operator==</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;a, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;b)</td></tr>
<tr class="separator:a80bdef743a64c754bf1a2b217c82f60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffa413af039c2bff07202dcfce55f05"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1ffa413af039c2bff07202dcfce55f05">operator!=</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;a, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;b)</td></tr>
<tr class="separator:a1ffa413af039c2bff07202dcfce55f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb86919d9ba71747d21fbd6e28671692"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aeb86919d9ba71747d21fbd6e28671692">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v)</td></tr>
<tr class="separator:aeb86919d9ba71747d21fbd6e28671692"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Completely and shamelessly lifted from Qt's QFlag/QFlags classes and macros and just renamed without the prepended 'Q'. These classes allow enums to be treated as datatypes when passed to methods. They are also type-safe so that the receiving method is expecting the enum and not the basic int equivalent. So printFlag(Label::AlignLeft) works whilst printFlag(2) doesn't.</p>
<p>For example,</p>
<p>class Label { private: enum Alignment { AlignLeft = 0x1, AlignRight = 0x2 } <a class="el" href="_flags_8h.html#aa5aa2c9827ab949836e20999b9a068ec">PRISM_DECLARE_FLAGS(AlignFlags, Alignment)</a> }</p>
<p>// outside class def <a class="el" href="_flags_8h.html#ae8aabb683a18b872a4449769b82e8e15">PRISM_DECLARE_OPERATORS_FOR_FLAGS(Label::AlignFlags)</a></p>
<p>void printFlag(Label::AlignFlags f) { if (f == Label::AlignLeft) std::cout &lt;&lt; "AlignLeft" &lt;&lt; std::endl; else if (f == Label::AlignRight) std::cout &lt;&lt; "AlignRight" &lt;&lt; std::endl; else std::cout &lt;&lt; f &lt;&lt; std::endl; }</p>
<p>int main(int argc, char** argv) { printFlag(Label::AlignLeft); }</p>
<p>A <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> is made up of four components (w, x, y and z) which are a scalar (w) and a 3d vector (x, y and z). It does not suffer from gimbal lock and yet can represent any orientation possible.</p>
<p>Some interesting properties of quaternion multiplication: a) it is associative but not commutitive - (ab)c = a(bc) ab != ba</p>
<p>b) the magnitude of a quaternion product equals the product of the individual magnitudes. This is an important concept because when quaternions are of unit length and are multiplied, this guarentees us that the result will itself be a unit quaternion - ||ab|| = ||a||||b||</p>
<p>c) the inverse of a quaternion product is equal to the product of the individual quaternion inverses in reverse order - (ab).inverse = (b.inverse) * (a.inverse)</p>
<p>Rotating vectors: When rotating with a quaternion it is important that the quaternion be normalised i.e. be of unit length. This is because otherwise scaling will occur and since we only require rotations from our quaternions this won't do. Rotating a vector using quaternions is done with the following equation: v' = q * v * q.inverse where vector v is represented as a quaternion.</p>
<p>Concatenating rotational transforms together: Multiple quaternion rotations can be applied to a vector in one single action by concatenating the rotational quaternions together and then applying them to the vector using the above equation. For example, to rotate the vector v by quaternion a and then rotating that result by quaternion b would be as follows: v' = b * (a * v * a.inverse) * b.inverse = (b * a) * v * (b.inverse * a.inverse) = (b * a) * v * (b * a).inverse So, rotating by a and then by b is equivalent to the single rotation of the product of ba. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a82052418345794a13044c15d8e32dd89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator prism::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the range <em></em>[first,last] for the first occurrence of two consecutive elements that match. </p><dl class="section return"><dt>Returns</dt><dd>Returns an iterator to the first of these two elements, or <em>last</em> if no such pair is found. </dd></dl>

</div>
</div>
<a class="anchor" id="aba366b328f3b6161e6115c16b7153c6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::all_of </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <em>pred</em> returns true for all the elements in the range <em></em>[first,last] or if the range is empty, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a5d0e3ddb9f698759635572f1220ec0ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::any_of </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <em>pred</em> returns true for any of the elements in the range <em></em>[first, last]. </p>

</div>
</div>
<a class="anchor" id="ae776f4cd825f79e7af1cf6ee1d90a209"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] into the range beginning at <em>otherFirst</em>. </p>

</div>
</div>
<a class="anchor" id="a2564c63b76369cc81ff725a56e818046"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator1 , class BidirectionalIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BidirectionalIterator2 prism::copy_backward </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator2&#160;</td>
          <td class="paramname"><em>otherLast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range [first,last] starting from <em>last</em> to the range ending at <em>otherLast</em>. The elements copied are between <em>first</em> and <em>last</em>, including <em>first</em> but not <em>last</em>. <em>otherLast</em> should point to the past-the-end position of the destination range. </p>

</div>
</div>
<a class="anchor" id="afbed55ae6769c2d88c125aedc2f3846e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] for which <em>pred</em> returns true to the range beginning at <em>otherFirst</em>. </p>

</div>
</div>
<a class="anchor" id="af907f3f5637d4ec056e9b833b6272953"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Size , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::copy_n </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classprism_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the first <em>n</em> elements from the range beginning at <em>first</em> into the range beginning at <em>otherFirst</em>. </p>

</div>
</div>
<a class="anchor" id="a024117fc3639cdf6598509edf22f034a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int prism::count </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of elements in the range <em></em>[first,last] that compare equal to <em>value</em>. </p>

</div>
</div>
<a class="anchor" id="af0007d361beae18a930b6249752e509e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int prism::count_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of elements in the range <em></em>[first,last] for which <em>pred</em> is true. </p>

</div>
</div>
<a class="anchor" id="a83e62e5b148c55f949e5ea843d53ad67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::delete_range </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the elements in the range <em></em>[first, last] by using the c++ delete operator. The element that the iterator points to therefore must be a pointer. </p>

</div>
</div>
<a class="anchor" id="ad3bede9a0f2c648e93677b14c45b1b7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator1 , class InputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::equal </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the elements in the range <em></em>[first1,last1] with those in the range beginning at <em>otherFirst</em>, and returns true if all of the elements in both ranges match. <br />
</p><dl class="section note"><dt>Note</dt><dd>The elements being compared must support <a class="el" href="namespaceprism.html#ae53d52e8a36ec7ca58ea1731cc18f1d8">operator==()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c33653a5b4a07b31f5bde15e9085b45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::fill </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns <em>value</em> to all the elements in the range <em></em>[first,last]. </p>

</div>
</div>
<a class="anchor" id="aceb4b9c511a5edb706296b457427b226"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::fill_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns <em>value</em> to the first <em>n</em> elements of the sequence pointed by <em>first</em>. </p>

</div>
</div>
<a class="anchor" id="a1b543d9c2862a539cc8b770abda87561"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InputIterator prism::find </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator to the first element in the range <em></em>[first,last] that compares equal to <em>value</em>. If no such element is found, the function returns <em>last</em>. </p>

</div>
</div>
<a class="anchor" id="aa17e9e6c80f8a52479a52450a108a636"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InputIterator prism::find_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator to the first element in the range <em></em>[first,last] for which <em>pred</em> returns true. If no such element is found, the function returns <em>last</em>. </p>

</div>
</div>
<a class="anchor" id="a3189014b9fa31e0ef0d1933c6f616618"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InputIterator prism::find_last </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator to the last element in the range <em></em>[first,last] that compares equal to <em>value</em>. The range searched is <em></em>[first,last), which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. If no match is found then a null pointer is returned instead i.e. p=0; </p>

</div>
</div>
<a class="anchor" id="aae062d5bfdc0e53ae49c56520aded906"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Function prism::for_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies function <em>func</em> to each of the elements in the range <em></em>[first,last]. </p>

</div>
</div>
<a class="anchor" id="acf5efbeb096446c47690b9e8bd2cc01a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::is_sorted </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the elements in the range <em></em>[first,last] are sorted in ascending order, false otherwise. The range searched is <em></em>[first,last), which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. </p>

</div>
</div>
<a class="anchor" id="af8e36230e6cb92a41aaca282772a9e6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::make_heap </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rearranges the elements in the range <em></em>[first,last] so that they satisfy the order conditions of a heap.<br />
The range searched is <em></em>[first,last), which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. </p>

</div>
</div>
<a class="anchor" id="a812456273adfa37979e79f07e731d412"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; prism::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the largest of <em>a</em> and <em>b</em>. If they are equivalent then <em>a</em> is returned. </p>

</div>
</div>
<a class="anchor" id="a10aff0aca673fb1837069dd8967e4738"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; prism::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the smallest of <em>a</em> and <em>b</em>. If they are equivalent then <em>a</em> is returned. </p>

</div>
</div>
<a class="anchor" id="a10c83b433c7f98fd4513f1b68c6db594"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::none_of </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <em>pred</em> returns false for all the elements in the range <em></em>[first,last] or if the range is empty, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a9df924e4deb059bf1200701c8235410a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the managed pointers of p1 and p2 do not point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="ad6391c124e006b0e3a3ec67f55e208b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the managed pointer of p1 and the raw pointer p2 do not point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a249b6933154570d808cdd405ab1fd89b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the chars <em>c1</em> and <em>c2</em> are not equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8792dbd5cac5678390843bacdb69daa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the raw pointer p1 and the managed pointer of p2 do not point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="ae010d5880eb7bcf5119f006e26bf473f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if x or y of p1 and p2 are not equal, false if not </p>

</div>
</div>
<a class="anchor" id="a63ab3c18ecc73e21e7281dbe180e07e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the widths are equal and the heights are not equal of both <a class="el" href="classprism_1_1_size.html">Size</a> objects. </p>

</div>
</div>
<a class="anchor" id="aea72179b12983e614f72acd2b3cbf0e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if /em f1 does not equal /em f2 in value, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a75cab41d882d24ca064927f2390ef3a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if x or y of p1 and p2 are not equal, false if not </p>

</div>
</div>
<a class="anchor" id="a7e9d0b027a9e7d9e313affe5af91dabc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the vectors and returns true if a and b are not equal, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a1ffa413af039c2bff07202dcfce55f05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the vectors and returns true if a and b are not equal, false otherwise. </p>

</div>
</div>
<a class="anchor" id="aa752c5d0210902dece31c2fcfc98a824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the vectors and returns true if a and b are not equal, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a9e32551f997ae19dc52df146482405c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares q1 and q2 and returns true if they are not equal, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a58cbf7ef406800002b446a0f1e917745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if both circles are not equal, false otherwsie. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9f46c5ebd3cec844925173aaacbed9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the rectangles <em>r1</em> and <em>r2</em> are not equal, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a4d184994eec61a1511fc936a9facb69a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the elements of the two matrices and returns true if they don't contain the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a5c2215edf9ab445c3c1791217d131b15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac4f48e3429a86bafcc7c21a2bd6a7ae1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_fraction.html">Fraction</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies /em f1 and /em f2 together and returns a new <a class="el" href="classprism_1_1_fraction.html">Fraction</a>. <a class="el" href="classprism_1_1_fraction.html">Fraction</a> multiplication is the easiest arithmetical operation. Simply multiply the two numerators together to form the new numerator and multiply the two denominators together to form the new denominator. e.g. 2 8 2x8 16 4 &mdash; x &mdash; = &mdash; = &mdash; = &mdash; 5 4 5x4 20 5 </p>

</div>
</div>
<a class="anchor" id="a1f5007702b28b447f62c3b9df62f2aa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_fraction.html">Fraction</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies the <a class="el" href="classprism_1_1_fraction.html">Fraction</a> /em fraction by the whole number /em i. Returns a new <a class="el" href="classprism_1_1_fraction.html">Fraction</a>. </p>

</div>
</div>
<a class="anchor" id="ade1984e58679ef4d8fcdd37726ee6483"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_pointf.html">Pointf</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_pointf.html">Pointf</a> object that is formed by multiplying the components of p by the float factor </p>

</div>
</div>
<a class="anchor" id="a409aa6b61b79f029d78f6d4c3aba2df5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_pointf.html">Pointf</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af1ff5871f65565a84b886c5013bcd50a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_fraction.html">Fraction</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>fraction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies the whole number /em i by the <a class="el" href="classprism_1_1_fraction.html">Fraction</a> /em fraction. Returns a new <a class="el" href="classprism_1_1_fraction.html">Fraction</a>. </p>

</div>
</div>
<a class="anchor" id="a40976ce143923309d4c737bb8288d9e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> object that is formed by multiplying the components of p by the int factor </p>

</div>
</div>
<a class="anchor" id="a96e41c0858ff4149eafa1bc878dabb7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> object that is formed by multiplying the components of p by the float factor Note: the x and y components are rounded to the nearest integer as they are stored as ints internally. Use <a class="el" href="classprism_1_1_pointf.html">Pointf</a> for floating point accuracy instead. </p>

</div>
</div>
<a class="anchor" id="aa46a547ddc48425588986b0840d026a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> object that is formed by multiplying the components of p by the int factor </p>

</div>
</div>
<a class="anchor" id="a1ec2671f1e6c155a79740a8556baecc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> object that is formed by multiplying the components of p by the float factor Note: the x and y components are rounded to the nearest integer as they are stored as ints internally. Use <a class="el" href="classprism_1_1_pointf.html">Pointf</a> for floating point accuracy instead. </p>

</div>
</div>
<a class="anchor" id="a3d8e53ee3208e09e8736a77be3f485c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_size.html">Size</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies <em>size</em> by <em>factor</em> and returns a new <a class="el" href="classprism_1_1_size.html">Size</a> object. </p>

</div>
</div>
<a class="anchor" id="acd79758984cccce0dddfb459af65f6e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_size.html">Size</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies <em>size</em> by <em>factor</em> and returns a new <a class="el" href="classprism_1_1_size.html">Size</a> object. </p>

</div>
</div>
<a class="anchor" id="a6528ec4496096e8ccde186bb01fbeed3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector2.html">Vector2</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector2.html">Vector2</a> that has had each vector component of v multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="a1de3bc1dbc3fd33f26d580bce3520854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector2.html">Vector2</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector2.html">Vector2</a> that has had each vector component of v multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="a74c3eeec91c3a178711b6f05a5487d70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> that is the product of q1 and q2. Note: quaternion multiplication is associative so a(bc) = (ab)c but is not commutitive so q1q2 does not always equal q2q1. Order matters! </p>

</div>
</div>
<a class="anchor" id="aa652a61fe96302693aa0279e832360c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> that has had each vector component of v multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="ab3b4a59d9247143b49db3c2778838895"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> that has had each vector component of v multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="a429cccc5eee454ba019045afb4a01e93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> that has had each vector component of v multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="aa1f2f6de8bf1b584cbb82062a607e167"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> that has had each vector component of v multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="a45806b1a58ec5aae0db87d399d4d832b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> that is the result of multiplying each component of q by factor. </p>

</div>
</div>
<a class="anchor" id="ad9f03413053b1efa6851344eb39a5982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> that is the result of multiplying each component of q by factor. </p>

</div>
</div>
<a class="anchor" id="a8aebd3615ba448915f37140515a37b05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies a quaternion and vector3 together and returns a quaternion as a result. The vector is just transformed into a quaternion (setting w = 0) and then the two quaternions are multiplied. </p>

</div>
</div>
<a class="anchor" id="a2c4c5e120d8c4de9891f2261a50f100e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies a quaternion and <a class="el" href="classprism_1_1_vector4.html">Vector4</a> together and returns a quaternion as a result. The vector is just transformed into a quaternion and then the two quaternions are multiplied. </p>

</div>
</div>
<a class="anchor" id="a9ae44fb46bb709a5c8f4d592baf65522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> that is the product of m1 and m2 i.e. m1m2 </p>

</div>
</div>
<a class="anchor" id="ab3639f7bd46a54726522dfe406841ea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> where each component of m is multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="a4073983f089695c40b6fd20d892175f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> where each component of m is multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="aa2859acb8e8dd6fea8678e14249e561d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> that is the result of multiplying a <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> with a float array. </p>

</div>
</div>
<a class="anchor" id="a5e83bcd69595728106bed838aeb32f70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> that is the result of multiplying a <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> with a float array. </p>

</div>
</div>
<a class="anchor" id="a95ceb3342a808c88d0bb7c1f7e0ef82b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> which has been transformed by the matrix M in the order of vM. </p>

</div>
</div>
<a class="anchor" id="a04f1e6e0f84169fce23b236e0312d6a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> which has been transformed by the matrix M in the order of Mv. </p>

</div>
</div>
<a class="anchor" id="a5a10d8ea1e63b19d02bd294e4ebabb1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> which has been transformed by the matrix M in the order of vM. </p>

</div>
</div>
<a class="anchor" id="ad125bd8304d577b6f879fb973f774eb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> which has been transformed by the matrix M in the order of Mv. </p>

</div>
</div>
<a class="anchor" id="a44373b8bda7131a90d04eef7e455ea6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> which has been transformed by the matrix m in the order of pM </p>

</div>
</div>
<a class="anchor" id="a82522932359d2381607cf1fe0c898011"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> which has been transformed by the matrix M in the order of Mp </p>

</div>
</div>
<a class="anchor" id="ac1b5b2765c314b2baa2dba5c57419829"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_fraction.html">Fraction</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the fractions /em f1 and /em f2 together and returns a new <a class="el" href="classprism_1_1_fraction.html">Fraction</a>. If the two denominators are the same then the two numerators are added together to form the new numerator and the original denominator is kept the same. e.g. 1 1 2 &mdash; + &mdash; = &mdash; 4 4 4 If the denominators are different then we alter the fractions in order to make both denominators the same value. We make a whole fraction out of the second fraction's denominator and multiply it by the first fraction. Then make a whole fraction from the first fraction's denominator and multiply it by the second fraction. Now we can simply add together the two numerators and keep the denominator the same. 1 1 | 4 1 | | 1 2 | 4 2 6 3 &mdash; + &mdash; = |&mdash; x &mdash;| + |&mdash; x &mdash;| = &mdash; + &mdash; = &mdash; = &mdash; 2 4 | 4 2 | | 4 2 | 8 8 8 4 </p>

</div>
</div>
<a class="anchor" id="a64243aa2d4cf6ddb70526aaeda396f82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_pointf.html">Pointf</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_pointf.html">Pointf</a> object that is the sum of the components of p1 and p2 </p>

</div>
</div>
<a class="anchor" id="a49e983b5c32c93114583309eda19dc2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> object that is the sum of the components of p1 and p2 </p>

</div>
</div>
<a class="anchor" id="a7141aeb35db81548155e44d60c05530e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_size.html">Size</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds <em>s1</em> and <em>s2</em> together and returns a new <a class="el" href="classprism_1_1_size.html">Size</a> object. </p>

</div>
</div>
<a class="anchor" id="ae482804c32b466401a9ecdf26bc1e6de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector2.html">Vector2</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector2.html">Vector2</a> that is the result of adding the components of vector a and vector b. </p>

</div>
</div>
<a class="anchor" id="ad81bceaddc25922e571b4bf427ffe296"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> that is the sum of q1 and q2 i.e. each component of q1 is added to the corresponding component of q2. </p>

</div>
</div>
<a class="anchor" id="a4ac9ebc0ce1449793eb8f521c64929a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> that is the result of adding the components of vector a and vector b. </p>

</div>
</div>
<a class="anchor" id="a7ac90b31f235390d6feb818e3f88ecf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> that is the result of adding the components of vector a and vector b. </p>

</div>
</div>
<a class="anchor" id="a33537d30f01f996f8a05fc5b1b49ba3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> which is the sum of m1 and m2. </p>

</div>
</div>
<a class="anchor" id="a433f7afd310d95a93cf8c03d1f831812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classprism_1_1_string.html">String</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a50879e9455a36b7762514951ca0f47f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classprism_1_1_string.html">String</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7d59729f69eafd3bc9f4d30ad9dd06b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classprism_1_1_string.html">String</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa0fce6a8b93050fcb6db327e68b701e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classprism_1_1_string.html">String</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8ae68ccc6eb3a47a748671c1a7af88ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classprism_1_1_string.html">String</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2daf470e5f35f8450447deb2634c22c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_fraction.html">Fraction</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtracts the fractions /em f1 and /em f2 and returns a new <a class="el" href="classprism_1_1_fraction.html">Fraction</a>. If the two denominators are the same then the two numerators are subtracted to form the new numerator and the original denominator is kept the same. e.g. 3 1 2 &mdash; - &mdash; = &mdash; 4 4 4 If the denominators are different then we alter the fractions in order to make both denominators the same value. We make a whole fraction out of the second fraction's denominator and multiply it by the first fraction. Then make a whole fraction from the first fraction's denominator and multiply it by the second fraction. Now we can simply subtract the two numerators and keep the denominator the same. 3 1 | 2 3 | | 1 4 | 6 4 2 1 &mdash; - &mdash; = |&mdash; x &mdash;| - |&mdash; x &mdash;| = &mdash; - &mdash; = &mdash; = &mdash; 4 2 | 2 4 | | 2 4 | 8 8 8 4 </p>

</div>
</div>
<a class="anchor" id="a435d5c45d873875f2c5092d102eddb78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_pointf.html">Pointf</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_pointf.html">Pointf</a> object that is formed by subtracting the components of p2 from p1 </p>

</div>
</div>
<a class="anchor" id="a505cbd94f024ad80136afe0b751da08a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> object that is formed by subtracting the components of p2 from p1 </p>

</div>
</div>
<a class="anchor" id="ab170e3ca42d85a6766cbc7950ddfb0c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_size.html">Size</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtracts <em>s2</em> from <em>s1</em> and returns a new <a class="el" href="classprism_1_1_size.html">Size</a> object. </p>

</div>
</div>
<a class="anchor" id="a86359a88dc5245847de48575a1f969e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector2.html">Vector2</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector2.html">Vector2</a> that is the result of subtracting the components of vector b from vector a. Note: vector subtraction is not commutitive so a-b does not always equal b-a </p>

</div>
</div>
<a class="anchor" id="a124f1081b3a9bbc441dac9927f8a0fc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector2.html">Vector2</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector2.html">Vector2</a> object where each vector component of v has been negated. </p>

</div>
</div>
<a class="anchor" id="a5eae37b5dc73c544572686f215cea89d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> that is the result of subtracting q2 from q1 i.e. each component of q2 is subtracted from the corresponding component of q1. </p>

</div>
</div>
<a class="anchor" id="a038a64f530d1c50bf72cf1a23886ecca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> that is the result of subtracting the components of vector b from vector a. Note: vector subtraction is not commutitive so a-b does not always equal b-a </p>

</div>
</div>
<a class="anchor" id="ae04c2e5eae2242c58a967086ecad8ff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> which has had each component of q negated. </p>

</div>
</div>
<a class="anchor" id="a147712ae50c37618cbc61f20efe6729f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> object where each vector component of v has been negated. </p>

</div>
</div>
<a class="anchor" id="a3beb56b334423e027f1ab185785695f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> that is the result of subtracting the components of vector b from vector a. Note: vector subtraction is not commutitive so a-b does not always equal b-a </p>

</div>
</div>
<a class="anchor" id="a8f7cf835ff415e187e6881169803f502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> object where each vector component of v has been negated. </p>

</div>
</div>
<a class="anchor" id="a34a2f64f209065f753bed62a880b75b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> which is the result of subtracting m2 from m1. </p>

</div>
</div>
<a class="anchor" id="a879d3410d690b5722a9af17297f38fbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> where each component of matrix m has been negated (multiplyed by -1). </p>

</div>
</div>
<a class="anchor" id="a71504f6dd299e8bc788e07d11d29dc5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_pointf.html">Pointf</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_pointf.html">Pointf</a> object that is formed by dividing the components of p by divisor </p>

</div>
</div>
<a class="anchor" id="a7ba7b5cc9750f0d6cda50f0cb874da6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_fraction.html">Fraction</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divides /em f1 by /em f2 and returns a new <a class="el" href="classprism_1_1_fraction.html">Fraction</a>. <a class="el" href="classprism_1_1_fraction.html">Fraction</a> division is achieved by taking the reciprocal of the second fraction and multiplying it against the first fraction. See /em <a class="el" href="classprism_1_1_fraction.html#aab12f13967ca16e8956618f9d0641c31">Fraction::reciprocal()</a> for more information. 3 2 3 7 21 &mdash; / &mdash; = &mdash; * &mdash; = &mdash; 4 7 4 2 8 </p>

</div>
</div>
<a class="anchor" id="a5f73aee33931e5b9977da32e50d47c0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> object that is formed by dividing the components of p1 by the components of p2 </p>

</div>
</div>
<a class="anchor" id="ad7e100bd6b1730deaab53d1218e29a67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_size.html">Size</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divides <em>size</em> by <em>factor</em> rounding to integer precision and returns a new <a class="el" href="classprism_1_1_size.html">Size</a> object. </p>

</div>
</div>
<a class="anchor" id="aea1ab02785c9d4d5ea560face252b75e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector2.html">Vector2</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector2.html">Vector2</a> where each component of vector v has been divided by divisor. If divisor is 0 then a zero vector is returned instead. </p>

</div>
</div>
<a class="anchor" id="a4aa2b9a75c3d5134fc80cc6afc1be443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> where each component of vector v has been divided by divisor. If divisor is 0 then a zero vector is returned instead. </p>

</div>
</div>
<a class="anchor" id="a87e022748076586917c38e83430df284"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> where each component of vector v has been divided by divisor. If divisor is 0 then a zero vector is returned instead. </p>

</div>
</div>
<a class="anchor" id="aec648937a53338bcd9879670877d0425"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> that is the result of dividing each component of q by divisor. If divisor is 0 then a identity quaternion is returned instead. </p>

</div>
</div>
<a class="anchor" id="a517b4bc9b0ccc23f79b744d93b540fa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> where each component of matrix m is divided by divisor. If divisor is 0 a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> is returned set to the identity matrix instead. </p>

</div>
</div>
<a class="anchor" id="a2fc3e64ba36a16f24cb0ae387c83f35f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the unicode value of <em>c1</em> is less than <em>c2</em>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a105ac9995ade66ebb2a039ef90751c7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if /em f1 is less than /em f2, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a8e662d15b162ca76912c491798caefd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if <em>c1</em> has a smaller radius than <em>c2</em>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acad408bf2576dfc62a573cb44aa895fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an ostream object that allows this object to printed with std::cout </p>

</div>
</div>
<a class="anchor" id="acb9fe7ab8ef5f1ee0338e3b057624393"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an ostream object that allows this object to printed with std::cout </p>

</div>
</div>
<a class="anchor" id="aa67ea1154a35dabe9c2c232aff65e930"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_char.html">Char</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="a9c2d182a77a92e6cba7917dbd58f9d87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_fraction.html">Fraction</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="ad6335168e27f481d86ae42da444006d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_size.html">Size</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="a4616180b97f4288a3b3e28304efee020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_vector2.html">Vector2</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="aeb86919d9ba71747d21fbd6e28671692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_vector4.html">Vector4</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="aa7b9367a483153af865552ba486f1196"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_vector3.html">Vector3</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="ad2beaed7a837821f0abc608cf6ac6c0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to a stream which allows an instance of <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> to be written to the stream. </p>

</div>
</div>
<a class="anchor" id="a403ca8f79c481a89132691c0fd8c3a06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa63d3d39d3fad8fa5c5966cc4f306324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_circle.html">Circle</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="a52fd2a97b66b06ba6e451e1890136ff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_rect.html">Rect</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="a50da64555d454821545fe0311fde6a62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_list.html">List</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outputs a human-friendly summary of <em>list</em> to the stream <em>out</em>. </p>

</div>
</div>
<a class="anchor" id="ab65e15b3e601e0570beb49a11610c671"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of Matrx4x4 to be written to the ostream out and returns a reference to the ostream. i.e. std::cout &lt;&lt; matrix &lt;&lt; std::endl; </p>

</div>
</div>
<a class="anchor" id="a0a166bbf645cc854542cc0fc50324670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_string.html">String</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="a87d86e9266469c8a40537e12a560b066"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the unicode value of <em>c1</em> is less than or equal to <em>c2</em>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ba68b64a6cfdcff9e144b8c2476cddb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the chars <em>c1</em> and <em>c2</em> are equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a13ab889958edc08eea9a5bea056cd9c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if x and y of p1 and p2 are equal, false if not </p>

</div>
</div>
<a class="anchor" id="a2a7baeb09cd2ee29251667ad18a2bd00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>========================================================== </p><h1>Related non-members </h1>
<p>Returns true if the widths are equal and the heights are equal of both <a class="el" href="classprism_1_1_size.html">Size</a> objects. </p>

</div>
</div>
<a class="anchor" id="ae53d52e8a36ec7ca58ea1731cc18f1d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the managed pointers of p1 and p2 point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a2b73e87f080646696ed6b595a3900119"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the managed pointer of p1 and the raw pointer p2 point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a5b9e84008b9eaa99d29d4b74cd150cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if /em f1 and /em f2 are equal in value. </p>

</div>
</div>
<a class="anchor" id="a1f29b22985dc0ec1fc548a551ce313ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the raw pointer p1 and the managed pointer of p2 point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a739baa4e75c1ca83624d486eec1d45e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if x and y of p1 and p2 are equal, false if not </p>

</div>
</div>
<a class="anchor" id="a311fc983ec89876189643e840d781974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the two vectors and if each of the corresponding components are equal in value then true is returned, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a80bdef743a64c754bf1a2b217c82f60a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the two vectors and if each of the corresponding components are equal in value then true is returned, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a2fc2a483f2e3ec622ad2c0ac9699fbcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the two vectors and if each of the corresponding components are equal in value then true is returned, false otherwise. </p>

</div>
</div>
<a class="anchor" id="ac4ae112433b9ab32c801cccc9c3f74f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares q1 and q2 and returns true if they are equal, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a0ce1ad6e6392618212d5ab3bebb8e585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if both circles have the same radius and (x,y) centre point, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abe409fa2ef458a2d477ed7845cf4b6a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>===================================================================== </p><h1>Related non-members </h1>
<p>Returns true if the rectangles <em>r1</em> and <em>r2</em> are equal, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a8804ec2ab8dda9441d64e947f05e293c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the elements of the two matrices and returns true if they contain the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a0e7bfee93ae735b5af7e566ddd8c4f65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab8a312729c4c9ae72836d0034a6f0758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the unicode value of <em>c1</em> is greater than <em>c2</em>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7122a7ff43fc6aba9cef9d31fe8c7559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if /em f1 is less than /em f2, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a671739ac8567654dba563c34af92213f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if <em>c1</em> has a greater radius than <em>c2</em>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aad049ddef9beb3fec3e7057a7f651280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the unicode value of <em>c1</em> is greater than or equal to <em>c2</em>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f2c83ae0d89a6581d1c42ba6fd79de0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::p_heapify </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Private recursive function called by <a class="el" href="namespaceprism.html#af8e36230e6cb92a41aaca282772a9e6e">make_heap()</a>. Compares a node with its two children (if it has any) and ensures that the largest of the three nodes is the parent node. </p>

</div>
</div>
<a class="anchor" id="aeddd21943bcf811c56f7d9d1bd4784f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator prism::remove </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms the range <em></em>[first,last] into a range with all the elements that compare equal to <em>value</em> removed, and returns an iterator to the new end of that range. </p>

</div>
</div>
<a class="anchor" id="ab7b6fb407340e51749169560b48fb20c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::remove_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] to the range beginning at <em>otherFirst</em>, except those elements that compare equal to <em>value</em>. </p>

</div>
</div>
<a class="anchor" id="abfc7da1f951e480a26d58fc098b78844"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::remove_copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] to the range beginning at <em>otherFirst</em>, except those elements for which <em>pred</em> returns true. </p>

</div>
</div>
<a class="anchor" id="a2e9d25191ed83ea0a193f16d9c0a00b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator prism::remove_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms the range <em></em>[first,last] into a range with all the elements for which <em>pred</em> returns true removed, and returns an iterator to the new end of that range. </p>

</div>
</div>
<a class="anchor" id="a6156070b98de7130b8c912ae3a6d333f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::replace </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>oldValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns <em>newValue</em> to all the elements in the range <em></em>[first,last] that compare equal to <em>oldValue</em>. </p>

</div>
</div>
<a class="anchor" id="a16d85ecb70d2f216714a0146a057a105"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::replace_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>oldValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] to the range beginning at <em>otherFirst</em>, replacing the appearances of <em>oldValue</em> by <em>newValue</em>. </p>

</div>
</div>
<a class="anchor" id="a55d702599739f7137516dcd095119f15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class Predicate , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::replace_copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] to the range beginning at <em>otherFirst</em>, replacing those for which <em>pred</em> returns true by newValue. </p>

</div>
</div>
<a class="anchor" id="af118c19f6b5448319eb3aaf2d556ac54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class Predicate , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::replace_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns <em>newValue</em> to all the elements in the range <em></em>[first,last] for which <em>pred</em> returns true. </p>

</div>
</div>
<a class="anchor" id="affcb3e5150d72d9f79b85b9ea4eb41e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator1 prism::search </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the range [first1,last1] for the first occurrence of the sequence defined by [first2,last2], and returns an iterator to its first element, or last1 if no occurrences are found. The range used is [first1,last1], which contains all the elements between first1 and last1, including the element pointed by first1 but not the element pointed by last1. </p>

</div>
</div>
<a class="anchor" id="a9bf397cad0a67b67fbd1ecddf40d405e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the elements in the range <em></em>[first,last] in ascending order using the quicksort algorithm. The range used is [first1,last1], which contains all the elements between first1 and last1, including the element pointed by first1 but not the element pointed by last1. <br />
Currently <em><a class="el" href="namespaceprism.html#a9bf397cad0a67b67fbd1ecddf40d405e">sort()</a></em> is implemented using the quicksort algorithm which averages a reasonable O(n log(n)) complexity. </p>

</div>
</div>
<a class="anchor" id="aa597d262eb2f9ef80703c883a2d18d1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort_bubble </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the elements in the range <em></em>[first, last] in ascending order using the Bubble Sort algorithm. <br />
The range used is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. </p><dl class="section note"><dt>Note</dt><dd>The objects being sorted must support <a class="el" href="namespaceprism.html#ab8a312729c4c9ae72836d0034a6f0758">operator&gt;()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e9fe74c5dcee70bf5dd5c89f1234a02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort_heap </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the elements in the range <em></em>[first,last] using the heapsort algorithm. <br />
The elements are first rearranged so that they satisfy the ordering of a heap (by a call to <a class="el" href="namespaceprism.html#af8e36230e6cb92a41aaca282772a9e6e">make_heap()</a>).<br />
The range used is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. </p>

</div>
</div>
<a class="anchor" id="a720fbbcb3f399b006969bb00a66686f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort_quicksort </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the elements in the range <em></em>[first, last] in ascending order using the Quicksort algorithm. <br />
The range used is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. </p><dl class="section note"><dt>Note</dt><dd>The objects being sorted must support <a class="el" href="namespaceprism.html#a87d86e9266469c8a40537e12a560b066">operator&lt;=()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6430516ab4f2e2a7f43323acb6b559d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exchanges the values of <em>a</em> and <em>b</em>. </p>

</div>
</div>
<a class="anchor" id="a4661f2c0c4dca098c137179b4d93f3dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator2 prism::swap_ranges </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exchanges the values of each of the elements in the range <em></em>[first1,last1] with those of their respective elements in the range beginning at <em>otherFirst</em>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceprism.html">prism</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
