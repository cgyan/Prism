<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Prism API: prism Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Prism API
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">prism Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_abstract_tree.html">AbstractTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_allocator.html">Allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_allocator_traits.html">AllocatorTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed size sequence based container.  <a href="classprism_1_1_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_associative_iterator.html">AssociativeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_binary_search_tree.html">BinarySearchTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_bitvector.html">Bitvector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_b_s_t_data.html">BSTData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_b_s_t_memory.html">BSTMemory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_b_s_t_node.html">BSTNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_char.html">Char</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_circle.html">Circle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents a circle.  <a href="classprism_1_1_circle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1conditional__type.html">conditional_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1conditional__type_3_01false_00_01_t1_00_01_t2_01_4.html">conditional_type&lt; false, T1, T2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_deque.html">Deque</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_deque_data.html">DequeData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1even.html">even</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_exception.html">Exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_flag.html">Flag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_flags.html">Flags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1forward__iterator__tag.html">forward_iterator_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_fraction.html">Fraction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1greater.html">greater</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1input__iterator__tag.html">input_iterator_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_integral_constant.html">IntegralConstant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_is_arithmetic.html">IsArithmetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_is_floating_point.html">IsFloatingPoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_is_fundamental.html">IsFundamental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_is_integral.html">IsIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_is_same__aux.html">IsSame_aux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1iterator__traits.html">iterator_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1iterator__traits_3_01const_01_t_01_5_01_4.html">iterator_traits&lt; const T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1iterator__traits_3_01_t_01_5_01_4.html">iterator_traits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1less.html">less</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_list.html">List</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node-based container.  <a href="classprism_1_1_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_log_allocator.html">LogAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_map.html">Map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_mathf.html">Mathf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_obj.html">Obj</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1odd.html">odd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_out_of_bounds_exception.html">OutOfBoundsException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1output__iterator__tag.html">output_iterator_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_overflow_exception.html">OverflowException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1pair.html">pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_point.html">Point</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_pointf.html">Pointf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_prism_version.html">PrismVersion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_queue.html">Queue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1random__access__iterator__tag.html">random_access_iterator_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_rect.html">Rect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_reference_counter.html">ReferenceCounter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_sequence_iterator.html">SequenceIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_shared_data.html">SharedData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_shared_data_pointer.html">SharedDataPointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_size.html">Size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_stack.html">Stack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_string.html">String</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_time.html">Time</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_unequal_size_exception.html">UnequalSizeException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_vector.html">Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_vector2.html">Vector2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_vector3.html">Vector3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_vector4.html">Vector4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_vector_data.html">VectorData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_version.html">Version</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7d28160dd23799e4294e2d705294f16f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structprism_1_1_integral_constant.html">IntegralConstant</a>&lt; bool, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7d28160dd23799e4294e2d705294f16f">TrueType</a></td></tr>
<tr class="separator:a7d28160dd23799e4294e2d705294f16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11baa40bd94b92172c01957db05a76f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structprism_1_1_integral_constant.html">IntegralConstant</a>&lt; bool, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab11baa40bd94b92172c01957db05a76f">FalseType</a></td></tr>
<tr class="separator:ab11baa40bd94b92172c01957db05a76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a82052418345794a13044c15d8e32dd89"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a82052418345794a13044c15d8e32dd89"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a82052418345794a13044c15d8e32dd89">adjacent_find</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="memdesc:a82052418345794a13044c15d8e32dd89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds two consecutive matching elements in a range.  <a href="#a82052418345794a13044c15d8e32dd89">More...</a><br /></td></tr>
<tr class="separator:a82052418345794a13044c15d8e32dd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2de9cb16507b1e1b73597c308cafa6c"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:ad2de9cb16507b1e1b73597c308cafa6c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad2de9cb16507b1e1b73597c308cafa6c">all_of</a> (InputIterator first, InputIterator last, UnaryPredicate pred)</td></tr>
<tr class="memdesc:ad2de9cb16507b1e1b73597c308cafa6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all the elements match a condition in a range.  <a href="#ad2de9cb16507b1e1b73597c308cafa6c">More...</a><br /></td></tr>
<tr class="separator:ad2de9cb16507b1e1b73597c308cafa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06451218f60335b732769b55b683321"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:ab06451218f60335b732769b55b683321"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab06451218f60335b732769b55b683321">any_of</a> (InputIterator first, InputIterator last, UnaryPredicate pred)</td></tr>
<tr class="memdesc:ab06451218f60335b732769b55b683321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any elements match a condition in a range.  <a href="#ab06451218f60335b732769b55b683321">More...</a><br /></td></tr>
<tr class="separator:ab06451218f60335b732769b55b683321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae776f4cd825f79e7af1cf6ee1d90a209"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ae776f4cd825f79e7af1cf6ee1d90a209"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae776f4cd825f79e7af1cf6ee1d90a209">copy</a> (InputIterator first, InputIterator last, OutputIterator otherFirst)</td></tr>
<tr class="memdesc:ae776f4cd825f79e7af1cf6ee1d90a209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from one range to another range.  <a href="#ae776f4cd825f79e7af1cf6ee1d90a209">More...</a><br /></td></tr>
<tr class="separator:ae776f4cd825f79e7af1cf6ee1d90a209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2564c63b76369cc81ff725a56e818046"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator1 , class BidirectionalIterator2 &gt; </td></tr>
<tr class="memitem:a2564c63b76369cc81ff725a56e818046"><td class="memTemplItemLeft" align="right" valign="top">BidirectionalIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2564c63b76369cc81ff725a56e818046">copy_backward</a> (BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 otherLast)</td></tr>
<tr class="memdesc:a2564c63b76369cc81ff725a56e818046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range to another range backwards.  <a href="#a2564c63b76369cc81ff725a56e818046">More...</a><br /></td></tr>
<tr class="separator:a2564c63b76369cc81ff725a56e818046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd8d05b64877fd3c6d1af2cfe3d3e81"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:adcd8d05b64877fd3c6d1af2cfe3d3e81"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#adcd8d05b64877fd3c6d1af2cfe3d3e81">copy_if</a> (InputIterator first, InputIterator last, OutputIterator otherFirst, UnaryPredicate pred)</td></tr>
<tr class="memdesc:adcd8d05b64877fd3c6d1af2cfe3d3e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from a range to another range only if they meet a condition.  <a href="#adcd8d05b64877fd3c6d1af2cfe3d3e81">More...</a><br /></td></tr>
<tr class="separator:adcd8d05b64877fd3c6d1af2cfe3d3e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af907f3f5637d4ec056e9b833b6272953"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Size , class OutputIterator &gt; </td></tr>
<tr class="memitem:af907f3f5637d4ec056e9b833b6272953"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af907f3f5637d4ec056e9b833b6272953">copy_n</a> (InputIterator first, <a class="el" href="classprism_1_1_size.html">Size</a> n, OutputIterator otherFirst)</td></tr>
<tr class="memdesc:af907f3f5637d4ec056e9b833b6272953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a specified number of elements from one range to another range.  <a href="#af907f3f5637d4ec056e9b833b6272953">More...</a><br /></td></tr>
<tr class="separator:af907f3f5637d4ec056e9b833b6272953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024117fc3639cdf6598509edf22f034a"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class T &gt; </td></tr>
<tr class="memitem:a024117fc3639cdf6598509edf22f034a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a024117fc3639cdf6598509edf22f034a">count</a> (InputIterator first, InputIterator last, const T &amp;value)</td></tr>
<tr class="memdesc:a024117fc3639cdf6598509edf22f034a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of occurrences of a value in a range.  <a href="#a024117fc3639cdf6598509edf22f034a">More...</a><br /></td></tr>
<tr class="separator:a024117fc3639cdf6598509edf22f034a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124ac016ee2a8ab3844c9af6daf5b4a6"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a124ac016ee2a8ab3844c9af6daf5b4a6"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a124ac016ee2a8ab3844c9af6daf5b4a6">count_if</a> (InputIterator first, InputIterator last, UnaryPredicate pred)</td></tr>
<tr class="memdesc:a124ac016ee2a8ab3844c9af6daf5b4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of occurrences of a value that meets a condition in a range.  <a href="#a124ac016ee2a8ab3844c9af6daf5b4a6">More...</a><br /></td></tr>
<tr class="separator:a124ac016ee2a8ab3844c9af6daf5b4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bede9a0f2c648e93677b14c45b1b7b"><td class="memTemplParams" colspan="2">template&lt;class InputIterator1 , class InputIterator2 &gt; </td></tr>
<tr class="memitem:ad3bede9a0f2c648e93677b14c45b1b7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad3bede9a0f2c648e93677b14c45b1b7b">equal</a> (InputIterator1 first, InputIterator1 last, InputIterator2 otherFirst)</td></tr>
<tr class="memdesc:ad3bede9a0f2c648e93677b14c45b1b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ranges for equality.  <a href="#ad3bede9a0f2c648e93677b14c45b1b7b">More...</a><br /></td></tr>
<tr class="separator:ad3bede9a0f2c648e93677b14c45b1b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c33653a5b4a07b31f5bde15e9085b45"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:a7c33653a5b4a07b31f5bde15e9085b45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45">fill</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>
<tr class="memdesc:a7c33653a5b4a07b31f5bde15e9085b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a range with a value.  <a href="#a7c33653a5b4a07b31f5bde15e9085b45">More...</a><br /></td></tr>
<tr class="separator:a7c33653a5b4a07b31f5bde15e9085b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb4b9c511a5edb706296b457427b226"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:aceb4b9c511a5edb706296b457427b226"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aceb4b9c511a5edb706296b457427b226">fill_n</a> (ForwardIterator first, int size, const T &amp;value)</td></tr>
<tr class="memdesc:aceb4b9c511a5edb706296b457427b226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a value to a specified number of elements in a range.  <a href="#aceb4b9c511a5edb706296b457427b226">More...</a><br /></td></tr>
<tr class="separator:aceb4b9c511a5edb706296b457427b226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b543d9c2862a539cc8b770abda87561"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class T &gt; </td></tr>
<tr class="memitem:a1b543d9c2862a539cc8b770abda87561"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1b543d9c2862a539cc8b770abda87561">find</a> (InputIterator first, InputIterator last, const T &amp;value)</td></tr>
<tr class="memdesc:a1b543d9c2862a539cc8b770abda87561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a value in a range.  <a href="#a1b543d9c2862a539cc8b770abda87561">More...</a><br /></td></tr>
<tr class="separator:a1b543d9c2862a539cc8b770abda87561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411641547f43e750a186c89bf0dd5a59"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a411641547f43e750a186c89bf0dd5a59"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a411641547f43e750a186c89bf0dd5a59">find_if</a> (InputIterator first, InputIterator last, UnaryPredicate pred)</td></tr>
<tr class="memdesc:a411641547f43e750a186c89bf0dd5a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first value in a range for which a predicate returns true.  <a href="#a411641547f43e750a186c89bf0dd5a59">More...</a><br /></td></tr>
<tr class="separator:a411641547f43e750a186c89bf0dd5a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3189014b9fa31e0ef0d1933c6f616618"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class T &gt; </td></tr>
<tr class="memitem:a3189014b9fa31e0ef0d1933c6f616618"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a3189014b9fa31e0ef0d1933c6f616618">find_last</a> (InputIterator first, InputIterator last, const T &amp;value)</td></tr>
<tr class="memdesc:a3189014b9fa31e0ef0d1933c6f616618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last value in a range that matches a specified value.  <a href="#a3189014b9fa31e0ef0d1933c6f616618">More...</a><br /></td></tr>
<tr class="separator:a3189014b9fa31e0ef0d1933c6f616618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f65de889707907c02a325d8a4ff4aec"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class UnaryFunction &gt; </td></tr>
<tr class="memitem:a9f65de889707907c02a325d8a4ff4aec"><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9f65de889707907c02a325d8a4ff4aec">for_each</a> (InputIterator first, InputIterator last, UnaryFunction func)</td></tr>
<tr class="memdesc:a9f65de889707907c02a325d8a4ff4aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function for each element in a range.  <a href="#a9f65de889707907c02a325d8a4ff4aec">More...</a><br /></td></tr>
<tr class="separator:a9f65de889707907c02a325d8a4ff4aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5efbeb096446c47690b9e8bd2cc01a"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:acf5efbeb096446c47690b9e8bd2cc01a"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#acf5efbeb096446c47690b9e8bd2cc01a">is_sorted</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="memdesc:acf5efbeb096446c47690b9e8bd2cc01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a range is sorted in ascending order.  <a href="#acf5efbeb096446c47690b9e8bd2cc01a">More...</a><br /></td></tr>
<tr class="separator:acf5efbeb096446c47690b9e8bd2cc01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e36230e6cb92a41aaca282772a9e6e"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator &gt; </td></tr>
<tr class="memitem:af8e36230e6cb92a41aaca282772a9e6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af8e36230e6cb92a41aaca282772a9e6e">make_heap</a> (RandomAccessIterator first, RandomAccessIterator last)</td></tr>
<tr class="memdesc:af8e36230e6cb92a41aaca282772a9e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges a range into a heap order.  <a href="#af8e36230e6cb92a41aaca282772a9e6e">More...</a><br /></td></tr>
<tr class="separator:af8e36230e6cb92a41aaca282772a9e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812456273adfa37979e79f07e731d412"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a812456273adfa37979e79f07e731d412"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a812456273adfa37979e79f07e731d412">max</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a812456273adfa37979e79f07e731d412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which value is greater.  <a href="#a812456273adfa37979e79f07e731d412">More...</a><br /></td></tr>
<tr class="separator:a812456273adfa37979e79f07e731d412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aff0aca673fb1837069dd8967e4738"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a10aff0aca673fb1837069dd8967e4738"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a10aff0aca673fb1837069dd8967e4738">min</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a10aff0aca673fb1837069dd8967e4738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which value is lesser.  <a href="#a10aff0aca673fb1837069dd8967e4738">More...</a><br /></td></tr>
<tr class="separator:a10aff0aca673fb1837069dd8967e4738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c43dafd5926d3dc6ce698ae8938810d"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a3c43dafd5926d3dc6ce698ae8938810d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a3c43dafd5926d3dc6ce698ae8938810d">none_of</a> (InputIterator first, InputIterator last, UnaryPredicate pred)</td></tr>
<tr class="memdesc:a3c43dafd5926d3dc6ce698ae8938810d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks elements in a range to see if they don't match a condition.  <a href="#a3c43dafd5926d3dc6ce698ae8938810d">More...</a><br /></td></tr>
<tr class="separator:a3c43dafd5926d3dc6ce698ae8938810d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddd21943bcf811c56f7d9d1bd4784f6"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:aeddd21943bcf811c56f7d9d1bd4784f6"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aeddd21943bcf811c56f7d9d1bd4784f6">remove</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>
<tr class="memdesc:aeddd21943bcf811c56f7d9d1bd4784f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements that equal a value in a range.  <a href="#aeddd21943bcf811c56f7d9d1bd4784f6">More...</a><br /></td></tr>
<tr class="separator:aeddd21943bcf811c56f7d9d1bd4784f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b6fb407340e51749169560b48fb20c"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class T &gt; </td></tr>
<tr class="memitem:ab7b6fb407340e51749169560b48fb20c"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab7b6fb407340e51749169560b48fb20c">remove_copy</a> (InputIterator first, InputIterator last, OutputIterator otherFirst, const T &amp;value)</td></tr>
<tr class="memdesc:ab7b6fb407340e51749169560b48fb20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from a range that don't match a value into another range.  <a href="#ab7b6fb407340e51749169560b48fb20c">More...</a><br /></td></tr>
<tr class="separator:ab7b6fb407340e51749169560b48fb20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc7da1f951e480a26d58fc098b78844"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:abfc7da1f951e480a26d58fc098b78844"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#abfc7da1f951e480a26d58fc098b78844">remove_copy_if</a> (InputIterator first, InputIterator last, OutputIterator otherFirst, UnaryPredicate pred)</td></tr>
<tr class="memdesc:abfc7da1f951e480a26d58fc098b78844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from a range for which a predicate returns false into another range.  <a href="#abfc7da1f951e480a26d58fc098b78844">More...</a><br /></td></tr>
<tr class="separator:abfc7da1f951e480a26d58fc098b78844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252483ee5c3c08a0b99b67510371583d"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a252483ee5c3c08a0b99b67510371583d"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a252483ee5c3c08a0b99b67510371583d">remove_if</a> (ForwardIterator first, ForwardIterator last, UnaryPredicate pred)</td></tr>
<tr class="memdesc:a252483ee5c3c08a0b99b67510371583d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from a range for which a predicate returns true.  <a href="#a252483ee5c3c08a0b99b67510371583d">More...</a><br /></td></tr>
<tr class="separator:a252483ee5c3c08a0b99b67510371583d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6156070b98de7130b8c912ae3a6d333f"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:a6156070b98de7130b8c912ae3a6d333f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a6156070b98de7130b8c912ae3a6d333f">replace</a> (ForwardIterator first, ForwardIterator last, const T &amp;oldValue, const T &amp;newValue)</td></tr>
<tr class="memdesc:a6156070b98de7130b8c912ae3a6d333f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a value with a new value in a range.  <a href="#a6156070b98de7130b8c912ae3a6d333f">More...</a><br /></td></tr>
<tr class="separator:a6156070b98de7130b8c912ae3a6d333f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d85ecb70d2f216714a0146a057a105"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class T &gt; </td></tr>
<tr class="memitem:a16d85ecb70d2f216714a0146a057a105"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a16d85ecb70d2f216714a0146a057a105">replace_copy</a> (InputIterator first, InputIterator last, OutputIterator otherFirst, const T &amp;oldValue, const T &amp;newValue)</td></tr>
<tr class="memdesc:a16d85ecb70d2f216714a0146a057a105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from one range to another range replacing one value with another value.  <a href="#a16d85ecb70d2f216714a0146a057a105">More...</a><br /></td></tr>
<tr class="separator:a16d85ecb70d2f216714a0146a057a105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48a460cd28a7965f460dfb98e68fa39"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class UnaryPredicate , class T &gt; </td></tr>
<tr class="memitem:ac48a460cd28a7965f460dfb98e68fa39"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ac48a460cd28a7965f460dfb98e68fa39">replace_copy_if</a> (InputIterator first, InputIterator last, OutputIterator otherFirst, UnaryPredicate pred, const T &amp;newValue)</td></tr>
<tr class="memdesc:ac48a460cd28a7965f460dfb98e68fa39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from one range to another range replacing each element that a predicate returns true for with a new value.  <a href="#ac48a460cd28a7965f460dfb98e68fa39">More...</a><br /></td></tr>
<tr class="separator:ac48a460cd28a7965f460dfb98e68fa39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7742cad186e8ce8764ee48ff1fbfd4cf"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class UnaryPredicate , class T &gt; </td></tr>
<tr class="memitem:a7742cad186e8ce8764ee48ff1fbfd4cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7742cad186e8ce8764ee48ff1fbfd4cf">replace_if</a> (ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T &amp;newValue)</td></tr>
<tr class="memdesc:a7742cad186e8ce8764ee48ff1fbfd4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a new value to all elements for which a predicate returns true.  <a href="#a7742cad186e8ce8764ee48ff1fbfd4cf">More...</a><br /></td></tr>
<tr class="separator:a7742cad186e8ce8764ee48ff1fbfd4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dbb806369b062fd90909fd826c2ee4"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </td></tr>
<tr class="memitem:a03dbb806369b062fd90909fd826c2ee4"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a03dbb806369b062fd90909fd826c2ee4">search</a> (ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 otherFirst, ForwardIterator2 otherLast)</td></tr>
<tr class="memdesc:a03dbb806369b062fd90909fd826c2ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a range for a sub-range.  <a href="#a03dbb806369b062fd90909fd826c2ee4">More...</a><br /></td></tr>
<tr class="separator:a03dbb806369b062fd90909fd826c2ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2955433bd872919cf59580c1a464c93"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator &gt; </td></tr>
<tr class="memitem:aa2955433bd872919cf59580c1a464c93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa2955433bd872919cf59580c1a464c93">sort_bubble</a> (BidirectionalIterator first, BidirectionalIterator last)</td></tr>
<tr class="memdesc:aa2955433bd872919cf59580c1a464c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in a range in ascending order.  <a href="#aa2955433bd872919cf59580c1a464c93">More...</a><br /></td></tr>
<tr class="separator:aa2955433bd872919cf59580c1a464c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9fe74c5dcee70bf5dd5c89f1234a02"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator &gt; </td></tr>
<tr class="memitem:a1e9fe74c5dcee70bf5dd5c89f1234a02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1e9fe74c5dcee70bf5dd5c89f1234a02">sort_heap</a> (RandomAccessIterator first, RandomAccessIterator last)</td></tr>
<tr class="memdesc:a1e9fe74c5dcee70bf5dd5c89f1234a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in a range in ascending order.  <a href="#a1e9fe74c5dcee70bf5dd5c89f1234a02">More...</a><br /></td></tr>
<tr class="separator:a1e9fe74c5dcee70bf5dd5c89f1234a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cbe49b782032932d0da83860e7b368"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator &gt; </td></tr>
<tr class="memitem:ad8cbe49b782032932d0da83860e7b368"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad8cbe49b782032932d0da83860e7b368">sort_quicksort</a> (BidirectionalIterator first, BidirectionalIterator last)</td></tr>
<tr class="memdesc:ad8cbe49b782032932d0da83860e7b368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in a range in ascending order.  <a href="#ad8cbe49b782032932d0da83860e7b368">More...</a><br /></td></tr>
<tr class="separator:ad8cbe49b782032932d0da83860e7b368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfe9ea0146b59b2b16adee4cd2220b9"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator &gt; </td></tr>
<tr class="memitem:addfe9ea0146b59b2b16adee4cd2220b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#addfe9ea0146b59b2b16adee4cd2220b9">sort</a> (BidirectionalIterator first, BidirectionalIterator last)</td></tr>
<tr class="memdesc:addfe9ea0146b59b2b16adee4cd2220b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in a range in ascending order.  <a href="#addfe9ea0146b59b2b16adee4cd2220b9">More...</a><br /></td></tr>
<tr class="separator:addfe9ea0146b59b2b16adee4cd2220b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6430516ab4f2e2a7f43323acb6b559d8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6430516ab4f2e2a7f43323acb6b559d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a6430516ab4f2e2a7f43323acb6b559d8">swap</a> (T &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:a6430516ab4f2e2a7f43323acb6b559d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the values of two variables.  <a href="#a6430516ab4f2e2a7f43323acb6b559d8">More...</a><br /></td></tr>
<tr class="separator:a6430516ab4f2e2a7f43323acb6b559d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4661f2c0c4dca098c137179b4d93f3dc"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </td></tr>
<tr class="memitem:a4661f2c0c4dca098c137179b4d93f3dc"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a4661f2c0c4dca098c137179b4d93f3dc">swap_ranges</a> (ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 otherFirst)</td></tr>
<tr class="memdesc:a4661f2c0c4dca098c137179b4d93f3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the elements in two ranges.  <a href="#a4661f2c0c4dca098c137179b4d93f3dc">More...</a><br /></td></tr>
<tr class="separator:a4661f2c0c4dca098c137179b4d93f3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8234c2c7917f750db94bb068d6fd554e"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:a8234c2c7917f750db94bb068d6fd554e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8234c2c7917f750db94bb068d6fd554e">uninitialized_fill</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>
<tr class="memdesc:a8234c2c7917f750db94bb068d6fd554e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an uninitialized range with a value.  <a href="#a8234c2c7917f750db94bb068d6fd554e">More...</a><br /></td></tr>
<tr class="separator:a8234c2c7917f750db94bb068d6fd554e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5485ae7bad862f6ff0ab363ed4697b61"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:a5485ae7bad862f6ff0ab363ed4697b61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5485ae7bad862f6ff0ab363ed4697b61">uninitialized_fill_n</a> (ForwardIterator first, const int size, const T &amp;value)</td></tr>
<tr class="memdesc:a5485ae7bad862f6ff0ab363ed4697b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the first number of elements in an uninitialized range with a value.  <a href="#a5485ae7bad862f6ff0ab363ed4697b61">More...</a><br /></td></tr>
<tr class="separator:a5485ae7bad862f6ff0ab363ed4697b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff56f151fea6e709350a0e9fbdb70a8"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </td></tr>
<tr class="memitem:a5ff56f151fea6e709350a0e9fbdb70a8"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5ff56f151fea6e709350a0e9fbdb70a8">uninitialized_copy</a> (ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 otherFirst)</td></tr>
<tr class="memdesc:a5ff56f151fea6e709350a0e9fbdb70a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range into an uninitialized range.  <a href="#a5ff56f151fea6e709350a0e9fbdb70a8">More...</a><br /></td></tr>
<tr class="separator:a5ff56f151fea6e709350a0e9fbdb70a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c7d8eb38174ba66d98321b68047e6e"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </td></tr>
<tr class="memitem:ad1c7d8eb38174ba66d98321b68047e6e"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad1c7d8eb38174ba66d98321b68047e6e">uninitialized_copy_n</a> (ForwardIterator1 first, const int size, ForwardIterator2 otherFirst)</td></tr>
<tr class="memdesc:ad1c7d8eb38174ba66d98321b68047e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a number of elements from a range into an uninitialized range.  <a href="#ad1c7d8eb38174ba66d98321b68047e6e">More...</a><br /></td></tr>
<tr class="separator:ad1c7d8eb38174ba66d98321b68047e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faf99d35e2cbb2b8c0644aa0b777e9b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1faf99d35e2cbb2b8c0644aa0b777e9b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1faf99d35e2cbb2b8c0644aa0b777e9b">operator==</a> (const <a class="el" href="classprism_1_1_allocator.html">Allocator</a>&lt; T &gt; &amp;a1, const <a class="el" href="classprism_1_1_allocator.html">Allocator</a>&lt; T &gt; &amp;a2)</td></tr>
<tr class="separator:a1faf99d35e2cbb2b8c0644aa0b777e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cc68e19002deb7797ff9eaa10523db"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t size&gt; </td></tr>
<tr class="memitem:a23cc68e19002deb7797ff9eaa10523db"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a23cc68e19002deb7797ff9eaa10523db">operator==</a> (const <a class="el" href="classprism_1_1_array.html">Array</a>&lt; T, size &gt; &amp;lhs, const <a class="el" href="classprism_1_1_array.html">Array</a>&lt; T, size &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a23cc68e19002deb7797ff9eaa10523db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two arrays for equality.  <a href="#a23cc68e19002deb7797ff9eaa10523db">More...</a><br /></td></tr>
<tr class="separator:a23cc68e19002deb7797ff9eaa10523db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae176101945a65ff8a61af85fcf832221"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t size&gt; </td></tr>
<tr class="memitem:ae176101945a65ff8a61af85fcf832221"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae176101945a65ff8a61af85fcf832221">operator!=</a> (const <a class="el" href="classprism_1_1_array.html">Array</a>&lt; T, size &gt; &amp;lhs, const <a class="el" href="classprism_1_1_array.html">Array</a>&lt; T, size &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae176101945a65ff8a61af85fcf832221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two arrays for inequality.  <a href="#ae176101945a65ff8a61af85fcf832221">More...</a><br /></td></tr>
<tr class="separator:ae176101945a65ff8a61af85fcf832221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff86329b54a13cb753f2c79156f68bb4"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Size&gt; </td></tr>
<tr class="memitem:aff86329b54a13cb753f2c79156f68bb4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aff86329b54a13cb753f2c79156f68bb4">swap</a> (<a class="el" href="classprism_1_1_array.html">Array</a>&lt; T, <a class="el" href="classprism_1_1_size.html">Size</a> &gt; &amp;a, <a class="el" href="classprism_1_1_array.html">Array</a>&lt; T, <a class="el" href="classprism_1_1_size.html">Size</a> &gt; &amp;b)</td></tr>
<tr class="memdesc:aff86329b54a13cb753f2c79156f68bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two arrays.  <a href="#aff86329b54a13cb753f2c79156f68bb4">More...</a><br /></td></tr>
<tr class="separator:aff86329b54a13cb753f2c79156f68bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec96a679831176af1c6f2b7480226e1"><td class="memTemplParams" colspan="2">template&lt;class NodePointer &gt; </td></tr>
<tr class="memitem:a3ec96a679831176af1c6f2b7480226e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a3ec96a679831176af1c6f2b7480226e1">printTree</a> (NodePointer p, int indent=0)</td></tr>
<tr class="separator:a3ec96a679831176af1c6f2b7480226e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667eee76b54258f4f3530eaa7ef44d69"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a667eee76b54258f4f3530eaa7ef44d69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a667eee76b54258f4f3530eaa7ef44d69">advance</a> (InputIterator &amp;iterator, const int numSteps)</td></tr>
<tr class="separator:a667eee76b54258f4f3530eaa7ef44d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7a987672303bcc2aad6eedfa3c97c5"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a6d7a987672303bcc2aad6eedfa3c97c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a6d7a987672303bcc2aad6eedfa3c97c5">begin</a> (Container &amp;con) -&gt; decltype(con.begin())</td></tr>
<tr class="separator:a6d7a987672303bcc2aad6eedfa3c97c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d797e0ebd535413f23ff6c378bce541"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a1d797e0ebd535413f23ff6c378bce541"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1d797e0ebd535413f23ff6c378bce541">begin</a> (const Container &amp;con) -&gt; decltype(con.begin())</td></tr>
<tr class="separator:a1d797e0ebd535413f23ff6c378bce541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa3ae5087a69ca4b87cd0142dd7f4f4"><td class="memTemplParams" colspan="2">template&lt;class T , int Size&gt; </td></tr>
<tr class="memitem:a1fa3ae5087a69ca4b87cd0142dd7f4f4"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1fa3ae5087a69ca4b87cd0142dd7f4f4">begin</a> (T(&amp;array)[<a class="el" href="classprism_1_1_size.html">Size</a>])</td></tr>
<tr class="separator:a1fa3ae5087a69ca4b87cd0142dd7f4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a8b01383d77bc9bcd878901af6f8bb"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:ad9a8b01383d77bc9bcd878901af6f8bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structprism_1_1iterator__traits.html">prism::iterator_traits</a>&lt; InputIterator &gt;::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad9a8b01383d77bc9bcd878901af6f8bb">distance</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="separator:ad9a8b01383d77bc9bcd878901af6f8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1f6ce5ed6fe400694b77f49270ea36"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:acd1f6ce5ed6fe400694b77f49270ea36"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#acd1f6ce5ed6fe400694b77f49270ea36">end</a> (Container &amp;con) -&gt; decltype(con.end())</td></tr>
<tr class="separator:acd1f6ce5ed6fe400694b77f49270ea36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b99f9ade4f7bd30ab1c5a64a20d539"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a81b99f9ade4f7bd30ab1c5a64a20d539"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a81b99f9ade4f7bd30ab1c5a64a20d539">end</a> (const Container &amp;con) -&gt; decltype(con.end())</td></tr>
<tr class="separator:a81b99f9ade4f7bd30ab1c5a64a20d539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7ee229aa856b527057b2abdf6cf144"><td class="memTemplParams" colspan="2">template&lt;class T , int Size&gt; </td></tr>
<tr class="memitem:a9b7ee229aa856b527057b2abdf6cf144"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9b7ee229aa856b527057b2abdf6cf144">end</a> (T(&amp;array)[<a class="el" href="classprism_1_1_size.html">Size</a>])</td></tr>
<tr class="separator:a9b7ee229aa856b527057b2abdf6cf144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56900cb33be6d15ac27a7c61bad2ce6"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Container &gt; </td></tr>
<tr class="memitem:ad56900cb33be6d15ac27a7c61bad2ce6"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad56900cb33be6d15ac27a7c61bad2ce6">has_next</a> (InputIterator &amp;it, Container &amp;con)</td></tr>
<tr class="separator:ad56900cb33be6d15ac27a7c61bad2ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20b814018d65b46e6d08eb450c176c9"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Container &gt; </td></tr>
<tr class="memitem:af20b814018d65b46e6d08eb450c176c9"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af20b814018d65b46e6d08eb450c176c9">has_previous</a> (InputIterator &amp;it, Container &amp;con)</td></tr>
<tr class="separator:af20b814018d65b46e6d08eb450c176c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16771cef03b7354150e188f4ce10f6b1"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a16771cef03b7354150e188f4ce10f6b1"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a16771cef03b7354150e188f4ce10f6b1">next</a> (ForwardIterator it, int numSteps=1)</td></tr>
<tr class="separator:a16771cef03b7354150e188f4ce10f6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8370841f58d9898247afa42c49a7658d"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator &gt; </td></tr>
<tr class="memitem:a8370841f58d9898247afa42c49a7658d"><td class="memTemplItemLeft" align="right" valign="top">BidirectionalIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8370841f58d9898247afa42c49a7658d">previous</a> (BidirectionalIterator it, int numSteps=1)</td></tr>
<tr class="separator:a8370841f58d9898247afa42c49a7658d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aab2862319b55b02ddcb6b9659b3699"><td class="memTemplParams" colspan="2">template&lt;class NodePointer &gt; </td></tr>
<tr class="memitem:a8aab2862319b55b02ddcb6b9659b3699"><td class="memTemplItemLeft" align="right" valign="top">NodePointer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8aab2862319b55b02ddcb6b9659b3699">minimumNodeInSubTree</a> (NodePointer node)</td></tr>
<tr class="separator:a8aab2862319b55b02ddcb6b9659b3699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db5694fde99b39da76f51463f300c4a"><td class="memTemplParams" colspan="2">template&lt;class NodePointer &gt; </td></tr>
<tr class="memitem:a6db5694fde99b39da76f51463f300c4a"><td class="memTemplItemLeft" align="right" valign="top">NodePointer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a6db5694fde99b39da76f51463f300c4a">maximumNodeInSubTree</a> (NodePointer node)</td></tr>
<tr class="separator:a6db5694fde99b39da76f51463f300c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f163cf0ef281768da60b400045aa8d8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7f163cf0ef281768da60b400045aa8d8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7f163cf0ef281768da60b400045aa8d8">operator==</a> (const <a class="el" href="classprism_1_1_log_allocator.html">LogAllocator</a>&lt; T &gt; &amp;a1, const <a class="el" href="classprism_1_1_log_allocator.html">LogAllocator</a>&lt; T &gt; &amp;a2)</td></tr>
<tr class="separator:a7f163cf0ef281768da60b400045aa8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df924e4deb059bf1200701c8235410a"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a9df924e4deb059bf1200701c8235410a"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9df924e4deb059bf1200701c8235410a">operator!=</a> (const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p1, const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p2)</td></tr>
<tr class="separator:a9df924e4deb059bf1200701c8235410a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6391c124e006b0e3a3ec67f55e208b0"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ad6391c124e006b0e3a3ec67f55e208b0"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad6391c124e006b0e3a3ec67f55e208b0">operator!=</a> (const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p1, const U *p2)</td></tr>
<tr class="separator:ad6391c124e006b0e3a3ec67f55e208b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8792dbd5cac5678390843bacdb69daa"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ab8792dbd5cac5678390843bacdb69daa"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab8792dbd5cac5678390843bacdb69daa">operator!=</a> (const U *p1, const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p2)</td></tr>
<tr class="separator:ab8792dbd5cac5678390843bacdb69daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53d52e8a36ec7ca58ea1731cc18f1d8"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ae53d52e8a36ec7ca58ea1731cc18f1d8"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae53d52e8a36ec7ca58ea1731cc18f1d8">operator==</a> (const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p1, const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p2)</td></tr>
<tr class="separator:ae53d52e8a36ec7ca58ea1731cc18f1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b73e87f080646696ed6b595a3900119"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a2b73e87f080646696ed6b595a3900119"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2b73e87f080646696ed6b595a3900119">operator==</a> (const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p1, const U *p2)</td></tr>
<tr class="separator:a2b73e87f080646696ed6b595a3900119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f29b22985dc0ec1fc548a551ce313ed"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a1f29b22985dc0ec1fc548a551ce313ed"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1f29b22985dc0ec1fc548a551ce313ed">operator==</a> (const U *p1, const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p2)</td></tr>
<tr class="separator:a1f29b22985dc0ec1fc548a551ce313ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Completely and shamefully lifted from Qt's QFlag/QFlags classes and macros and just renamed without the prepended 'Q'. These classes allow enums to be treated as datatypes when passed to methods. They are also type-safe so that the receiving method is expecting the enum and not the basic int equivalent. So printFlag(Label::AlignLeft) works whilst printFlag(2) doesn't.</p>
<p>For example,</p>
<p>class Label { private: enum Alignment { AlignLeft = 0x1, AlignRight = 0x2 } <a class="el" href="_flags_8h.html#aa5aa2c9827ab949836e20999b9a068ec">PRISM_DECLARE_FLAGS(AlignFlags, Alignment)</a> }</p>
<p>// outside class def <a class="el" href="_flags_8h.html#ae8aabb683a18b872a4449769b82e8e15">PRISM_DECLARE_OPERATORS_FOR_FLAGS(Label::AlignFlags)</a></p>
<p>void printFlag(Label::AlignFlags f) { if (f == Label::AlignLeft) std::cout &lt;&lt; "AlignLeft" &lt;&lt; std::endl; else if (f == Label::AlignRight) std::cout &lt;&lt; "AlignRight" &lt;&lt; std::endl; else std::cout &lt;&lt; f &lt;&lt; std::endl; }</p>
<p>int main(int argc, char** argv) { printFlag(Label::AlignLeft); }</p>
<p>todo</p>
<p>functions to add: &ndash; move constructor and move assignment operator &ndash; TAllocator allocator(); &ndash; <a class="el" href="namespaceprism.html#addfe9ea0146b59b2b16adee4cd2220b9" title="Sorts the elements in a range in ascending order. ">prism::sort()</a> needs a specialization for <a class="el" href="classprism_1_1_list.html" title="A node-based container. ">List</a></p>
<p>This simple class extends the <a class="el" href="classprism_1_1_allocator.html">Allocator</a> class by logging each memory allocation and deallocation by storing the newly allocated pointer in a <a class="el" href="classprism_1_1_vector.html">Vector</a> on allocation and removes it when the pointer is deallocated. In theory, at the end of the LoggerAllocator's lifetime the <a class="el" href="classprism_1_1_vector.html">Vector</a> should be empty as all pointers should be deallocated. If there are still pointers in the vector then an error message is printed to the console.</p>
<p>A <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> is made up of four components (w, x, y and z) which are a scalar (w) and a 3d vector (x, y and z). It does not suffer from gimbal lock and yet can represent any orientation possible.</p>
<p>Some interesting properties of quaternion multiplication: a) it is associative but not commutitive - (ab)c = a(bc) ab != ba</p>
<p>b) the magnitude of a quaternion product equals the product of the individual magnitudes. This is an important concept because when quaternions are of unit length and are multiplied, this guarentees us that the result will itself be a unit quaternion - ||ab|| = ||a||||b||</p>
<p>c) the inverse of a quaternion product is equal to the product of the individual quaternion inverses in reverse order - (ab).inverse = (b.inverse) * (a.inverse)</p>
<p>Rotating vectors: When rotating with a quaternion it is important that the quaternion be normalised i.e. be of unit length. This is because otherwise scaling will occur and since we only require rotations from our quaternions this won't do. Rotating a vector using quaternions is done with the following equation: v' = q * v * q.inverse where vector v is represented as a quaternion.</p>
<p>Concatenating rotational transforms together: Multiple quaternion rotations can be applied to a vector in one single action by concatenating the rotational quaternions together and then applying them to the vector using the above equation. For example, to rotate the vector v by quaternion a and then rotating that result by quaternion b would be as follows: v' = b * (a * v * a.inverse) * b.inverse = (b * a) * v * (b.inverse * a.inverse) = (b * a) * v * (b * a).inverse So, rotating by a and then by b is equivalent to the single rotation of the product of ba. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ab11baa40bd94b92172c01957db05a76f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structprism_1_1_integral_constant.html">IntegralConstant</a>&lt;bool,false&gt; <a class="el" href="namespaceprism.html#ab11baa40bd94b92172c01957db05a76f">prism::FalseType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7d28160dd23799e4294e2d705294f16f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structprism_1_1_integral_constant.html">IntegralConstant</a>&lt;bool,true&gt; <a class="el" href="namespaceprism.html#a7d28160dd23799e4294e2d705294f16f">prism::TrueType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a82052418345794a13044c15d8e32dd89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator prism::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds two consecutive matching elements in a range. </p>
<p>Searches the range <em></em>[first,last] for the first occurrence of two consecutive elements that match.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>The iterator pointing to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>The iterator pointing to the end of the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator to the first of these two elements, or <em>last</em> if no such pair is found.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a667eee76b54258f4f3530eaa7ef44d69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::advance </td>
          <td>(</td>
          <td class="paramtype">InputIterator &amp;&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numSteps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the iterator forwards by numSteps (or backwards if numSteps is negative). </p>

</div>
</div>
<a class="anchor" id="ad2de9cb16507b1e1b73597c308cafa6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::all_of </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if all the elements match a condition in a range. </p>
<p>Each element in the range <em></em>[first,last] is matched against the condition in <em>pred</em>.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator pointing to the first element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator pointing to the position after the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>A unary function that returns true or false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the predicate returns true for all of the elements in the range or false otherwise.</dd></dl>
<p>Example usage </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> isEven(<span class="keyword">const</span> <span class="keywordtype">int</span> n) { <span class="keywordflow">return</span> n % 2 == 0; }</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> a[5] = {2,4,6,8,10};</div><div class="line"><span class="keywordtype">bool</span> allEven = <a class="code" href="namespaceprism.html#ad2de9cb16507b1e1b73597c308cafa6c">prism::all_of</a>(a, a+5, isEven);</div><div class="line">cout &lt;&lt; allEven;</div><div class="line"></div><div class="line">output: 1</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceprism.html#ab06451218f60335b732769b55b683321" title="Checks if any elements match a condition in a range. ">any_of()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ab06451218f60335b732769b55b683321"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::any_of </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if any elements match a condition in a range. </p>
<p>Each element in the range <em></em>[first,last] is checked against the condition in <em><b>pred</b></em> until one of them matches.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator pointing to the first element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator pointing to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>A unary function that returns true or false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if any of the elements match the condition in <em>pred</em> or false otherwise</dd></dl>
<p>Example usage </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> isEven(<span class="keyword">const</span> <span class="keywordtype">int</span> n) { <span class="keywordflow">return</span> n % 2 == 0; }</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> a[5] = {1,3,5,8,9};</div><div class="line"><span class="keywordtype">bool</span> anyEven = <a class="code" href="namespaceprism.html#ab06451218f60335b732769b55b683321">prism::any_of</a>(a, a+5, isEven);</div><div class="line">cout &lt;&lt; anyEven;</div><div class="line"></div><div class="line">output: 1</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceprism.html#ad2de9cb16507b1e1b73597c308cafa6c" title="Checks if all the elements match a condition in a range. ">all_of()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a6d7a987672303bcc2aad6eedfa3c97c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto prism::begin </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>con</em></td><td>)</td>
          <td> -&gt;  decltype(con.begin())</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the beginning of <em>con</em>. </p>

</div>
</div>
<a class="anchor" id="a1d797e0ebd535413f23ff6c378bce541"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto prism::begin </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>con</em></td><td>)</td>
          <td> -&gt;  decltype(con.begin())</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a const iterator pointing to the beginning of <em>con</em>. </p>

</div>
</div>
<a class="anchor" id="a1fa3ae5087a69ca4b87cd0142dd7f4f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* prism::begin </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[Size]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classprism_1_1_array.html" title="A fixed size sequence based container. ">Array</a> specialization. </p>

</div>
</div>
<a class="anchor" id="ae776f4cd825f79e7af1cf6ee1d90a209"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements from one range to another range. </p>
<p>Copies the elements in the range <em></em>[first,last] and places them at the range beginning from <em>otherFirst</em> </p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator pointing to the first element in the range to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator pointing to the position after the last element in the range to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherFirst</td><td>An iterator pointing to the start of the range where the copies will be placed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the end of the destination range</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> a[5] = {1,2,3,4,5};</div><div class="line"><span class="keywordtype">int</span> b[5];</div><div class="line"></div><div class="line"><a class="code" href="namespaceprism.html#ae776f4cd825f79e7af1cf6ee1d90a209">prism::copy</a>(a, a+5, b);</div><div class="line"><span class="comment">// b == [1,2,3,4,5]</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceprism.html#a2564c63b76369cc81ff725a56e818046" title="Copies a range to another range backwards. ">copy_backward()</a>, <a class="el" href="namespaceprism.html#adcd8d05b64877fd3c6d1af2cfe3d3e81" title="Copies elements from a range to another range only if they meet a condition. ">copy_if()</a>, <a class="el" href="namespaceprism.html#af907f3f5637d4ec056e9b833b6272953" title="Copies a specified number of elements from one range to another range. ">copy_n()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a2564c63b76369cc81ff725a56e818046"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator1 , class BidirectionalIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BidirectionalIterator2 prism::copy_backward </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator2&#160;</td>
          <td class="paramname"><em>otherLast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a range to another range backwards. </p>
<p>Copies the elements in the range <em></em>[first,last] starting from <em>last</em> to the range ending at <em>otherLast</em>. The elements copied are between <em>first</em> and <em>last</em>, including <em>first</em> but not <em>last</em>. <em>otherLast</em> should point to the past-the-end position of the destination range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position after the last element to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherLast</td><td>An iterator that points to the position after where the copied range should finish</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the first element of the copied range in the destination range</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="adcd8d05b64877fd3c6d1af2cfe3d3e81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies elements from a range to another range only if they meet a condition. </p>
<p>Each element from the range <em></em>[first,last] is matched against the condition in <em>pred</em> which if true the element is copied across to the range beginning at <em>otherFirst</em>.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the first element in the range to be copied from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position after the last element in the range to be copied from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherFirst</td><td>An iterator that points to the start of the destination range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>A unary function that returns true or false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that is one position past the last inserted element in the destination range</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="af907f3f5637d4ec056e9b833b6272953"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Size , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::copy_n </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classprism_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a specified number of elements from one range to another range. </p>
<p>Copies <em>n</em> amount of elements from the range beginning at <em>first</em> to the range beginning at <em>otherFirst</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the first element in the range to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherFirst</td><td>An iterator that points to the start of the destination range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that is one position past the last inserted element in the destination range</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a024117fc3639cdf6598509edf22f034a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int prism::count </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of occurrences of a value in a range. </p>
<p>Searches the range <em></em>[first,last] and counts the number of occurrences of elements matching <em>value</em>.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range to be searched </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position after the last element to be searched </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value that each element will be compared to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of times that <em>value</em> appears in the range</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a124ac016ee2a8ab3844c9af6daf5b4a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int prism::count_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of occurrences of a value that meets a condition in a range. </p>
<p>Iterates through the range <em></em>[first,last] and compares each element to the predicate <em>pred</em>. If <em>pred</em> returns true for that element then it will be counted.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range to be counted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position after the last element of the range to be counted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>A unary function that returns true or false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements that match the condition in <em>pred</em> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad9a8b01383d77bc9bcd878901af6f8bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprism_1_1iterator__traits.html">prism::iterator_traits</a>&lt;InputIterator&gt;::difference_type prism::distance </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the distance between two iterators. </p>

</div>
</div>
<a class="anchor" id="acd1f6ce5ed6fe400694b77f49270ea36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto prism::end </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>con</em></td><td>)</td>
          <td> -&gt;  decltype(con.end())</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the end of <em>con</em>. </p>

</div>
</div>
<a class="anchor" id="a81b99f9ade4f7bd30ab1c5a64a20d539"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto prism::end </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>con</em></td><td>)</td>
          <td> -&gt;  decltype(con.end())</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a const iterator pointing to the end of <em>con</em>. </p>

</div>
</div>
<a class="anchor" id="a9b7ee229aa856b527057b2abdf6cf144"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* prism::end </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[Size]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classprism_1_1_array.html" title="A fixed size sequence based container. ">Array</a> specialization. </p>

</div>
</div>
<a class="anchor" id="ad3bede9a0f2c648e93677b14c45b1b7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator1 , class InputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::equal </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ranges for equality. </p>
<p>Compares all the elements in the range [first,last] against the elements in the range beginning from <em>otherFirst</em>. Comparison is made using <a class="el" href="namespaceprism.html#a1faf99d35e2cbb2b8c0644aa0b777e9b">operator==()</a> so the element must support that operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the first range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position after the last element of the first range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherFirst</td><td>An iterator that points to the start of the second range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If each element from the first range matches the corresponding element in the second range then <em>true</em> is returned and <em>false</em> otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a7c33653a5b4a07b31f5bde15e9085b45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::fill </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a range with a value. </p>
<p>Assigns <em>value</em> to each element in the range [first,last].</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to one position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be assigned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aceb4b9c511a5edb706296b457427b226"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::fill_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a value to a specified number of elements in a range. </p>
<p>Assigns <em>value</em> to the first  elements starting from <em>first</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of assignments to take place </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be assigned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1b543d9c2862a539cc8b770abda87561"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InputIterator prism::find </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a value in a range. </p>
<p>Searches the range [first,last] for the first value equal to <em>value</em>. Comparison is made using <a class="el" href="namespaceprism.html#a1faf99d35e2cbb2b8c0644aa0b777e9b">operator==()</a> so the element must support that operator.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position after the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the found value or <em>last</em> if no element is found.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a411641547f43e750a186c89bf0dd5a59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InputIterator prism::find_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first value in a range for which a predicate returns true. </p>
<p>Searches the range [first,last] to find the first element for which <em>pred</em> returns true.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the first element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position after the last element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>A unary function that returns true or false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the first found element for which <em>pred</em> return true or <em>last</em> if no element is found</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a3189014b9fa31e0ef0d1933c6f616618"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InputIterator prism::find_last </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last value in a range that matches a specified value. </p>
<p>Searches the range [first,last] for the last occurrence of <em>value</em> </p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the found element or <em>last</em> if no element is found</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a9f65de889707907c02a325d8a4ff4aec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">UnaryFunction prism::for_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls a function for each element in a range. </p>
<p>For all elements in a range [first,last] a function <em>func</em> is called where each element is passed into the function as an argument.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to be called for each element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function <em>func</em> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad56900cb33be6d15ac27a7c61bad2ce6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::has_next </td>
          <td>(</td>
          <td class="paramtype">InputIterator &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>con</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af20b814018d65b46e6d08eb450c176c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::has_previous </td>
          <td>(</td>
          <td class="paramtype">InputIterator &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>con</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acf5efbeb096446c47690b9e8bd2cc01a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::is_sorted </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a range is sorted in ascending order. </p>
<p>Checks the elements in a range [first,last] to see if they are arranged in ascending order. The element type must support operator&lt;().</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>A unary function that takes an argument from the range [frst,last]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the range is sorted in ascending order or false otherwise</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="af8e36230e6cb92a41aaca282772a9e6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::make_heap </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rearranges a range into a heap order. </p>
<p>todo WRITE A BETTER EXPLANATION OF WHAT A HEAP IS Transforms a range [first,last] in such a way that it forms a heap. This makes retrieving the element with the highest value very fast.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a812456273adfa37979e79f07e731d412"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; prism::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines which value is greater. </p>
<p>Compares the values <em>a</em> and <em>b</em> to find out which one has the greater value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>a</em> or <em>b</em>, whichever is the greater value</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a6db5694fde99b39da76f51463f300c4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodePointer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NodePointer prism::maximumNodeInSubTree </td>
          <td>(</td>
          <td class="paramtype">NodePointer&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a10aff0aca673fb1837069dd8967e4738"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; prism::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines which value is lesser. </p>
<p>Compares the values <em>a</em> and <em>b</em> to find out which one has the lesser value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>a</em> or <em>b</em>, whichever is the lesser value</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a8aab2862319b55b02ddcb6b9659b3699"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodePointer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NodePointer prism::minimumNodeInSubTree </td>
          <td>(</td>
          <td class="paramtype">NodePointer&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a16771cef03b7354150e188f4ce10f6b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator prism::next </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSteps</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advances the iterator <em>it</em> by <em>numSteps</em> (1 by default). Returns an iterator. </p>

</div>
</div>
<a class="anchor" id="a3c43dafd5926d3dc6ce698ae8938810d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::none_of </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks elements in a range to see if they don't match a condition. </p>
<p>Each element in the range [first,last] is checked to make sure it doesn't match the condition in <em>pred</em>.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>A unary predicate that returns true or false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>pred</em> returns false for all elements or if the range is empty, false otherwise</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a9df924e4deb059bf1200701c8235410a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the managed pointers of p1 and p2 do not point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="ad6391c124e006b0e3a3ec67f55e208b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the managed pointer of p1 and the raw pointer p2 do not point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="ab8792dbd5cac5678390843bacdb69daa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the raw pointer p1 and the managed pointer of p2 do not point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="ae176101945a65ff8a61af85fcf832221"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_array.html">Array</a>&lt; T, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_array.html">Array</a>&lt; T, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two arrays for inequality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first array </td></tr>
    <tr><td class="paramname">rhs</td><td>The second array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the arrays are not equal or false otherwise. Two arrays are equivalent if they have the same size and the same elements in the same order</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1faf99d35e2cbb2b8c0644aa0b777e9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_allocator.html">Allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_allocator.html">Allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae53d52e8a36ec7ca58ea1731cc18f1d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the managed pointers of p1 and p2 point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a7f163cf0ef281768da60b400045aa8d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_log_allocator.html">LogAllocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_log_allocator.html">LogAllocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2b73e87f080646696ed6b595a3900119"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the managed pointer of p1 and the raw pointer p2 point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a1f29b22985dc0ec1fc548a551ce313ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the raw pointer p1 and the managed pointer of p2 point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a23cc68e19002deb7797ff9eaa10523db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_array.html">Array</a>&lt; T, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_array.html">Array</a>&lt; T, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two arrays for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first array </td></tr>
    <tr><td class="paramname">rhs</td><td>The second array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the arrays are equal or false otherwise. Two arrays are equivalent if they have the same size and the same elements in the same order</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a8370841f58d9898247afa42c49a7658d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BidirectionalIterator prism::previous </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSteps</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the iterator <em>it</em> back by <em>numSteps</em>. Returns an iterator. </p>

</div>
</div>
<a class="anchor" id="a3ec96a679831176af1c6f2b7480226e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodePointer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::printTree </td>
          <td>(</td>
          <td class="paramtype">NodePointer&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeddd21943bcf811c56f7d9d1bd4784f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator prism::remove </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements that equal a value in a range. </p>
<p>Transforms a range [first,last] into a range where all elements that equal <em>value</em> are removed. The element type must support <a class="el" href="namespaceprism.html#a1faf99d35e2cbb2b8c0644aa0b777e9b">operator==()</a>.</p>
<p>The order of the elements not removed are preserved but note that any element between the returned iterator and <em>last</em> are still valid but in an unspecified state.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the position after the new end of the range</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ab7b6fb407340e51749169560b48fb20c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::remove_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies elements from a range that don't match a value into another range. </p>
<p>Iterates through a range [first,last] and copies each element that doesn't match <em>value</em> into the range beginning at <em>otherFirst</em>. The element type must support <a class="el" href="namespaceprism.html#a1faf99d35e2cbb2b8c0644aa0b777e9b">operator==()</a>.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherFirst</td><td>An iterator that points to the start of the destination range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value for each element to be compared to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the position after the last element copied into the destination range</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="abfc7da1f951e480a26d58fc098b78844"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::remove_copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies elements from a range for which a predicate returns false into another range. </p>
<p>Iterates through a range [first,last] and copies all elements (except those for which <em>pred</em> returns true) into the range beginning at <em>otherFirst</em>. The element type must support <a class="el" href="namespaceprism.html#a1faf99d35e2cbb2b8c0644aa0b777e9b">operator==()</a>.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherFirst</td><td>An iterator that points to the start of the destination range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>A unary function that returns true or false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the position after the last element copied into the destination range</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a252483ee5c3c08a0b99b67510371583d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator prism::remove_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from a range for which a predicate returns true. </p>
<p>Transforms the range [first,last] into a range where each element for which <em>pred</em> returns true is removed.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>A unary function that returns true or false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the position after the new end of the range</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a6156070b98de7130b8c912ae3a6d333f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::replace </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>oldValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all occurrences of a value with a new value in a range. </p>
<p>Iterates through the range [first,last] and replaces each occurrence of <em>oldValue</em> with <em>newValue</em>. The element type must support <a class="el" href="namespaceprism.html#a1faf99d35e2cbb2b8c0644aa0b777e9b">operator==()</a>.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oldValue</td><td>The value to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newValue</td><td>The new value that replaces the old value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a16d85ecb70d2f216714a0146a057a105"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::replace_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>oldValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements from one range to another range replacing one value with another value. </p>
<p>Iterates through the range [first,last] and copies each element into the range beginning at <em>otherFirst</em> whilst replacing all occurrences of <em>oldValue</em> with <em>newValue</em> in the destination range. The element type must support <a class="el" href="namespaceprism.html#a1faf99d35e2cbb2b8c0644aa0b777e9b">operator==()</a>.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherFirst</td><td>An iterator that points to the start of the destination range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oldValue</td><td>The value to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newValue</td><td>The new value that replaces the old value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the position after the last element copied into the destination range</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ac48a460cd28a7965f460dfb98e68fa39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class UnaryPredicate , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::replace_copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements from one range to another range replacing each element that a predicate returns true for with a new value. </p>
<p>Iterates through the range {first,last] and copies each element into the destination range beginning at <em>otherFirst</em> replacing any value with <em>newValue</em> for which <em>pred</em> returns true.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherFirst</td><td>An iterator that points to the start of the destination range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>A unary function that returns true or false </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newValue</td><td>The new value that replaces the old value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the position after the last element copied into the destination range</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a7742cad186e8ce8764ee48ff1fbfd4cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class UnaryPredicate , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::replace_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a new value to all elements for which a predicate returns true. </p>
<p>Iterates through the range [first,last] and replaces any element for which the predicate <em>pred</em> returns true with <em>newValue</em>. The element type must support <a class="el" href="namespaceprism.html#a1faf99d35e2cbb2b8c0644aa0b777e9b">operator==()</a>.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>A unary function that returns true or false </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newValue</td><td>The new value that replaces the old value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a03dbb806369b062fd90909fd826c2ee4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator1 prism::search </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>otherLast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches a range for a sub-range. </p>
<p>Iterates through the range [first,last] searching for the sub-range defined by the range [otherFirst,otherLast]. The element type must support <a class="el" href="namespaceprism.html#a1faf99d35e2cbb2b8c0644aa0b777e9b">operator==()</a>.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>. Likewise for the range [otherFirst,otherLast].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherFirst</td><td>An iterator that points to the start of the other range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherLast</td><td>An iterator that points to the position past the last element in the other range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the first element of the matching sub-range in the source range or <em>last</em> if no sub-range is found</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="addfe9ea0146b59b2b16adee4cd2220b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the elements in a range in ascending order. </p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aa2955433bd872919cf59580c1a464c93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort_bubble </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the elements in a range in ascending order. </p>
<p>Sorts the elements in the range [first,last] in ascending order using the bubble sort algorithm. The element type must support operator&gt;().</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1e9fe74c5dcee70bf5dd5c89f1234a02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort_heap </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the elements in a range in ascending order. </p>
<p>Sorts the elements in the range [first,last] in ascending order using the heap sort algorithm. The element type must support operator&lt;().</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad8cbe49b782032932d0da83860e7b368"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort_quicksort </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the elements in a range in ascending order. </p>
<p>Sorts the elements in the range [first,last] in ascending order using the quick sort algorithm. The element type must support operator&lt;=().</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aff86329b54a13cb753f2c79156f68bb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classprism_1_1_array.html">Array</a>&lt; T, <a class="el" href="classprism_1_1_size.html">Size</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classprism_1_1_array.html">Array</a>&lt; T, <a class="el" href="classprism_1_1_size.html">Size</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of two arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first array </td></tr>
    <tr><td class="paramname">b</td><td>The second array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a6430516ab4f2e2a7f43323acb6b559d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the values of two variables. </p>
<p>After running this function <em>a</em> will equal <em>b's</em> old value and <em>b</em> will equal <em>a's</em> old value. The element type must support operator=()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a4661f2c0c4dca098c137179b4d93f3dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator2 prism::swap_ranges </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the elements in two ranges. </p>
<p>All of the elements in the range [first,last] are swapped with the elements in the range beginning from <em>otherFirst</em>. The element type must support operator=().</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherFirst</td><td>An iterator that points to the start of the other range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the position after the last element swapped into the destination range</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a5ff56f151fea6e709350a0e9fbdb70a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator2 prism::uninitialized_copy </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a range into an uninitialized range. </p>
<p>The range [first,last] represents a block of memory that has been allocated but not initialized i.e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the <a class="el" href="namespaceprism.html#ae776f4cd825f79e7af1cf6ee1d90a209" title="Copies the elements from one range to another range. ">prism::copy</a> algorithm). This algorithm takes that memory block and initializes each element by copy-constructing each element in place. This algorithm differs from <a class="el" href="namespaceprism.html#ae776f4cd825f79e7af1cf6ee1d90a209" title="Copies the elements from one range to another range. ">prism::copy</a> because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn't. It copy-constructs in place instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherFirst</td><td>An iterator that points to the start of an uninitialized range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the position after the last element copied to the destination range</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad1c7d8eb38174ba66d98321b68047e6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator2 prism::uninitialized_copy_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a number of elements from a range into an uninitialized range. </p>
<p>The range beginning at <em>first</em> represents a block of memory that has been allocated but not initialized i.e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the <a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45" title="Fills a range with a value. ">prism::fill</a> algorithm). This algorithm takes that memory block and initializes each element by copy-constructing each element in place. This algorithm differs from <a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45" title="Fills a range with a value. ">prism::fill</a> because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn't. It copy-constructs in place instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements to copy-initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherFirst</td><td>An iterator that points to the start of an uninitialized range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the position after the last element copied to the destination range</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a8234c2c7917f750db94bb068d6fd554e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::uninitialized_fill </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills an uninitialized range with a value. </p>
<p>The range [first,last] represents a block of memory that has been allocated but not initialized i.e. no elements have been constructed. This algorithm takes that memory block and initializes each element by copy-constructing each element in place.</p>
<p>The range is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed to by <em>first</em> but not the element pointed to by <em>last</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>An iterator that points to the position past the last element in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be assigned to the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a5485ae7bad862f6ff0ab363ed4697b61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::uninitialized_fill_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the first number of elements in an uninitialized range with a value. </p>
<p>The range starting at <em>first</em> represents a block of memory that has been allocated but not initialized i.e. no elements have been constructed. This algorithm takes that memory block and initializes each element by copy-constructing each element in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator that points to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements to fill-initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to fill-initialize with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
