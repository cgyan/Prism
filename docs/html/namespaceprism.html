<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Prism: prism Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Prism
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceprism.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">prism Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_allocator.html">Allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_allocator_traits.html">AllocatorTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_array.html">Array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_bitvector.html">Bitvector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_bitvector_data.html">BitvectorData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_char.html">Char</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_circle.html">Circle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1conditional__type.html">conditional_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1conditional__type_3_01false_00_01_type1_00_01_type2_01_4.html">conditional_type&lt; false, Type1, Type2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_exception.html">Exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_flag.html">Flag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_flags.html">Flags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_fraction.html">Fraction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_list.html">List</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_logger_allocator.html">LoggerAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_mathf.html">Mathf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_obj.html">Obj</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_out_of_bounds_exception.html">OutOfBoundsException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_overflow_exception.html">OverflowException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprism_1_1_pair.html">Pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_point.html">Point</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_pointf.html">Pointf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_queue.html">Queue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_rect.html">Rect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_reference_counter.html">ReferenceCounter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_shared_data.html">SharedData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_shared_data_pointer.html">SharedDataPointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_size.html">Size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_stack.html">Stack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_string.html">String</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_time.html">Time</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_unequal_size_exception.html">UnequalSizeException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_vector.html">Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_vector2.html">Vector2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_vector3.html">Vector3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprism_1_1_vector4.html">Vector4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a82052418345794a13044c15d8e32dd89"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a82052418345794a13044c15d8e32dd89"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a82052418345794a13044c15d8e32dd89">adjacent_find</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:a82052418345794a13044c15d8e32dd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba366b328f3b6161e6115c16b7153c6d"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:aba366b328f3b6161e6115c16b7153c6d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aba366b328f3b6161e6115c16b7153c6d">all_of</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Predicate pred)</td></tr>
<tr class="separator:aba366b328f3b6161e6115c16b7153c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0e3ddb9f698759635572f1220ec0ca"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:a5d0e3ddb9f698759635572f1220ec0ca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5d0e3ddb9f698759635572f1220ec0ca">any_of</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Predicate pred)</td></tr>
<tr class="separator:a5d0e3ddb9f698759635572f1220ec0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae776f4cd825f79e7af1cf6ee1d90a209"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ae776f4cd825f79e7af1cf6ee1d90a209"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae776f4cd825f79e7af1cf6ee1d90a209">copy</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, OutputIterator otherFirst)</td></tr>
<tr class="separator:ae776f4cd825f79e7af1cf6ee1d90a209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2564c63b76369cc81ff725a56e818046"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator1 , class BidirectionalIterator2 &gt; </td></tr>
<tr class="memitem:a2564c63b76369cc81ff725a56e818046"><td class="memTemplItemLeft" align="right" valign="top">BidirectionalIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2564c63b76369cc81ff725a56e818046">copy_backward</a> (BidirectionalIterator1 <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, BidirectionalIterator1 <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, BidirectionalIterator2 otherLast)</td></tr>
<tr class="separator:a2564c63b76369cc81ff725a56e818046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbed55ae6769c2d88c125aedc2f3846e"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:afbed55ae6769c2d88c125aedc2f3846e"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#afbed55ae6769c2d88c125aedc2f3846e">copy_if</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, OutputIterator otherFirst, Predicate pred)</td></tr>
<tr class="separator:afbed55ae6769c2d88c125aedc2f3846e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af907f3f5637d4ec056e9b833b6272953"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Size , class OutputIterator &gt; </td></tr>
<tr class="memitem:af907f3f5637d4ec056e9b833b6272953"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af907f3f5637d4ec056e9b833b6272953">copy_n</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, <a class="el" href="classprism_1_1_size.html">Size</a> n, OutputIterator otherFirst)</td></tr>
<tr class="separator:af907f3f5637d4ec056e9b833b6272953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024117fc3639cdf6598509edf22f034a"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class T &gt; </td></tr>
<tr class="memitem:a024117fc3639cdf6598509edf22f034a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a024117fc3639cdf6598509edf22f034a">count</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, const T &amp;value)</td></tr>
<tr class="separator:a024117fc3639cdf6598509edf22f034a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0007d361beae18a930b6249752e509e"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:af0007d361beae18a930b6249752e509e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af0007d361beae18a930b6249752e509e">count_if</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Predicate pred)</td></tr>
<tr class="separator:af0007d361beae18a930b6249752e509e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e62e5b148c55f949e5ea843d53ad67"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a83e62e5b148c55f949e5ea843d53ad67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a83e62e5b148c55f949e5ea843d53ad67">delete_range</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:a83e62e5b148c55f949e5ea843d53ad67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bede9a0f2c648e93677b14c45b1b7b"><td class="memTemplParams" colspan="2">template&lt;class InputIterator1 , class InputIterator2 &gt; </td></tr>
<tr class="memitem:ad3bede9a0f2c648e93677b14c45b1b7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad3bede9a0f2c648e93677b14c45b1b7b">equal</a> (InputIterator1 <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator1 <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, InputIterator2 otherFirst)</td></tr>
<tr class="separator:ad3bede9a0f2c648e93677b14c45b1b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c33653a5b4a07b31f5bde15e9085b45"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:a7c33653a5b4a07b31f5bde15e9085b45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45">fill</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, const T &amp;value)</td></tr>
<tr class="separator:a7c33653a5b4a07b31f5bde15e9085b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb4b9c511a5edb706296b457427b226"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:aceb4b9c511a5edb706296b457427b226"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aceb4b9c511a5edb706296b457427b226">fill_n</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, int <a class="el" href="namespaceprism.html#acd3c0f96adf158a29387191d79c4d874">size</a>, const T &amp;value)</td></tr>
<tr class="separator:aceb4b9c511a5edb706296b457427b226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b543d9c2862a539cc8b770abda87561"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class T &gt; </td></tr>
<tr class="memitem:a1b543d9c2862a539cc8b770abda87561"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1b543d9c2862a539cc8b770abda87561">find</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, const T &amp;value)</td></tr>
<tr class="separator:a1b543d9c2862a539cc8b770abda87561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17e9e6c80f8a52479a52450a108a636"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:aa17e9e6c80f8a52479a52450a108a636"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa17e9e6c80f8a52479a52450a108a636">find_if</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Predicate pred)</td></tr>
<tr class="separator:aa17e9e6c80f8a52479a52450a108a636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3189014b9fa31e0ef0d1933c6f616618"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class T &gt; </td></tr>
<tr class="memitem:a3189014b9fa31e0ef0d1933c6f616618"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a3189014b9fa31e0ef0d1933c6f616618">find_last</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, const T &amp;value)</td></tr>
<tr class="separator:a3189014b9fa31e0ef0d1933c6f616618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae062d5bfdc0e53ae49c56520aded906"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Function &gt; </td></tr>
<tr class="memitem:aae062d5bfdc0e53ae49c56520aded906"><td class="memTemplItemLeft" align="right" valign="top">Function&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aae062d5bfdc0e53ae49c56520aded906">for_each</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Function func)</td></tr>
<tr class="separator:aae062d5bfdc0e53ae49c56520aded906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5efbeb096446c47690b9e8bd2cc01a"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:acf5efbeb096446c47690b9e8bd2cc01a"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#acf5efbeb096446c47690b9e8bd2cc01a">is_sorted</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:acf5efbeb096446c47690b9e8bd2cc01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e36230e6cb92a41aaca282772a9e6e"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator &gt; </td></tr>
<tr class="memitem:af8e36230e6cb92a41aaca282772a9e6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af8e36230e6cb92a41aaca282772a9e6e">make_heap</a> (RandomAccessIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, RandomAccessIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:af8e36230e6cb92a41aaca282772a9e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812456273adfa37979e79f07e731d412"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a812456273adfa37979e79f07e731d412"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a812456273adfa37979e79f07e731d412">max</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a812456273adfa37979e79f07e731d412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aff0aca673fb1837069dd8967e4738"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a10aff0aca673fb1837069dd8967e4738"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a10aff0aca673fb1837069dd8967e4738">min</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a10aff0aca673fb1837069dd8967e4738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c83b433c7f98fd4513f1b68c6db594"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:a10c83b433c7f98fd4513f1b68c6db594"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a10c83b433c7f98fd4513f1b68c6db594">none_of</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Predicate pred)</td></tr>
<tr class="separator:a10c83b433c7f98fd4513f1b68c6db594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddd21943bcf811c56f7d9d1bd4784f6"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:aeddd21943bcf811c56f7d9d1bd4784f6"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aeddd21943bcf811c56f7d9d1bd4784f6">remove</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, const T &amp;value)</td></tr>
<tr class="separator:aeddd21943bcf811c56f7d9d1bd4784f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b6fb407340e51749169560b48fb20c"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class T &gt; </td></tr>
<tr class="memitem:ab7b6fb407340e51749169560b48fb20c"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab7b6fb407340e51749169560b48fb20c">remove_copy</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, OutputIterator otherFirst, const T &amp;value)</td></tr>
<tr class="separator:ab7b6fb407340e51749169560b48fb20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc7da1f951e480a26d58fc098b78844"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:abfc7da1f951e480a26d58fc098b78844"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#abfc7da1f951e480a26d58fc098b78844">remove_copy_if</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, OutputIterator otherFirst, UnaryPredicate pred)</td></tr>
<tr class="separator:abfc7da1f951e480a26d58fc098b78844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9d25191ed83ea0a193f16d9c0a00b7"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class Predicate &gt; </td></tr>
<tr class="memitem:a2e9d25191ed83ea0a193f16d9c0a00b7"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2e9d25191ed83ea0a193f16d9c0a00b7">remove_if</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Predicate pred)</td></tr>
<tr class="separator:a2e9d25191ed83ea0a193f16d9c0a00b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6156070b98de7130b8c912ae3a6d333f"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:a6156070b98de7130b8c912ae3a6d333f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a6156070b98de7130b8c912ae3a6d333f">replace</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, const T &amp;oldValue, const T &amp;newValue)</td></tr>
<tr class="separator:a6156070b98de7130b8c912ae3a6d333f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d85ecb70d2f216714a0146a057a105"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class T &gt; </td></tr>
<tr class="memitem:a16d85ecb70d2f216714a0146a057a105"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a16d85ecb70d2f216714a0146a057a105">replace_copy</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, OutputIterator otherFirst, const T &amp;oldValue, const T &amp;newValue)</td></tr>
<tr class="separator:a16d85ecb70d2f216714a0146a057a105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d702599739f7137516dcd095119f15"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class Predicate , class T &gt; </td></tr>
<tr class="memitem:a55d702599739f7137516dcd095119f15"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a55d702599739f7137516dcd095119f15">replace_copy_if</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, OutputIterator otherFirst, Predicate pred, const T &amp;newValue)</td></tr>
<tr class="separator:a55d702599739f7137516dcd095119f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af118c19f6b5448319eb3aaf2d556ac54"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class Predicate , class T &gt; </td></tr>
<tr class="memitem:af118c19f6b5448319eb3aaf2d556ac54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af118c19f6b5448319eb3aaf2d556ac54">replace_if</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Predicate pred, const T &amp;newValue)</td></tr>
<tr class="separator:af118c19f6b5448319eb3aaf2d556ac54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dbb806369b062fd90909fd826c2ee4"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </td></tr>
<tr class="memitem:a03dbb806369b062fd90909fd826c2ee4"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a03dbb806369b062fd90909fd826c2ee4">search</a> (ForwardIterator1 <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator1 <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, ForwardIterator2 otherFirst, ForwardIterator2 otherLast)</td></tr>
<tr class="separator:a03dbb806369b062fd90909fd826c2ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf397cad0a67b67fbd1ecddf40d405e"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a9bf397cad0a67b67fbd1ecddf40d405e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9bf397cad0a67b67fbd1ecddf40d405e">sort</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:a9bf397cad0a67b67fbd1ecddf40d405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa597d262eb2f9ef80703c883a2d18d1e"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator &gt; </td></tr>
<tr class="memitem:aa597d262eb2f9ef80703c883a2d18d1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa597d262eb2f9ef80703c883a2d18d1e">sort_bubble</a> (RandomAccessIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, RandomAccessIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:aa597d262eb2f9ef80703c883a2d18d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9fe74c5dcee70bf5dd5c89f1234a02"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator &gt; </td></tr>
<tr class="memitem:a1e9fe74c5dcee70bf5dd5c89f1234a02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1e9fe74c5dcee70bf5dd5c89f1234a02">sort_heap</a> (RandomAccessIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, RandomAccessIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:a1e9fe74c5dcee70bf5dd5c89f1234a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720fbbcb3f399b006969bb00a66686f9"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a720fbbcb3f399b006969bb00a66686f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a720fbbcb3f399b006969bb00a66686f9">sort_quicksort</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:a720fbbcb3f399b006969bb00a66686f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6430516ab4f2e2a7f43323acb6b559d8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6430516ab4f2e2a7f43323acb6b559d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a6430516ab4f2e2a7f43323acb6b559d8">swap</a> (T &amp;a, T &amp;b)</td></tr>
<tr class="separator:a6430516ab4f2e2a7f43323acb6b559d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4661f2c0c4dca098c137179b4d93f3dc"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </td></tr>
<tr class="memitem:a4661f2c0c4dca098c137179b4d93f3dc"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a4661f2c0c4dca098c137179b4d93f3dc">swap_ranges</a> (ForwardIterator1 <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator1 <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, ForwardIterator2 otherFirst)</td></tr>
<tr class="separator:a4661f2c0c4dca098c137179b4d93f3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8234c2c7917f750db94bb068d6fd554e"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:a8234c2c7917f750db94bb068d6fd554e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8234c2c7917f750db94bb068d6fd554e">uninitialized_fill</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, const T &amp;value)</td></tr>
<tr class="separator:a8234c2c7917f750db94bb068d6fd554e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5485ae7bad862f6ff0ab363ed4697b61"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:a5485ae7bad862f6ff0ab363ed4697b61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5485ae7bad862f6ff0ab363ed4697b61">uninitialized_fill_n</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, const int <a class="el" href="namespaceprism.html#acd3c0f96adf158a29387191d79c4d874">size</a>, const T &amp;value)</td></tr>
<tr class="separator:a5485ae7bad862f6ff0ab363ed4697b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff56f151fea6e709350a0e9fbdb70a8"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </td></tr>
<tr class="memitem:a5ff56f151fea6e709350a0e9fbdb70a8"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5ff56f151fea6e709350a0e9fbdb70a8">uninitialized_copy</a> (ForwardIterator1 <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator1 <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, ForwardIterator2 otherFirst)</td></tr>
<tr class="separator:a5ff56f151fea6e709350a0e9fbdb70a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c7d8eb38174ba66d98321b68047e6e"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </td></tr>
<tr class="memitem:ad1c7d8eb38174ba66d98321b68047e6e"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad1c7d8eb38174ba66d98321b68047e6e">uninitialized_copy_n</a> (ForwardIterator1 <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, const int <a class="el" href="namespaceprism.html#acd3c0f96adf158a29387191d79c4d874">size</a>, ForwardIterator2 otherFirst)</td></tr>
<tr class="separator:ad1c7d8eb38174ba66d98321b68047e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2c83ae0d89a6581d1c42ba6fd79de0"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator &gt; </td></tr>
<tr class="memitem:a5f2c83ae0d89a6581d1c42ba6fd79de0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5f2c83ae0d89a6581d1c42ba6fd79de0">p_heapify</a> (RandomAccessIterator node, RandomAccessIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, RandomAccessIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:a5f2c83ae0d89a6581d1c42ba6fd79de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b26c227e2d379b9d934a85a2570bae7"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a6b26c227e2d379b9d934a85a2570bae7"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a6b26c227e2d379b9d934a85a2570bae7">adjacent_find_aux</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:a6b26c227e2d379b9d934a85a2570bae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee0c5bacf315d8cfdc4de7151ba2295"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:adee0c5bacf315d8cfdc4de7151ba2295"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#adee0c5bacf315d8cfdc4de7151ba2295">all_of_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Predicate pred)</td></tr>
<tr class="separator:adee0c5bacf315d8cfdc4de7151ba2295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3105c7afbb375201f4691b7ea966b4"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:aae3105c7afbb375201f4691b7ea966b4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aae3105c7afbb375201f4691b7ea966b4">any_of_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Predicate pred)</td></tr>
<tr class="separator:aae3105c7afbb375201f4691b7ea966b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc5dc440a705fbe80912a49ea6d899b"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a8fc5dc440a705fbe80912a49ea6d899b"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8fc5dc440a705fbe80912a49ea6d899b">copy_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, OutputIterator otherFirst)</td></tr>
<tr class="separator:a8fc5dc440a705fbe80912a49ea6d899b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94bcd5517145cc7b62c59a84a776814"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator1 , class BidirectionalIterator2 &gt; </td></tr>
<tr class="memitem:af94bcd5517145cc7b62c59a84a776814"><td class="memTemplItemLeft" align="right" valign="top">BidirectionalIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af94bcd5517145cc7b62c59a84a776814">copy_backward_aux</a> (BidirectionalIterator1 <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, BidirectionalIterator1 <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, BidirectionalIterator2 otherLast)</td></tr>
<tr class="separator:af94bcd5517145cc7b62c59a84a776814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d95b48370d6b89936a81e08f7ed8d7"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:a06d95b48370d6b89936a81e08f7ed8d7"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a06d95b48370d6b89936a81e08f7ed8d7">copy_if_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, OutputIterator otherFirst, Predicate pred)</td></tr>
<tr class="separator:a06d95b48370d6b89936a81e08f7ed8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305d5bebe30595a5d4705a6cef37b52a"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Size , class OutputIterator &gt; </td></tr>
<tr class="memitem:a305d5bebe30595a5d4705a6cef37b52a"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a305d5bebe30595a5d4705a6cef37b52a">copy_n_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, <a class="el" href="classprism_1_1_size.html">Size</a> n, OutputIterator otherFirst)</td></tr>
<tr class="separator:a305d5bebe30595a5d4705a6cef37b52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161f644c4e266d280a770bb0c9fbe045"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class T &gt; </td></tr>
<tr class="memitem:a161f644c4e266d280a770bb0c9fbe045"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a161f644c4e266d280a770bb0c9fbe045">count_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, const T &amp;value)</td></tr>
<tr class="separator:a161f644c4e266d280a770bb0c9fbe045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d72a3b00c7e3e537c82829965732dad"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:a8d72a3b00c7e3e537c82829965732dad"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8d72a3b00c7e3e537c82829965732dad">count_if_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Predicate pred)</td></tr>
<tr class="separator:a8d72a3b00c7e3e537c82829965732dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e9f7e103a3f2ae15048eb75dc6af97"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a25e9f7e103a3f2ae15048eb75dc6af97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a25e9f7e103a3f2ae15048eb75dc6af97">delete_range_aux</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:a25e9f7e103a3f2ae15048eb75dc6af97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6dc9c68afaa8d8490148baf121bfc1c"><td class="memTemplParams" colspan="2">template&lt;class InputIterator1 , class InputIterator2 &gt; </td></tr>
<tr class="memitem:ac6dc9c68afaa8d8490148baf121bfc1c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ac6dc9c68afaa8d8490148baf121bfc1c">equal_aux</a> (InputIterator1 <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator1 <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, InputIterator2 otherFirst)</td></tr>
<tr class="separator:ac6dc9c68afaa8d8490148baf121bfc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76092b4faa3c2a98088678943ad23df4"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:a76092b4faa3c2a98088678943ad23df4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a76092b4faa3c2a98088678943ad23df4">fill_aux</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, const T &amp;value)</td></tr>
<tr class="separator:a76092b4faa3c2a98088678943ad23df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e7f5f7dee0072f4741520356ebdaee"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:ad2e7f5f7dee0072f4741520356ebdaee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad2e7f5f7dee0072f4741520356ebdaee">fill_n_aux</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, int <a class="el" href="namespaceprism.html#acd3c0f96adf158a29387191d79c4d874">size</a>, const T &amp;value)</td></tr>
<tr class="separator:ad2e7f5f7dee0072f4741520356ebdaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23b68308b7ec11222bd2bfb2904c595"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class T &gt; </td></tr>
<tr class="memitem:af23b68308b7ec11222bd2bfb2904c595"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af23b68308b7ec11222bd2bfb2904c595">find_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, const T &amp;value)</td></tr>
<tr class="separator:af23b68308b7ec11222bd2bfb2904c595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c456a075b03cfe290044281af93203"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:a91c456a075b03cfe290044281af93203"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a91c456a075b03cfe290044281af93203">find_if_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Predicate pred)</td></tr>
<tr class="separator:a91c456a075b03cfe290044281af93203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66df70426cdeee37f0c06a90881f1f36"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class T &gt; </td></tr>
<tr class="memitem:a66df70426cdeee37f0c06a90881f1f36"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a66df70426cdeee37f0c06a90881f1f36">find_last_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, const T &amp;value)</td></tr>
<tr class="separator:a66df70426cdeee37f0c06a90881f1f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adcafd2357df71bd906d85ffe9fdf85"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Function &gt; </td></tr>
<tr class="memitem:a9adcafd2357df71bd906d85ffe9fdf85"><td class="memTemplItemLeft" align="right" valign="top">Function&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9adcafd2357df71bd906d85ffe9fdf85">for_each_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Function func)</td></tr>
<tr class="separator:a9adcafd2357df71bd906d85ffe9fdf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c1478cf9a6f78fa511d96f93b22791"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a29c1478cf9a6f78fa511d96f93b22791"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a29c1478cf9a6f78fa511d96f93b22791">is_sorted_aux</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:a29c1478cf9a6f78fa511d96f93b22791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567b63d0d3fa2bc8bdba883f152848be"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator &gt; </td></tr>
<tr class="memitem:a567b63d0d3fa2bc8bdba883f152848be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a567b63d0d3fa2bc8bdba883f152848be">make_heap_aux</a> (RandomAccessIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, RandomAccessIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:a567b63d0d3fa2bc8bdba883f152848be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5ae6f65d12dcb2e433ffdc95b733bb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9d5ae6f65d12dcb2e433ffdc95b733bb"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9d5ae6f65d12dcb2e433ffdc95b733bb">max_aux</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a9d5ae6f65d12dcb2e433ffdc95b733bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ded05d282e95b0ab21c6aeaca2e8794"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5ded05d282e95b0ab21c6aeaca2e8794"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5ded05d282e95b0ab21c6aeaca2e8794">min_aux</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a5ded05d282e95b0ab21c6aeaca2e8794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4333d241a3ee0f8bce307db84c7eba23"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr class="memitem:a4333d241a3ee0f8bce307db84c7eba23"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a4333d241a3ee0f8bce307db84c7eba23">none_of_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Predicate pred)</td></tr>
<tr class="separator:a4333d241a3ee0f8bce307db84c7eba23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7d8d4b86592081686e15ee7a18f856"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:acb7d8d4b86592081686e15ee7a18f856"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#acb7d8d4b86592081686e15ee7a18f856">remove_aux</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, const T &amp;value)</td></tr>
<tr class="separator:acb7d8d4b86592081686e15ee7a18f856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f41bf6d9ab98a87d693fba69f138dc"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class T &gt; </td></tr>
<tr class="memitem:ae3f41bf6d9ab98a87d693fba69f138dc"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae3f41bf6d9ab98a87d693fba69f138dc">remove_copy_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, OutputIterator otherFirst, const T &amp;value)</td></tr>
<tr class="separator:ae3f41bf6d9ab98a87d693fba69f138dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198b599ea535deb9fdf28c46c8658bd4"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a198b599ea535deb9fdf28c46c8658bd4"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a198b599ea535deb9fdf28c46c8658bd4">remove_copy_if_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, OutputIterator otherFirst, UnaryPredicate pred)</td></tr>
<tr class="separator:a198b599ea535deb9fdf28c46c8658bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e9f5186670e27472aa7d8cd02397eb"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class Predicate &gt; </td></tr>
<tr class="memitem:a95e9f5186670e27472aa7d8cd02397eb"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a95e9f5186670e27472aa7d8cd02397eb">remove_if_aux</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Predicate pred)</td></tr>
<tr class="separator:a95e9f5186670e27472aa7d8cd02397eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad053e45daef65797bc1cff18dfcd8dc0"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:ad053e45daef65797bc1cff18dfcd8dc0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad053e45daef65797bc1cff18dfcd8dc0">replace_aux</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, const T &amp;oldValue, const T &amp;newValue)</td></tr>
<tr class="separator:ad053e45daef65797bc1cff18dfcd8dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7055d91bb6279fa78b8b498297a11eab"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class T &gt; </td></tr>
<tr class="memitem:a7055d91bb6279fa78b8b498297a11eab"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7055d91bb6279fa78b8b498297a11eab">replace_copy_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, OutputIterator otherFirst, const T &amp;oldValue, const T &amp;newValue)</td></tr>
<tr class="separator:a7055d91bb6279fa78b8b498297a11eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e660997b10ccb0985b35999c84a9bbf"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class Predicate , class T &gt; </td></tr>
<tr class="memitem:a1e660997b10ccb0985b35999c84a9bbf"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1e660997b10ccb0985b35999c84a9bbf">replace_copy_if_aux</a> (InputIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, InputIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, OutputIterator otherFirst, Predicate pred, const T &amp;newValue)</td></tr>
<tr class="separator:a1e660997b10ccb0985b35999c84a9bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23d44d30470aed0ee16e931514bd727"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class Predicate , class T &gt; </td></tr>
<tr class="memitem:ad23d44d30470aed0ee16e931514bd727"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad23d44d30470aed0ee16e931514bd727">replace_if_aux</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, Predicate pred, const T &amp;newValue)</td></tr>
<tr class="separator:ad23d44d30470aed0ee16e931514bd727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f8ed8b450ff281e02218e10d5643a7"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </td></tr>
<tr class="memitem:ab6f8ed8b450ff281e02218e10d5643a7"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab6f8ed8b450ff281e02218e10d5643a7">search_aux</a> (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)</td></tr>
<tr class="separator:ab6f8ed8b450ff281e02218e10d5643a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7b2f97895db323cbefbc4af311ccb9"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a9e7b2f97895db323cbefbc4af311ccb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9e7b2f97895db323cbefbc4af311ccb9">sort_aux</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:a9e7b2f97895db323cbefbc4af311ccb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a66e1051c4c7874f305ad2a5f0b37e"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator &gt; </td></tr>
<tr class="memitem:af3a66e1051c4c7874f305ad2a5f0b37e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af3a66e1051c4c7874f305ad2a5f0b37e">sort_bubble_aux</a> (RandomAccessIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, RandomAccessIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:af3a66e1051c4c7874f305ad2a5f0b37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab289bdf7cde130b0aeea21a9711770f4"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ab289bdf7cde130b0aeea21a9711770f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab289bdf7cde130b0aeea21a9711770f4">sort_heap_aux</a> (RandomAccessIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, RandomAccessIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:ab289bdf7cde130b0aeea21a9711770f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e0e235fa71938e5ebf29387b917057"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a46e0e235fa71938e5ebf29387b917057"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a46e0e235fa71938e5ebf29387b917057">sort_quicksort_aux</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:a46e0e235fa71938e5ebf29387b917057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3a7129cc6ab5d9a80301436e4d2e48"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6d3a7129cc6ab5d9a80301436e4d2e48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a6d3a7129cc6ab5d9a80301436e4d2e48">swap_aux</a> (T &amp;a, T &amp;b)</td></tr>
<tr class="separator:a6d3a7129cc6ab5d9a80301436e4d2e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca4ae3ad4c2e21d6fe48b6fae6930c3"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </td></tr>
<tr class="memitem:a7ca4ae3ad4c2e21d6fe48b6fae6930c3"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7ca4ae3ad4c2e21d6fe48b6fae6930c3">swap_ranges_aux</a> (ForwardIterator1 <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator1 <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, ForwardIterator2 otherFirst)</td></tr>
<tr class="separator:a7ca4ae3ad4c2e21d6fe48b6fae6930c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d1fe2d10e98f9de7aec30799f2eec0"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </td></tr>
<tr class="memitem:a85d1fe2d10e98f9de7aec30799f2eec0"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a85d1fe2d10e98f9de7aec30799f2eec0">uninitialized_copy_n_aux</a> (ForwardIterator1 <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, const int <a class="el" href="namespaceprism.html#acd3c0f96adf158a29387191d79c4d874">size</a>, ForwardIterator2 otherFirst)</td></tr>
<tr class="separator:a85d1fe2d10e98f9de7aec30799f2eec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef07b731fbaecb8abe1ad8faabaab1e"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </td></tr>
<tr class="memitem:a6ef07b731fbaecb8abe1ad8faabaab1e"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a6ef07b731fbaecb8abe1ad8faabaab1e">uninitialized_copy_aux</a> (ForwardIterator1 <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator1 <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, ForwardIterator2 otherFirst)</td></tr>
<tr class="separator:a6ef07b731fbaecb8abe1ad8faabaab1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02596d3361c57f312168ffac621e421"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:aa02596d3361c57f312168ffac621e421"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa02596d3361c57f312168ffac621e421">uninitialized_fill_n_aux</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, const int <a class="el" href="namespaceprism.html#acd3c0f96adf158a29387191d79c4d874">size</a>, const T &amp;value)</td></tr>
<tr class="separator:aa02596d3361c57f312168ffac621e421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8fcd4a3943bfa624f77fc8f3af5916"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:aaa8fcd4a3943bfa624f77fc8f3af5916"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aaa8fcd4a3943bfa624f77fc8f3af5916">uninitialized_fill_aux</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>, const T &amp;value)</td></tr>
<tr class="separator:aaa8fcd4a3943bfa624f77fc8f3af5916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d95c728950cef3542d8b1dd27eb344"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator &gt; </td></tr>
<tr class="memitem:a95d95c728950cef3542d8b1dd27eb344"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a95d95c728950cef3542d8b1dd27eb344">p_heapify_aux</a> (RandomAccessIterator node, RandomAccessIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, RandomAccessIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:a95d95c728950cef3542d8b1dd27eb344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403ca8f79c481a89132691c0fd8c3a06"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a403ca8f79c481a89132691c0fd8c3a06"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a403ca8f79c481a89132691c0fd8c3a06">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_array.html">Array</a>&lt; T &gt; &amp;array)</td></tr>
<tr class="separator:a403ca8f79c481a89132691c0fd8c3a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e77ed12f9b3a35d81935362d3050d0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a> ()</td></tr>
<tr class="separator:a8e77ed12f9b3a35d81935362d3050d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ec48544ee84c6327a63ac5c4c5cb60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a73ec48544ee84c6327a63ac5c4c5cb60">Deque</a> (const int <a class="el" href="namespaceprism.html#acd3c0f96adf158a29387191d79c4d874">size</a>, const T &amp;value=T())</td></tr>
<tr class="separator:a73ec48544ee84c6327a63ac5c4c5cb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bbb75108907fb0573f35d3b82ddf3a"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:aa7bbb75108907fb0573f35d3b82ddf3a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa7bbb75108907fb0573f35d3b82ddf3a">Deque</a> (ForwardIterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, ForwardIterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:aa7bbb75108907fb0573f35d3b82ddf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8b2ede230218b04aa9b6f48c94f77d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a6d8b2ede230218b04aa9b6f48c94f77d">Deque</a> (std::initializer_list&lt; T &gt; list)</td></tr>
<tr class="separator:a6d8b2ede230218b04aa9b6f48c94f77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a6c6b9242eb9a0c22af9e28ee4ae80"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af8a6c6b9242eb9a0c22af9e28ee4ae80">Deque</a> (const Deque&lt; T, T_Alloc &gt; &amp;<a class="el" href="namespaceprism.html#ae776f4cd825f79e7af1cf6ee1d90a209">copy</a>)</td></tr>
<tr class="separator:af8a6c6b9242eb9a0c22af9e28ee4ae80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331c22c8877ca45c3f9504b1fbfb711c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a331c22c8877ca45c3f9504b1fbfb711c">~Deque</a> ()</td></tr>
<tr class="separator:a331c22c8877ca45c3f9504b1fbfb711c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48d4e417d7dc90cd7979795347e1718"><td class="memItemLeft" align="right" valign="top">T_Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af48d4e417d7dc90cd7979795347e1718">allocator</a> () const </td></tr>
<tr class="separator:af48d4e417d7dc90cd7979795347e1718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3c0da5e0e065dd58d686f551746982"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#afc3c0da5e0e065dd58d686f551746982">append</a> (const T &amp;value)</td></tr>
<tr class="separator:afc3c0da5e0e065dd58d686f551746982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675cbab48f22d95f990b33294a447dfe"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a675cbab48f22d95f990b33294a447dfe">at</a> (const int i)</td></tr>
<tr class="separator:a675cbab48f22d95f990b33294a447dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fa4c8645ce4e3df7586e5a9f50c768"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a32fa4c8645ce4e3df7586e5a9f50c768">back</a> ()</td></tr>
<tr class="separator:a32fa4c8645ce4e3df7586e5a9f50c768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fcc740caf535a0f4ee6bba7301cf7f"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a05fcc740caf535a0f4ee6bba7301cf7f">begin</a> ()</td></tr>
<tr class="separator:a05fcc740caf535a0f4ee6bba7301cf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f11d607fd7daaeaf07d7b83e1add209"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7f11d607fd7daaeaf07d7b83e1add209">capacity</a> () const </td></tr>
<tr class="separator:a7f11d607fd7daaeaf07d7b83e1add209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7a4333c9a67559cfd90bb6d1c85420"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#acd7a4333c9a67559cfd90bb6d1c85420">cbegin</a> () const </td></tr>
<tr class="separator:acd7a4333c9a67559cfd90bb6d1c85420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0247b88b3e29f34b1cb742d724a6a330"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a0247b88b3e29f34b1cb742d724a6a330">cend</a> () const </td></tr>
<tr class="separator:a0247b88b3e29f34b1cb742d724a6a330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22144cb445517f69b2e6f76586cf75d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad22144cb445517f69b2e6f76586cf75d">clear</a> ()</td></tr>
<tr class="separator:ad22144cb445517f69b2e6f76586cf75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f07ef2e7db05a23c631dee99ad4eba3"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8f07ef2e7db05a23c631dee99ad4eba3">constBegin</a> () const </td></tr>
<tr class="separator:a8f07ef2e7db05a23c631dee99ad4eba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b5e8524d7d3106a0b01cd002af8f75"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a61b5e8524d7d3106a0b01cd002af8f75">constEnd</a> () const </td></tr>
<tr class="separator:a61b5e8524d7d3106a0b01cd002af8f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec550341cf4587d3a0afaa9492e77503"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aec550341cf4587d3a0afaa9492e77503">contains</a> (const T &amp;value) const </td></tr>
<tr class="separator:aec550341cf4587d3a0afaa9492e77503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02873ae9088199948854cc05b20831c5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a02873ae9088199948854cc05b20831c5">count</a> (const T &amp;value) const </td></tr>
<tr class="separator:a02873ae9088199948854cc05b20831c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7441180af2d914cc54ac35aead6ed030"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7441180af2d914cc54ac35aead6ed030">empty</a> () const </td></tr>
<tr class="separator:a7441180af2d914cc54ac35aead6ed030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8976ba2aea6612a03f75a390f40daef8"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8976ba2aea6612a03f75a390f40daef8">end</a> ()</td></tr>
<tr class="separator:a8976ba2aea6612a03f75a390f40daef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc42fa48a8be97e541b137e9ae83c18"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#abfc42fa48a8be97e541b137e9ae83c18">endsWith</a> (const T &amp;value) const </td></tr>
<tr class="separator:abfc42fa48a8be97e541b137e9ae83c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f69cc5e78e0a7bcd2d9a7ed9c05a8b"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a46f69cc5e78e0a7bcd2d9a7ed9c05a8b">erase</a> (iterator pos)</td></tr>
<tr class="separator:a46f69cc5e78e0a7bcd2d9a7ed9c05a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab853ba84b4ed547730d02a8c21328e65"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab853ba84b4ed547730d02a8c21328e65">erase</a> (iterator <a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a>, iterator <a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a>)</td></tr>
<tr class="separator:ab853ba84b4ed547730d02a8c21328e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76b40745e46fbda01eb55d8258ff498"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab76b40745e46fbda01eb55d8258ff498">fill</a> (const T &amp;value)</td></tr>
<tr class="separator:ab76b40745e46fbda01eb55d8258ff498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fb7a1926a9e8e59300cd5e370470da"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae3fb7a1926a9e8e59300cd5e370470da">first</a> ()</td></tr>
<tr class="separator:ae3fb7a1926a9e8e59300cd5e370470da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c27e6535264895614b87eefa337404d"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a0c27e6535264895614b87eefa337404d">front</a> ()</td></tr>
<tr class="separator:a0c27e6535264895614b87eefa337404d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b6d3259343e632ab4e9d806498ac92"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a78b6d3259343e632ab4e9d806498ac92">indexOf</a> (const T &amp;value, const int from=0) const </td></tr>
<tr class="separator:a78b6d3259343e632ab4e9d806498ac92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52510a241330236aa7202abf65c6dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af52510a241330236aa7202abf65c6dcb">insert</a> (const int index, const T &amp;value)</td></tr>
<tr class="separator:af52510a241330236aa7202abf65c6dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd912a072952b08ebd1009abbede3ee5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#abd912a072952b08ebd1009abbede3ee5">insert</a> (const int index, const int <a class="el" href="namespaceprism.html#a024117fc3639cdf6598509edf22f034a">count</a>, const T &amp;value)</td></tr>
<tr class="separator:abd912a072952b08ebd1009abbede3ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391f88be142a74df98c77632bb8352af"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a391f88be142a74df98c77632bb8352af">insert</a> (iterator insertBefore, const T &amp;value)</td></tr>
<tr class="separator:a391f88be142a74df98c77632bb8352af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414531a413ed8c90d951f6fd94ac5535"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a414531a413ed8c90d951f6fd94ac5535">insert</a> (iterator insertBefore, const int <a class="el" href="namespaceprism.html#a024117fc3639cdf6598509edf22f034a">count</a>, const T &amp;value)</td></tr>
<tr class="separator:a414531a413ed8c90d951f6fd94ac5535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538f7dd7bdd8d7963b39a9aea232a598"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a538f7dd7bdd8d7963b39a9aea232a598">isEmpty</a> () const </td></tr>
<tr class="separator:a538f7dd7bdd8d7963b39a9aea232a598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4956c4e865f55ca126b7fb973b5078"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#abe4956c4e865f55ca126b7fb973b5078">last</a> ()</td></tr>
<tr class="separator:abe4956c4e865f55ca126b7fb973b5078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ed081bf6c17e965bfac0d207cd6c28"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af0ed081bf6c17e965bfac0d207cd6c28">lastIndexOf</a> (const T &amp;value, int from=-1) const </td></tr>
<tr class="separator:af0ed081bf6c17e965bfac0d207cd6c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb39a03321ba086c660e96bfa11d33c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, T_Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aeb39a03321ba086c660e96bfa11d33c4">mid</a> (const int startIndex, const int <a class="el" href="namespaceprism.html#a024117fc3639cdf6598509edf22f034a">count</a>) const </td></tr>
<tr class="separator:aeb39a03321ba086c660e96bfa11d33c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682dc15d5493595804b4cf818b16281d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a682dc15d5493595804b4cf818b16281d">pop_back</a> ()</td></tr>
<tr class="separator:a682dc15d5493595804b4cf818b16281d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407f71f548b4930e7880b44cd695b33d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a407f71f548b4930e7880b44cd695b33d">pop_front</a> ()</td></tr>
<tr class="separator:a407f71f548b4930e7880b44cd695b33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a9a7c94d57bb61f25a61ef10d74b80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ac5a9a7c94d57bb61f25a61ef10d74b80">prepend</a> (const T &amp;value)</td></tr>
<tr class="separator:ac5a9a7c94d57bb61f25a61ef10d74b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae03a861ef55e15b5a64c5cb2a727667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aae03a861ef55e15b5a64c5cb2a727667">push_back</a> (const T &amp;value)</td></tr>
<tr class="separator:aae03a861ef55e15b5a64c5cb2a727667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a451a8db591d6c4fc315b05f9bff515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9a451a8db591d6c4fc315b05f9bff515">push_front</a> (const T &amp;value)</td></tr>
<tr class="separator:a9a451a8db591d6c4fc315b05f9bff515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b180b06c92cd65b70d2e565878e5d06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5b180b06c92cd65b70d2e565878e5d06">remove</a> (const int index)</td></tr>
<tr class="separator:a5b180b06c92cd65b70d2e565878e5d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a67eb6dd63f426b2837aebb07940b0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2a67eb6dd63f426b2837aebb07940b0b">remove</a> (const int index, const int <a class="el" href="namespaceprism.html#a024117fc3639cdf6598509edf22f034a">count</a>)</td></tr>
<tr class="separator:a2a67eb6dd63f426b2837aebb07940b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a96073d835746d48ba0a145c33b29e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a91a96073d835746d48ba0a145c33b29e">removeAll</a> (const T &amp;value)</td></tr>
<tr class="separator:a91a96073d835746d48ba0a145c33b29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a0d96bc03a45529e399cd39c48cb66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a32a0d96bc03a45529e399cd39c48cb66">removeFirst</a> ()</td></tr>
<tr class="separator:a32a0d96bc03a45529e399cd39c48cb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd774edd9e5b7398334440070da6bdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7dd774edd9e5b7398334440070da6bdd">removeLast</a> ()</td></tr>
<tr class="separator:a7dd774edd9e5b7398334440070da6bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac76605957b60675b2859cef694c61f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#acac76605957b60675b2859cef694c61f">replace</a> (const int index, const T &amp;value)</td></tr>
<tr class="separator:acac76605957b60675b2859cef694c61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7236cdb4e2661bd63c2fe4ee5c3452f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7236cdb4e2661bd63c2fe4ee5c3452f9">resize</a> (const int newSize, const T &amp;value=T())</td></tr>
<tr class="separator:a7236cdb4e2661bd63c2fe4ee5c3452f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3c0f96adf158a29387191d79c4d874"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#acd3c0f96adf158a29387191d79c4d874">size</a> () const </td></tr>
<tr class="separator:acd3c0f96adf158a29387191d79c4d874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e90ca54b9fa627213076f93d44ca2d"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a92e90ca54b9fa627213076f93d44ca2d">startsWith</a> (const T &amp;value) const </td></tr>
<tr class="separator:a92e90ca54b9fa627213076f93d44ca2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07654e91e7474a3ccdcd95bb5e57baea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_list.html">List</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a07654e91e7474a3ccdcd95bb5e57baea">toList</a> () const </td></tr>
<tr class="separator:a07654e91e7474a3ccdcd95bb5e57baea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770640a1fe99095d96e9295b225ac93d"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a770640a1fe99095d96e9295b225ac93d">toStdDeque</a> () const </td></tr>
<tr class="separator:a770640a1fe99095d96e9295b225ac93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cdc796ecf7df67ce6377bfe9eadb7c"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae5cdc796ecf7df67ce6377bfe9eadb7c">operator[]</a> (const int i)</td></tr>
<tr class="separator:ae5cdc796ecf7df67ce6377bfe9eadb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a3ba3d60ef11974d02f7941fa9a263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, T_Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab5a3ba3d60ef11974d02f7941fa9a263">operator=</a> (const <a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, T_Alloc &gt; &amp;rhs)</td></tr>
<tr class="separator:ab5a3ba3d60ef11974d02f7941fa9a263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47eb78b48fe05bc2087a1c5e70f4c373"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a47eb78b48fe05bc2087a1c5e70f4c373">operator==</a> (const <a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, T_Alloc &gt; &amp;rhs)</td></tr>
<tr class="separator:a47eb78b48fe05bc2087a1c5e70f4c373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7410d6cd07f48e8495d2ac7196b2e609"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7410d6cd07f48e8495d2ac7196b2e609">operator!=</a> (const <a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, T_Alloc &gt; &amp;rhs)</td></tr>
<tr class="separator:a7410d6cd07f48e8495d2ac7196b2e609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769b9ece349795edbfeb8e33cbf276e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a769b9ece349795edbfeb8e33cbf276e5">operator+</a> (const <a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, Alloc &gt; &amp;rhs)</td></tr>
<tr class="separator:a769b9ece349795edbfeb8e33cbf276e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1619579754dfe66f3fe3559f2e4495e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1619579754dfe66f3fe3559f2e4495e5">operator+=</a> (const <a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, Alloc &gt; &amp;rhs)</td></tr>
<tr class="separator:a1619579754dfe66f3fe3559f2e4495e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40203d2e776fe0acf317a98ef08f8be7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, T_Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a40203d2e776fe0acf317a98ef08f8be7">operator&lt;&lt;</a> (const T &amp;value)</td></tr>
<tr class="separator:a40203d2e776fe0acf317a98ef08f8be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602c194731bf182cf114b7d297bbff51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, T_Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a602c194731bf182cf114b7d297bbff51">operator&lt;&lt;</a> (const <a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, T_Alloc &gt; &amp;rhs)</td></tr>
<tr class="separator:a602c194731bf182cf114b7d297bbff51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554e40f4cee7980e001683ea75b16cd9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a554e40f4cee7980e001683ea75b16cd9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, T_Alloc &gt; &amp;d)</td></tr>
<tr class="separator:a554e40f4cee7980e001683ea75b16cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50da64555d454821545fe0311fde6a62"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a50da64555d454821545fe0311fde6a62"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a50da64555d454821545fe0311fde6a62">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_list.html">List</a>&lt; T &gt; &amp;list)</td></tr>
<tr class="separator:a50da64555d454821545fe0311fde6a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62c0c26668facbe5607e8915442010e"><td class="memTemplParams" colspan="2">template&lt;class T , typename... Args&gt; </td></tr>
<tr class="memitem:af62c0c26668facbe5607e8915442010e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af62c0c26668facbe5607e8915442010e">construct</a> (T *p, Args &amp;&amp;...args)</td></tr>
<tr class="separator:af62c0c26668facbe5607e8915442010e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af889ac2726920ab1b4f5361e6563d041"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af889ac2726920ab1b4f5361e6563d041"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af889ac2726920ab1b4f5361e6563d041">destroy</a> (T *p)</td></tr>
<tr class="separator:af889ac2726920ab1b4f5361e6563d041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df924e4deb059bf1200701c8235410a"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a9df924e4deb059bf1200701c8235410a"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9df924e4deb059bf1200701c8235410a">operator!=</a> (const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p1, const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p2)</td></tr>
<tr class="separator:a9df924e4deb059bf1200701c8235410a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6391c124e006b0e3a3ec67f55e208b0"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ad6391c124e006b0e3a3ec67f55e208b0"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad6391c124e006b0e3a3ec67f55e208b0">operator!=</a> (const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p1, const U *p2)</td></tr>
<tr class="separator:ad6391c124e006b0e3a3ec67f55e208b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8792dbd5cac5678390843bacdb69daa"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ab8792dbd5cac5678390843bacdb69daa"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab8792dbd5cac5678390843bacdb69daa">operator!=</a> (const U *p1, const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p2)</td></tr>
<tr class="separator:ab8792dbd5cac5678390843bacdb69daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53d52e8a36ec7ca58ea1731cc18f1d8"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ae53d52e8a36ec7ca58ea1731cc18f1d8"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae53d52e8a36ec7ca58ea1731cc18f1d8">operator==</a> (const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p1, const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p2)</td></tr>
<tr class="separator:ae53d52e8a36ec7ca58ea1731cc18f1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b73e87f080646696ed6b595a3900119"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a2b73e87f080646696ed6b595a3900119"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2b73e87f080646696ed6b595a3900119">operator==</a> (const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p1, const U *p2)</td></tr>
<tr class="separator:a2b73e87f080646696ed6b595a3900119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f29b22985dc0ec1fc548a551ce313ed"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a1f29b22985dc0ec1fc548a551ce313ed"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1f29b22985dc0ec1fc548a551ce313ed">operator==</a> (const U *p1, const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;p2)</td></tr>
<tr class="separator:a1f29b22985dc0ec1fc548a551ce313ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b2b2b5b2c5f305badd964c24625b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_bitvector.html">Bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a26b2b2b5b2c5f305badd964c24625b36">operator&amp;</a> (const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;bv1, const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;bv2)</td></tr>
<tr class="separator:a26b2b2b5b2c5f305badd964c24625b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145d1e196c14cdbdc4eccb01c60c9275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_bitvector.html">Bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a145d1e196c14cdbdc4eccb01c60c9275">operator|</a> (const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;bv1, const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;bv2)</td></tr>
<tr class="separator:a145d1e196c14cdbdc4eccb01c60c9275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a18ff84f30ae8056d6807056a24ef14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_bitvector.html">Bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a6a18ff84f30ae8056d6807056a24ef14">operator^</a> (const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;bv1, const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;bv2)</td></tr>
<tr class="separator:a6a18ff84f30ae8056d6807056a24ef14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca036c7f0f8a5aaf98b46b4879189bcc"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aca036c7f0f8a5aaf98b46b4879189bcc">operator==</a> (const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;bv1, const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;bv2)</td></tr>
<tr class="separator:aca036c7f0f8a5aaf98b46b4879189bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca663878d61686ef365f3e51efddc4b4"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aca663878d61686ef365f3e51efddc4b4">operator!=</a> (const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;bv1, const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;bv2)</td></tr>
<tr class="separator:aca663878d61686ef365f3e51efddc4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b98ff0fee78022242292f24158ad1f0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a0b98ff0fee78022242292f24158ad1f0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;bv)</td></tr>
<tr class="separator:a0b98ff0fee78022242292f24158ad1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba68b64a6cfdcff9e144b8c2476cddb"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1ba68b64a6cfdcff9e144b8c2476cddb">operator==</a> (const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c1, const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c2)</td></tr>
<tr class="separator:a1ba68b64a6cfdcff9e144b8c2476cddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249b6933154570d808cdd405ab1fd89b"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a249b6933154570d808cdd405ab1fd89b">operator!=</a> (const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c1, const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c2)</td></tr>
<tr class="separator:a249b6933154570d808cdd405ab1fd89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc3e64ba36a16f24cb0ae387c83f35f"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2fc3e64ba36a16f24cb0ae387c83f35f">operator&lt;</a> (const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c1, const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c2)</td></tr>
<tr class="separator:a2fc3e64ba36a16f24cb0ae387c83f35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a312729c4c9ae72836d0034a6f0758"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab8a312729c4c9ae72836d0034a6f0758">operator&gt;</a> (const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c1, const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c2)</td></tr>
<tr class="separator:ab8a312729c4c9ae72836d0034a6f0758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d86e9266469c8a40537e12a560b066"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a87d86e9266469c8a40537e12a560b066">operator&lt;=</a> (const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c1, const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c2)</td></tr>
<tr class="separator:a87d86e9266469c8a40537e12a560b066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad049ddef9beb3fec3e7057a7f651280"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aad049ddef9beb3fec3e7057a7f651280">operator&gt;=</a> (const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c1, const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c2)</td></tr>
<tr class="separator:aad049ddef9beb3fec3e7057a7f651280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67ea1154a35dabe9c2c232aff65e930"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa67ea1154a35dabe9c2c232aff65e930">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;c)</td></tr>
<tr class="separator:aa67ea1154a35dabe9c2c232aff65e930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce1ad6e6392618212d5ab3bebb8e585"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a0ce1ad6e6392618212d5ab3bebb8e585">operator==</a> (const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c1, const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c2)</td></tr>
<tr class="separator:a0ce1ad6e6392618212d5ab3bebb8e585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cbf7ef406800002b446a0f1e917745"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a58cbf7ef406800002b446a0f1e917745">operator!=</a> (const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c1, const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c2)</td></tr>
<tr class="separator:a58cbf7ef406800002b446a0f1e917745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e662d15b162ca76912c491798caefd3"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8e662d15b162ca76912c491798caefd3">operator&lt;</a> (const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c1, const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c2)</td></tr>
<tr class="separator:a8e662d15b162ca76912c491798caefd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671739ac8567654dba563c34af92213f"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a671739ac8567654dba563c34af92213f">operator&gt;</a> (const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c1, const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c2)</td></tr>
<tr class="separator:a671739ac8567654dba563c34af92213f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63d3d39d3fad8fa5c5966cc4f306324"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa63d3d39d3fad8fa5c5966cc4f306324">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;c)</td></tr>
<tr class="separator:aa63d3d39d3fad8fa5c5966cc4f306324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b5b2765c314b2baa2dba5c57419829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_fraction.html">Fraction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ac1b5b2765c314b2baa2dba5c57419829">operator+</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:ac1b5b2765c314b2baa2dba5c57419829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2daf470e5f35f8450447deb2634c22c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_fraction.html">Fraction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2daf470e5f35f8450447deb2634c22c1">operator-</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:a2daf470e5f35f8450447deb2634c22c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f48e3429a86bafcc7c21a2bd6a7ae1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_fraction.html">Fraction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ac4f48e3429a86bafcc7c21a2bd6a7ae1">operator*</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:ac4f48e3429a86bafcc7c21a2bd6a7ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5007702b28b447f62c3b9df62f2aa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_fraction.html">Fraction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1f5007702b28b447f62c3b9df62f2aa4">operator*</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;fraction, const int i)</td></tr>
<tr class="separator:a1f5007702b28b447f62c3b9df62f2aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ff5871f65565a84b886c5013bcd50a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_fraction.html">Fraction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#af1ff5871f65565a84b886c5013bcd50a">operator*</a> (const int i, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;fraction)</td></tr>
<tr class="separator:af1ff5871f65565a84b886c5013bcd50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba7b5cc9750f0d6cda50f0cb874da6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_fraction.html">Fraction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7ba7b5cc9750f0d6cda50f0cb874da6f">operator/</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:a7ba7b5cc9750f0d6cda50f0cb874da6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105ac9995ade66ebb2a039ef90751c7a"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a105ac9995ade66ebb2a039ef90751c7a">operator&lt;</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:a105ac9995ade66ebb2a039ef90751c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7122a7ff43fc6aba9cef9d31fe8c7559"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7122a7ff43fc6aba9cef9d31fe8c7559">operator&gt;</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:a7122a7ff43fc6aba9cef9d31fe8c7559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9e84008b9eaa99d29d4b74cd150cd8"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5b9e84008b9eaa99d29d4b74cd150cd8">operator==</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:a5b9e84008b9eaa99d29d4b74cd150cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea72179b12983e614f72acd2b3cbf0e0"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aea72179b12983e614f72acd2b3cbf0e0">operator!=</a> (const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f1, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f2)</td></tr>
<tr class="separator:aea72179b12983e614f72acd2b3cbf0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2d182a77a92e6cba7917dbd58f9d87"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9c2d182a77a92e6cba7917dbd58f9d87">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;f)</td></tr>
<tr class="separator:a9c2d182a77a92e6cba7917dbd58f9d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33537d30f01f996f8a05fc5b1b49ba3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a33537d30f01f996f8a05fc5b1b49ba3b">operator+</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m1, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m2)</td></tr>
<tr class="separator:a33537d30f01f996f8a05fc5b1b49ba3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a2f64f209065f753bed62a880b75b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a34a2f64f209065f753bed62a880b75b6">operator-</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m1, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m2)</td></tr>
<tr class="separator:a34a2f64f209065f753bed62a880b75b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879d3410d690b5722a9af17297f38fbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a879d3410d690b5722a9af17297f38fbb">operator-</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m)</td></tr>
<tr class="separator:a879d3410d690b5722a9af17297f38fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae44fb46bb709a5c8f4d592baf65522"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9ae44fb46bb709a5c8f4d592baf65522">operator*</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m1, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m2)</td></tr>
<tr class="separator:a9ae44fb46bb709a5c8f4d592baf65522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3639f7bd46a54726522dfe406841ea9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab3639f7bd46a54726522dfe406841ea9">operator*</a> (const float factor, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m)</td></tr>
<tr class="separator:ab3639f7bd46a54726522dfe406841ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4073983f089695c40b6fd20d892175f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a4073983f089695c40b6fd20d892175f9">operator*</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m, const float factor)</td></tr>
<tr class="separator:a4073983f089695c40b6fd20d892175f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2859acb8e8dd6fea8678e14249e561d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa2859acb8e8dd6fea8678e14249e561d">operator*</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m1, const float *m2)</td></tr>
<tr class="separator:aa2859acb8e8dd6fea8678e14249e561d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e83bcd69595728106bed838aeb32f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5e83bcd69595728106bed838aeb32f70">operator*</a> (const float *m1, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m2)</td></tr>
<tr class="separator:a5e83bcd69595728106bed838aeb32f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ceb3342a808c88d0bb7c1f7e0ef82b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a95ceb3342a808c88d0bb7c1f7e0ef82b">operator*</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m)</td></tr>
<tr class="separator:a95ceb3342a808c88d0bb7c1f7e0ef82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f1e6e0f84169fce23b236e0312d6a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a04f1e6e0f84169fce23b236e0312d6a0">operator*</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v)</td></tr>
<tr class="separator:a04f1e6e0f84169fce23b236e0312d6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a10d8ea1e63b19d02bd294e4ebabb1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5a10d8ea1e63b19d02bd294e4ebabb1b">operator*</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m)</td></tr>
<tr class="separator:a5a10d8ea1e63b19d02bd294e4ebabb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad125bd8304d577b6f879fb973f774eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad125bd8304d577b6f879fb973f774eb8">operator*</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v)</td></tr>
<tr class="separator:ad125bd8304d577b6f879fb973f774eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44373b8bda7131a90d04eef7e455ea6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a44373b8bda7131a90d04eef7e455ea6f">operator*</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m)</td></tr>
<tr class="separator:a44373b8bda7131a90d04eef7e455ea6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82522932359d2381607cf1fe0c898011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a82522932359d2381607cf1fe0c898011">operator*</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p)</td></tr>
<tr class="separator:a82522932359d2381607cf1fe0c898011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517b4bc9b0ccc23f79b744d93b540fa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a517b4bc9b0ccc23f79b744d93b540fa6">operator/</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m, const float divisor)</td></tr>
<tr class="separator:a517b4bc9b0ccc23f79b744d93b540fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8804ec2ab8dda9441d64e947f05e293c"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8804ec2ab8dda9441d64e947f05e293c">operator==</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m1, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m2)</td></tr>
<tr class="separator:a8804ec2ab8dda9441d64e947f05e293c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d184994eec61a1511fc936a9facb69a"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a4d184994eec61a1511fc936a9facb69a">operator!=</a> (const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m1, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;m2)</td></tr>
<tr class="separator:a4d184994eec61a1511fc936a9facb69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65e15b3e601e0570beb49a11610c671"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab65e15b3e601e0570beb49a11610c671">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;matrix)</td></tr>
<tr class="separator:ab65e15b3e601e0570beb49a11610c671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9fe7ab8ef5f1ee0338e3b057624393"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#acb9fe7ab8ef5f1ee0338e3b057624393">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p)</td></tr>
<tr class="separator:acb9fe7ab8ef5f1ee0338e3b057624393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e983b5c32c93114583309eda19dc2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a49e983b5c32c93114583309eda19dc2b">operator+</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p1, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p2)</td></tr>
<tr class="separator:a49e983b5c32c93114583309eda19dc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505cbd94f024ad80136afe0b751da08a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a505cbd94f024ad80136afe0b751da08a">operator-</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p1, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p2)</td></tr>
<tr class="separator:a505cbd94f024ad80136afe0b751da08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40976ce143923309d4c737bb8288d9e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a40976ce143923309d4c737bb8288d9e5">operator*</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p, const int factor)</td></tr>
<tr class="separator:a40976ce143923309d4c737bb8288d9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e41c0858ff4149eafa1bc878dabb7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a96e41c0858ff4149eafa1bc878dabb7c">operator*</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p, const float factor)</td></tr>
<tr class="separator:a96e41c0858ff4149eafa1bc878dabb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46a547ddc48425588986b0840d026a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa46a547ddc48425588986b0840d026a4">operator*</a> (const int factor, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p)</td></tr>
<tr class="separator:aa46a547ddc48425588986b0840d026a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec2671f1e6c155a79740a8556baecc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1ec2671f1e6c155a79740a8556baecc0">operator*</a> (const float factor, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p)</td></tr>
<tr class="separator:a1ec2671f1e6c155a79740a8556baecc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f73aee33931e5b9977da32e50d47c0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5f73aee33931e5b9977da32e50d47c0e">operator/</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p, const float divisor)</td></tr>
<tr class="separator:a5f73aee33931e5b9977da32e50d47c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739baa4e75c1ca83624d486eec1d45e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a739baa4e75c1ca83624d486eec1d45e9">operator==</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p1, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p2)</td></tr>
<tr class="separator:a739baa4e75c1ca83624d486eec1d45e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cab41d882d24ca064927f2390ef3a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a75cab41d882d24ca064927f2390ef3a6">operator!=</a> (const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p1, const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;p2)</td></tr>
<tr class="separator:a75cab41d882d24ca064927f2390ef3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad408bf2576dfc62a573cb44aa895fb"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#acad408bf2576dfc62a573cb44aa895fb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p)</td></tr>
<tr class="separator:acad408bf2576dfc62a573cb44aa895fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64243aa2d4cf6ddb70526aaeda396f82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_pointf.html">Pointf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a64243aa2d4cf6ddb70526aaeda396f82">operator+</a> (const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p1, const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p2)</td></tr>
<tr class="separator:a64243aa2d4cf6ddb70526aaeda396f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435d5c45d873875f2c5092d102eddb78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_pointf.html">Pointf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a435d5c45d873875f2c5092d102eddb78">operator-</a> (const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p1, const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p2)</td></tr>
<tr class="separator:a435d5c45d873875f2c5092d102eddb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1984e58679ef4d8fcdd37726ee6483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_pointf.html">Pointf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ade1984e58679ef4d8fcdd37726ee6483">operator*</a> (const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p, const float factor)</td></tr>
<tr class="separator:ade1984e58679ef4d8fcdd37726ee6483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409aa6b61b79f029d78f6d4c3aba2df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_pointf.html">Pointf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a409aa6b61b79f029d78f6d4c3aba2df5">operator*</a> (const float factor, const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p)</td></tr>
<tr class="separator:a409aa6b61b79f029d78f6d4c3aba2df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71504f6dd299e8bc788e07d11d29dc5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_pointf.html">Pointf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a71504f6dd299e8bc788e07d11d29dc5e">operator/</a> (const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p, const float divisor)</td></tr>
<tr class="separator:a71504f6dd299e8bc788e07d11d29dc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ab889958edc08eea9a5bea056cd9c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a13ab889958edc08eea9a5bea056cd9c1">operator==</a> (const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p1, const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p2)</td></tr>
<tr class="separator:a13ab889958edc08eea9a5bea056cd9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae010d5880eb7bcf5119f006e26bf473f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae010d5880eb7bcf5119f006e26bf473f">operator!=</a> (const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p1, const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;p2)</td></tr>
<tr class="separator:ae010d5880eb7bcf5119f006e26bf473f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81bceaddc25922e571b4bf427ffe296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad81bceaddc25922e571b4bf427ffe296">operator+</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q1, const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q2)</td></tr>
<tr class="separator:ad81bceaddc25922e571b4bf427ffe296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eae37b5dc73c544572686f215cea89d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5eae37b5dc73c544572686f215cea89d">operator-</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q1, const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q2)</td></tr>
<tr class="separator:a5eae37b5dc73c544572686f215cea89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04c2e5eae2242c58a967086ecad8ff4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae04c2e5eae2242c58a967086ecad8ff4">operator-</a> (<a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr class="separator:ae04c2e5eae2242c58a967086ecad8ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c3eeec91c3a178711b6f05a5487d70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a74c3eeec91c3a178711b6f05a5487d70">operator*</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q1, const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q2)</td></tr>
<tr class="separator:a74c3eeec91c3a178711b6f05a5487d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45806b1a58ec5aae0db87d399d4d832b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a45806b1a58ec5aae0db87d399d4d832b">operator*</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q, const float factor)</td></tr>
<tr class="separator:a45806b1a58ec5aae0db87d399d4d832b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f03413053b1efa6851344eb39a5982"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad9f03413053b1efa6851344eb39a5982">operator*</a> (const float factor, const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr class="separator:ad9f03413053b1efa6851344eb39a5982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aebd3615ba448915f37140515a37b05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8aebd3615ba448915f37140515a37b05">operator*</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v)</td></tr>
<tr class="separator:a8aebd3615ba448915f37140515a37b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4c5e120d8c4de9891f2261a50f100e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2c4c5e120d8c4de9891f2261a50f100e">operator*</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v)</td></tr>
<tr class="separator:a2c4c5e120d8c4de9891f2261a50f100e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec648937a53338bcd9879670877d0425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aec648937a53338bcd9879670877d0425">operator/</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q, const float divisor)</td></tr>
<tr class="separator:aec648937a53338bcd9879670877d0425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ae112433b9ab32c801cccc9c3f74f0"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ac4ae112433b9ab32c801cccc9c3f74f0">operator==</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q1, const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q2)</td></tr>
<tr class="separator:ac4ae112433b9ab32c801cccc9c3f74f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e32551f997ae19dc52df146482405c1"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a9e32551f997ae19dc52df146482405c1">operator!=</a> (const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q1, const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q2)</td></tr>
<tr class="separator:a9e32551f997ae19dc52df146482405c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2beaed7a837821f0abc608cf6ac6c0f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad2beaed7a837821f0abc608cf6ac6c0f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr class="separator:ad2beaed7a837821f0abc608cf6ac6c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe409fa2ef458a2d477ed7845cf4b6a6"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#abe409fa2ef458a2d477ed7845cf4b6a6">operator==</a> (const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;r1, const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;r2)</td></tr>
<tr class="separator:abe409fa2ef458a2d477ed7845cf4b6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f46c5ebd3cec844925173aaacbed9f"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad9f46c5ebd3cec844925173aaacbed9f">operator!=</a> (const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;r1, const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;r2)</td></tr>
<tr class="separator:ad9f46c5ebd3cec844925173aaacbed9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fd2a97b66b06ba6e451e1890136ff4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a52fd2a97b66b06ba6e451e1890136ff4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="separator:a52fd2a97b66b06ba6e451e1890136ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7baeb09cd2ee29251667ad18a2bd00"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2a7baeb09cd2ee29251667ad18a2bd00">operator==</a> (const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s1, const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s2)</td></tr>
<tr class="separator:a2a7baeb09cd2ee29251667ad18a2bd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ab3c18ecc73e21e7281dbe180e07e8"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a63ab3c18ecc73e21e7281dbe180e07e8">operator!=</a> (const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s1, const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s2)</td></tr>
<tr class="separator:a63ab3c18ecc73e21e7281dbe180e07e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7141aeb35db81548155e44d60c05530e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7141aeb35db81548155e44d60c05530e">operator+</a> (const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s1, const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s2)</td></tr>
<tr class="separator:a7141aeb35db81548155e44d60c05530e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab170e3ca42d85a6766cbc7950ddfb0c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab170e3ca42d85a6766cbc7950ddfb0c4">operator-</a> (const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s1, const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;s2)</td></tr>
<tr class="separator:ab170e3ca42d85a6766cbc7950ddfb0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8e53ee3208e09e8736a77be3f485c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a3d8e53ee3208e09e8736a77be3f485c9">operator*</a> (const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;<a class="el" href="namespaceprism.html#acd3c0f96adf158a29387191d79c4d874">size</a>, const int factor)</td></tr>
<tr class="separator:a3d8e53ee3208e09e8736a77be3f485c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd79758984cccce0dddfb459af65f6e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#acd79758984cccce0dddfb459af65f6e1">operator*</a> (const int factor, const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;<a class="el" href="namespaceprism.html#acd3c0f96adf158a29387191d79c4d874">size</a>)</td></tr>
<tr class="separator:acd79758984cccce0dddfb459af65f6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e100bd6b1730deaab53d1218e29a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad7e100bd6b1730deaab53d1218e29a67">operator/</a> (const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;<a class="el" href="namespaceprism.html#acd3c0f96adf158a29387191d79c4d874">size</a>, const int factor)</td></tr>
<tr class="separator:ad7e100bd6b1730deaab53d1218e29a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6335168e27f481d86ae42da444006d1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ad6335168e27f481d86ae42da444006d1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;<a class="el" href="namespaceprism.html#acd3c0f96adf158a29387191d79c4d874">size</a>)</td></tr>
<tr class="separator:ad6335168e27f481d86ae42da444006d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7bfee93ae735b5af7e566ddd8c4f65"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a0e7bfee93ae735b5af7e566ddd8c4f65">operator==</a> (const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str1, const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str2)</td></tr>
<tr class="separator:a0e7bfee93ae735b5af7e566ddd8c4f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2215edf9ab445c3c1791217d131b15"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a5c2215edf9ab445c3c1791217d131b15">operator!=</a> (const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str1, const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str2)</td></tr>
<tr class="separator:a5c2215edf9ab445c3c1791217d131b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433f7afd310d95a93cf8c03d1f831812"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classprism_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a433f7afd310d95a93cf8c03d1f831812">operator+</a> (const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str1, const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str2)</td></tr>
<tr class="separator:a433f7afd310d95a93cf8c03d1f831812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50879e9455a36b7762514951ca0f47f7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classprism_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a50879e9455a36b7762514951ca0f47f7">operator+</a> (const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str1, const char *str2)</td></tr>
<tr class="separator:a50879e9455a36b7762514951ca0f47f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d59729f69eafd3bc9f4d30ad9dd06b6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classprism_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7d59729f69eafd3bc9f4d30ad9dd06b6">operator+</a> (const char *str1, const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str2)</td></tr>
<tr class="separator:a7d59729f69eafd3bc9f4d30ad9dd06b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fce6a8b93050fcb6db327e68b701e3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classprism_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa0fce6a8b93050fcb6db327e68b701e3">operator+</a> (const char c, const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str)</td></tr>
<tr class="separator:aa0fce6a8b93050fcb6db327e68b701e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae68ccc6eb3a47a748671c1a7af88ca"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classprism_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8ae68ccc6eb3a47a748671c1a7af88ca">operator+</a> (const <a class="el" href="classprism_1_1_string.html">String</a> &amp;str, const char c)</td></tr>
<tr class="separator:a8ae68ccc6eb3a47a748671c1a7af88ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a166bbf645cc854542cc0fc50324670"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a0a166bbf645cc854542cc0fc50324670">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_string.html">String</a> &amp;s)</td></tr>
<tr class="separator:a0a166bbf645cc854542cc0fc50324670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd483f03b731881b25da5612b1213e5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_time.html">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#afd483f03b731881b25da5612b1213e5f">operator+</a> (const <a class="el" href="classprism_1_1_time.html">Time</a> &amp;t1, const <a class="el" href="classprism_1_1_time.html">Time</a> &amp;t2)</td></tr>
<tr class="separator:afd483f03b731881b25da5612b1213e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18009df22007fbbde08ab44b16a9a31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_time.html">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa18009df22007fbbde08ab44b16a9a31">operator-</a> (const <a class="el" href="classprism_1_1_time.html">Time</a> &amp;t1, const <a class="el" href="classprism_1_1_time.html">Time</a> &amp;t2)</td></tr>
<tr class="separator:aa18009df22007fbbde08ab44b16a9a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c24ead13d51c13dcadde1b6df4a4967"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7c24ead13d51c13dcadde1b6df4a4967">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_time.html">Time</a> &amp;t)</td></tr>
<tr class="separator:a7c24ead13d51c13dcadde1b6df4a4967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae482804c32b466401a9ecdf26bc1e6de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ae482804c32b466401a9ecdf26bc1e6de">operator+</a> (const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;a, const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;b)</td></tr>
<tr class="separator:ae482804c32b466401a9ecdf26bc1e6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86359a88dc5245847de48575a1f969e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a86359a88dc5245847de48575a1f969e8">operator-</a> (const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;a, const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;b)</td></tr>
<tr class="separator:a86359a88dc5245847de48575a1f969e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124f1081b3a9bbc441dac9927f8a0fc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a124f1081b3a9bbc441dac9927f8a0fc5">operator-</a> (const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;v)</td></tr>
<tr class="separator:a124f1081b3a9bbc441dac9927f8a0fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6528ec4496096e8ccde186bb01fbeed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a6528ec4496096e8ccde186bb01fbeed3">operator*</a> (const float factor, const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;v)</td></tr>
<tr class="separator:a6528ec4496096e8ccde186bb01fbeed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de3bc1dbc3fd33f26d580bce3520854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1de3bc1dbc3fd33f26d580bce3520854">operator*</a> (const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;v, const float factor)</td></tr>
<tr class="separator:a1de3bc1dbc3fd33f26d580bce3520854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1ab02785c9d4d5ea560face252b75e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aea1ab02785c9d4d5ea560face252b75e">operator/</a> (const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;v, const float divisor)</td></tr>
<tr class="separator:aea1ab02785c9d4d5ea560face252b75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311fc983ec89876189643e840d781974"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a311fc983ec89876189643e840d781974">operator==</a> (const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;a, const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;b)</td></tr>
<tr class="separator:a311fc983ec89876189643e840d781974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9d0b027a9e7d9e313affe5af91dabc"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7e9d0b027a9e7d9e313affe5af91dabc">operator!=</a> (const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;a, const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;b)</td></tr>
<tr class="separator:a7e9d0b027a9e7d9e313affe5af91dabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4616180b97f4288a3b3e28304efee020"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a4616180b97f4288a3b3e28304efee020">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;v)</td></tr>
<tr class="separator:a4616180b97f4288a3b3e28304efee020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac90b31f235390d6feb818e3f88ecf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a7ac90b31f235390d6feb818e3f88ecf0">operator+</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;a, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;b)</td></tr>
<tr class="separator:a7ac90b31f235390d6feb818e3f88ecf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3beb56b334423e027f1ab185785695f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a3beb56b334423e027f1ab185785695f8">operator-</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;a, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;b)</td></tr>
<tr class="separator:a3beb56b334423e027f1ab185785695f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7cf835ff415e187e6881169803f502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a8f7cf835ff415e187e6881169803f502">operator-</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v)</td></tr>
<tr class="separator:a8f7cf835ff415e187e6881169803f502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429cccc5eee454ba019045afb4a01e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a429cccc5eee454ba019045afb4a01e93">operator*</a> (const float factor, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v)</td></tr>
<tr class="separator:a429cccc5eee454ba019045afb4a01e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f2f6de8bf1b584cbb82062a607e167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa1f2f6de8bf1b584cbb82062a607e167">operator*</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v, const float factor)</td></tr>
<tr class="separator:aa1f2f6de8bf1b584cbb82062a607e167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e022748076586917c38e83430df284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a87e022748076586917c38e83430df284">operator/</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v, const float divisor)</td></tr>
<tr class="separator:a87e022748076586917c38e83430df284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc2a483f2e3ec622ad2c0ac9699fbcb"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a2fc2a483f2e3ec622ad2c0ac9699fbcb">operator==</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;a, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;b)</td></tr>
<tr class="separator:a2fc2a483f2e3ec622ad2c0ac9699fbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa752c5d0210902dece31c2fcfc98a824"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa752c5d0210902dece31c2fcfc98a824">operator!=</a> (const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;a, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;b)</td></tr>
<tr class="separator:aa752c5d0210902dece31c2fcfc98a824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b9367a483153af865552ba486f1196"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa7b9367a483153af865552ba486f1196">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;v)</td></tr>
<tr class="separator:aa7b9367a483153af865552ba486f1196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac9ebc0ce1449793eb8f521c64929a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a4ac9ebc0ce1449793eb8f521c64929a9">operator+</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;a, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;b)</td></tr>
<tr class="separator:a4ac9ebc0ce1449793eb8f521c64929a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038a64f530d1c50bf72cf1a23886ecca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a038a64f530d1c50bf72cf1a23886ecca">operator-</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;a, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;b)</td></tr>
<tr class="separator:a038a64f530d1c50bf72cf1a23886ecca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147712ae50c37618cbc61f20efe6729f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a147712ae50c37618cbc61f20efe6729f">operator-</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v)</td></tr>
<tr class="separator:a147712ae50c37618cbc61f20efe6729f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa652a61fe96302693aa0279e832360c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aa652a61fe96302693aa0279e832360c7">operator*</a> (const float factor, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v)</td></tr>
<tr class="separator:aa652a61fe96302693aa0279e832360c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b4a59d9247143b49db3c2778838895"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#ab3b4a59d9247143b49db3c2778838895">operator*</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v, const float factor)</td></tr>
<tr class="separator:ab3b4a59d9247143b49db3c2778838895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa2b9a75c3d5134fc80cc6afc1be443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprism_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a4aa2b9a75c3d5134fc80cc6afc1be443">operator/</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v, const float divisor)</td></tr>
<tr class="separator:a4aa2b9a75c3d5134fc80cc6afc1be443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bdef743a64c754bf1a2b217c82f60a"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a80bdef743a64c754bf1a2b217c82f60a">operator==</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;a, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;b)</td></tr>
<tr class="separator:a80bdef743a64c754bf1a2b217c82f60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffa413af039c2bff07202dcfce55f05"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#a1ffa413af039c2bff07202dcfce55f05">operator!=</a> (const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;a, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;b)</td></tr>
<tr class="separator:a1ffa413af039c2bff07202dcfce55f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb86919d9ba71747d21fbd6e28671692"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprism.html#aeb86919d9ba71747d21fbd6e28671692">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;v)</td></tr>
<tr class="separator:aeb86919d9ba71747d21fbd6e28671692"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Completely and shamefully lifted from Qt's QFlag/QFlags classes and macros and just renamed without the prepended 'Q'. These classes allow enums to be treated as datatypes when passed to methods. They are also type-safe so that the receiving method is expecting the enum and not the basic int equivalent. So printFlag(Label::AlignLeft) works whilst printFlag(2) doesn't.</p>
<p>For example,</p>
<p>class Label { private: enum Alignment { AlignLeft = 0x1, AlignRight = 0x2 } <a class="el" href="_flags_8h.html#aa5aa2c9827ab949836e20999b9a068ec">PRISM_DECLARE_FLAGS(AlignFlags, Alignment)</a> }</p>
<p>// outside class def <a class="el" href="_flags_8h.html#ae8aabb683a18b872a4449769b82e8e15">PRISM_DECLARE_OPERATORS_FOR_FLAGS(Label::AlignFlags)</a></p>
<p>void printFlag(Label::AlignFlags f) { if (f == Label::AlignLeft) std::cout &lt;&lt; "AlignLeft" &lt;&lt; std::endl; else if (f == Label::AlignRight) std::cout &lt;&lt; "AlignRight" &lt;&lt; std::endl; else std::cout &lt;&lt; f &lt;&lt; std::endl; }</p>
<p>int main(int argc, char** argv) { printFlag(Label::AlignLeft); }</p>
<p>This simple class extends the <a class="el" href="classprism_1_1_allocator.html">Allocator</a> class by logging each memory allocation and deallocation by storing the newly allocated pointer in a <a class="el" href="classprism_1_1_vector.html">Vector</a> on allocation and removes it when the pointer is deallocated. In theory, at the end of the <a class="el" href="classprism_1_1_logger_allocator.html">LoggerAllocator</a>'s lifetime the <a class="el" href="classprism_1_1_vector.html">Vector</a> should be empty as all pointers should be deallocated. If there are still pointers in the vector then an error message is printed to the console.</p>
<p>A <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> is made up of four components (w, x, y and z) which are a scalar (w) and a 3d vector (x, y and z). It does not suffer from gimbal lock and yet can represent any orientation possible.</p>
<p>Some interesting properties of quaternion multiplication: a) it is associative but not commutitive - (ab)c = a(bc) ab != ba</p>
<p>b) the magnitude of a quaternion product equals the product of the individual magnitudes. This is an important concept because when quaternions are of unit length and are multiplied, this guarentees us that the result will itself be a unit quaternion - ||ab|| = ||a||||b||</p>
<p>c) the inverse of a quaternion product is equal to the product of the individual quaternion inverses in reverse order - (ab).inverse = (b.inverse) * (a.inverse)</p>
<p>Rotating vectors: When rotating with a quaternion it is important that the quaternion be normalised i.e. be of unit length. This is because otherwise scaling will occur and since we only require rotations from our quaternions this won't do. Rotating a vector using quaternions is done with the following equation: v' = q * v * q.inverse where vector v is represented as a quaternion.</p>
<p>Concatenating rotational transforms together: Multiple quaternion rotations can be applied to a vector in one single action by concatenating the rotational quaternions together and then applying them to the vector using the above equation. For example, to rotate the vector v by quaternion a and then rotating that result by quaternion b would be as follows: v' = b * (a * v * a.inverse) * b.inverse = (b * a) * v * (b.inverse * a.inverse) = (b * a) * v * (b * a).inverse So, rotating by a and then by b is equivalent to the single rotation of the product of ba. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a82052418345794a13044c15d8e32dd89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator prism::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the range <em></em>[first,last] for the first occurrence of two consecutive elements that match. </p><dl class="section return"><dt>Returns</dt><dd>Returns an iterator to the first of these two elements, or <em>last</em> if no such pair is found. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b26c227e2d379b9d934a85a2570bae7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator prism::adjacent_find_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the range <em></em>[first,last] for the first occurrence of two consecutive elements that match. </p><dl class="section return"><dt>Returns</dt><dd>Returns an iterator to the first of these two elements, or <em>last</em> if no such pair is found. </dd></dl>

</div>
</div>
<a class="anchor" id="aba366b328f3b6161e6115c16b7153c6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::all_of </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <em>pred</em> returns true for all the elements in the range <em></em>[first,last] or if the range is empty, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="adee0c5bacf315d8cfdc4de7151ba2295"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::all_of_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <em>pred</em> returns true for all the elements in the range <em></em>[first,last] or if the range is empty, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="af48d4e417d7dc90cd7979795347e1718"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T_Alloc prism::allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d0e3ddb9f698759635572f1220ec0ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::any_of </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <em>pred</em> returns true for any of the elements in the range <em></em>[first, last]. </p>

</div>
</div>
<a class="anchor" id="aae3105c7afbb375201f4691b7ea966b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::any_of_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <em>pred</em> returns true for any of the elements in the range <em></em>[first, last]. </p>

</div>
</div>
<a class="anchor" id="afc3c0da5e0e065dd58d686f551746982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::append </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a675cbab48f22d95f990b33294a447dfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_reference prism::at </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the the element at index <em>i</em>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>an <a class="el" href="classprism_1_1_out_of_bounds_exception.html">OutOfBoundsException</a> if <em>i</em> is less than 0 or greater than or equal to <em><a class="el" href="namespaceprism.html#acd3c0f96adf158a29387191d79c4d874">size()</a></em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a const reference to the the element at index <em>i</em>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>an <a class="el" href="classprism_1_1_out_of_bounds_exception.html">OutOfBoundsException</a> if <em>i</em> is less than 0 or greater than or equal to <em><a class="el" href="namespaceprism.html#acd3c0f96adf158a29387191d79c4d874">size()</a></em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32fa4c8645ce4e3df7586e5a9f50c768"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_reference prism::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the last element in the Deque.</dd>
<dd>
Returns a const reference to the last element in the Deque. </dd></dl>

</div>
</div>
<a class="anchor" id="a05fcc740caf535a0f4ee6bba7301cf7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator prism::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator that points to the first element in the Deque.</dd>
<dd>
Returns a const_iterator that points to the first element in the Deque. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f11d607fd7daaeaf07d7b83e1add209"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int prism::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns the capacity of the Deque. </dd></dl>

</div>
</div>
<a class="anchor" id="acd7a4333c9a67559cfd90bb6d1c85420"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator prism::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const_iterator that points to the first element in the Deque. </dd></dl>

</div>
</div>
<a class="anchor" id="a0247b88b3e29f34b1cb742d724a6a330"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator prism::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const_iterator that points to one position past the last element in the Deque. </dd></dl>

</div>
</div>
<a class="anchor" id="ad22144cb445517f69b2e6f76586cf75d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all elements from the Deque so that its size is 0. <br />
Note that this does not affect the capacity. </p>

</div>
</div>
<a class="anchor" id="a8f07ef2e7db05a23c631dee99ad4eba3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator prism::constBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const_iterator that points to the first element in the Deque. </dd></dl>

</div>
</div>
<a class="anchor" id="a61b5e8524d7d3106a0b01cd002af8f75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator prism::constEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const_iterator that points to one position past the last element in the Deque. </dd></dl>

</div>
</div>
<a class="anchor" id="af62c0c26668facbe5607e8915442010e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::construct </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aec550341cf4587d3a0afaa9492e77503"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::contains </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the Deque contains <em>value</em>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae776f4cd825f79e7af1cf6ee1d90a209"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] into the range beginning at <em>otherFirst</em>. </p>

</div>
</div>
<a class="anchor" id="a8fc5dc440a705fbe80912a49ea6d899b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::copy_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] into the range beginning at <em>otherFirst</em>. </p>

</div>
</div>
<a class="anchor" id="a2564c63b76369cc81ff725a56e818046"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator1 , class BidirectionalIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BidirectionalIterator2 prism::copy_backward </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator2&#160;</td>
          <td class="paramname"><em>otherLast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range [first,last] starting from <em>last</em> to the range ending at <em>otherLast</em>. The elements copied are between <em>first</em> and <em>last</em>, including <em>first</em> but not <em>last</em>. <em>otherLast</em> should point to the past-the-end position of the destination range. </p>

</div>
</div>
<a class="anchor" id="af94bcd5517145cc7b62c59a84a776814"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator1 , class BidirectionalIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BidirectionalIterator2 prism::copy_backward_aux </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator2&#160;</td>
          <td class="paramname"><em>otherLast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range [first,last] starting from <em>last</em> to the range ending at <em>otherLast</em>. The elements copied are between <em>first</em> and <em>last</em>, including <em>first</em> but not <em>last</em>. <em>otherLast</em> should point to the past-the-end position of the destination range. </p>

</div>
</div>
<a class="anchor" id="afbed55ae6769c2d88c125aedc2f3846e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] for which <em>pred</em> returns true to the range beginning at <em>otherFirst</em>. </p>

</div>
</div>
<a class="anchor" id="a06d95b48370d6b89936a81e08f7ed8d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::copy_if_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] for which <em>pred</em> returns true to the range beginning at <em>otherFirst</em>. </p>

</div>
</div>
<a class="anchor" id="af907f3f5637d4ec056e9b833b6272953"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Size , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::copy_n </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classprism_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the first <em>n</em> elements from the range beginning at <em>first</em> into the range beginning at <em>otherFirst</em>. </p>

</div>
</div>
<a class="anchor" id="a305d5bebe30595a5d4705a6cef37b52a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Size , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::copy_n_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classprism_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the first <em>n</em> elements from the range beginning at <em>first</em> into the range beginning at <em>otherFirst</em>. </p>

</div>
</div>
<a class="anchor" id="a024117fc3639cdf6598509edf22f034a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int prism::count </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of elements in the range <em></em>[first,last] that compare equal to <em>value</em>. </p>

</div>
</div>
<a class="anchor" id="a02873ae9088199948854cc05b20831c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int prism::count </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a161f644c4e266d280a770bb0c9fbe045"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int prism::count_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of elements in the range <em></em>[first,last] that compare equal to <em>value</em>. </p>

</div>
</div>
<a class="anchor" id="af0007d361beae18a930b6249752e509e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int prism::count_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of elements in the range <em></em>[first,last] for which <em>pred</em> is true. </p>

</div>
</div>
<a class="anchor" id="a8d72a3b00c7e3e537c82829965732dad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int prism::count_if_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of elements in the range <em></em>[first,last] for which <em>pred</em> is true. </p>

</div>
</div>
<a class="anchor" id="a83e62e5b148c55f949e5ea843d53ad67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::delete_range </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the elements in the range <em></em>[first, last] by using the c++ delete operator. The element that the iterator points to therefore must be a pointer. </p>

</div>
</div>
<a class="anchor" id="a25e9f7e103a3f2ae15048eb75dc6af97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::delete_range_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the elements in the range <em></em>[first, last] by using the c++ delete operator. The element that the iterator points to therefore must be a pointer. </p>

</div>
</div>
<a class="anchor" id="a8e77ed12f9b3a35d81935362d3050d0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">prism::Deque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>================================================================================ </p><h1>DequeData </h1>
<p>/** </p><hr/>
 <h1>Deque </h1>
<p>template &lt;class T, class Alloc = prism::Allocator&lt;T&gt;&gt; class Deque { public: typedef Alloc T_Alloc; typedef DequeData&lt;T, T_Alloc&gt; Data; typedef typename Data::iterator iterator; typedef typename Data::const_iterator const_iterator; typedef typename T_Alloc::value_type value_type; typedef typename T_Alloc::difference_type difference_type; typedef typename T_Alloc::pointer pointer; typedef typename T_Alloc::reference reference; typedef typename T_Alloc::const_pointer const_pointer; typedef typename T_Alloc::const_reference const_reference; typedef typename iterator::iterator_category iterator_category; private: SharedDataPointer&lt;Data&gt; d; public: /** Creates an empty Deque. </p>

</div>
</div>
<a class="anchor" id="a73ec48544ee84c6327a63ac5c4c5cb60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">prism::Deque </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a Deque that contains <em>size</em> amount of elements initialized to <em>value</em>. </p>

</div>
</div>
<a class="anchor" id="aa7bbb75108907fb0573f35d3b82ddf3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">prism::Deque </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6d8b2ede230218b04aa9b6f48c94f77d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">prism::Deque </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a Deque and assigns the elements in the initializer list to the Deque. </p>

</div>
</div>
<a class="anchor" id="af8a6c6b9242eb9a0c22af9e28ee4ae80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">prism::Deque </td>
          <td>(</td>
          <td class="paramtype">const Deque&lt; T, T_Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new Deque which is a copy of <em>copy</em>. </p>

</div>
</div>
<a class="anchor" id="af889ac2726920ab1b4f5361e6563d041"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::destroy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7441180af2d914cc54ac35aead6ed030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the Deque is empty i.e. size == 0, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8976ba2aea6612a03f75a390f40daef8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator prism::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator that points to one position past the last element in the Deque.</dd>
<dd>
Returns a const_iterator that points to one position past the last element in the Deque. </dd></dl>

</div>
</div>
<a class="anchor" id="abfc42fa48a8be97e541b137e9ae83c18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::endsWith </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad3bede9a0f2c648e93677b14c45b1b7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator1 , class InputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::equal </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the elements in the range <em></em>[first1,last1] with those in the range beginning at <em>otherFirst</em>, and returns true if all of the elements in both ranges match. <br />
</p><dl class="section note"><dt>Note</dt><dd>The elements being compared must support <a class="el" href="namespaceprism.html#a47eb78b48fe05bc2087a1c5e70f4c373">operator==()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6dc9c68afaa8d8490148baf121bfc1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator1 , class InputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::equal_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the elements in the range <em></em>[first1,last1] with those in the range beginning at <em>otherFirst</em>, and returns true if all of the elements in both ranges match. <br />
</p><dl class="section note"><dt>Note</dt><dd>The elements being compared must support <a class="el" href="namespaceprism.html#a47eb78b48fe05bc2087a1c5e70f4c373">operator==()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a46f69cc5e78e0a7bcd2d9a7ed9c05a8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iterator prism::erase </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab853ba84b4ed547730d02a8c21328e65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iterator prism::erase </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator to the new position of the element that follows the last element erased. <div class="fragment"><div class="line">Deque&lt;int&gt; d({1,2,3,4,5,6});</div><div class="line">iterator it = d.erase(d.begin()+2, d.begin()+5);</div><div class="line"><span class="comment">// *it == 6 since the integers 3, 4 and 5 were erased</span></div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a7c33653a5b4a07b31f5bde15e9085b45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::fill </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns <em>value</em> to all the elements in the range <em></em>[first,last]. </p>

</div>
</div>
<a class="anchor" id="ab76b40745e46fbda01eb55d8258ff498"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets each element in the Deque to <em>value</em>. </p>

</div>
</div>
<a class="anchor" id="a76092b4faa3c2a98088678943ad23df4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::fill_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns <em>value</em> to all the elements in the range <em></em>[first,last]. </p>

</div>
</div>
<a class="anchor" id="aceb4b9c511a5edb706296b457427b226"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::fill_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns <em>value</em> to the first <em>n</em> elements of the sequence pointed by <em>first</em>. </p>

</div>
</div>
<a class="anchor" id="ad2e7f5f7dee0072f4741520356ebdaee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::fill_n_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns <em>value</em> to the first <em>n</em> elements of the sequence pointed by <em>first</em>. </p>

</div>
</div>
<a class="anchor" id="a1b543d9c2862a539cc8b770abda87561"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InputIterator prism::find </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator to the first element in the range <em></em>[first,last] that compares equal to <em>value</em>. If no such element is found, the function returns <em>last</em>. </p>

</div>
</div>
<a class="anchor" id="af23b68308b7ec11222bd2bfb2904c595"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InputIterator prism::find_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator to the first element in the range <em></em>[first,last] that compares equal to <em>value</em>. If no such element is found, the function returns <em>last</em>. </p>

</div>
</div>
<a class="anchor" id="aa17e9e6c80f8a52479a52450a108a636"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InputIterator prism::find_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator to the first element in the range <em></em>[first,last] for which <em>pred</em> returns true. If no such element is found, the function returns <em>last</em>. </p>

</div>
</div>
<a class="anchor" id="a91c456a075b03cfe290044281af93203"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InputIterator prism::find_if_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator to the first element in the range <em></em>[first,last] for which <em>pred</em> returns true. If no such element is found, the function returns <em>last</em>. </p>

</div>
</div>
<a class="anchor" id="a3189014b9fa31e0ef0d1933c6f616618"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InputIterator prism::find_last </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator to the last element in the range <em></em>[first,last] that compares equal to <em>value</em>. The range searched is <em></em>[first,last), which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. If no match is found then a null pointer is returned instead i.e. p=0; </p>

</div>
</div>
<a class="anchor" id="a66df70426cdeee37f0c06a90881f1f36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InputIterator prism::find_last_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator to the last element in the range <em></em>[first,last] that compares equal to <em>value</em>. The range searched is <em></em>[first,last), which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. If no match is found then a null pointer is returned instead i.e. p=0; </p>

</div>
</div>
<a class="anchor" id="ae3fb7a1926a9e8e59300cd5e370470da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_reference prism::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the first element in the Deque.</dd>
<dd>
Returns a const reference to the first element in the Deque. </dd></dl>

</div>
</div>
<a class="anchor" id="aae062d5bfdc0e53ae49c56520aded906"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Function prism::for_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies function <em>func</em> to each of the elements in the range <em></em>[first,last]. </p>

</div>
</div>
<a class="anchor" id="a9adcafd2357df71bd906d85ffe9fdf85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Function prism::for_each_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies function <em>func</em> to each of the elements in the range <em></em>[first,last]. </p>

</div>
</div>
<a class="anchor" id="a0c27e6535264895614b87eefa337404d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_reference prism::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the first element in the Deque.</dd>
<dd>
Returns a const reference to the first element in the Deque. </dd></dl>

</div>
</div>
<a class="anchor" id="a78b6d3259343e632ab4e9d806498ac92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int prism::indexOf </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>from</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for the first index starting from index <em>from</em> that contains <em>value</em>. </p><dl class="section return"><dt>Returns</dt><dd>Returns the index of of the first occurrence of <em>value</em> or -1 if <em>value</em> does not occur in the Deque. </dd></dl>

</div>
</div>
<a class="anchor" id="af52510a241330236aa7202abf65c6dcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::insert </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abd912a072952b08ebd1009abbede3ee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::insert </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a391f88be142a74df98c77632bb8352af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iterator prism::insert </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>insertBefore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a414531a413ed8c90d951f6fd94ac5535"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iterator prism::insert </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>insertBefore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acf5efbeb096446c47690b9e8bd2cc01a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::is_sorted </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the elements in the range <em></em>[first,last] are sorted in ascending order, false otherwise. The range searched is <em></em>[first,last), which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. </p>

</div>
</div>
<a class="anchor" id="a29c1478cf9a6f78fa511d96f93b22791"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::is_sorted_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the elements in the range <em></em>[first,last] are sorted in ascending order, false otherwise. The range searched is <em></em>[first,last), which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. </p>

</div>
</div>
<a class="anchor" id="a538f7dd7bdd8d7963b39a9aea232a598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the Deque is empty i.e. size == 0, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abe4956c4e865f55ca126b7fb973b5078"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_reference prism::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the last element in the Deque.</dd>
<dd>
Returns a const reference to the last element in the Deque. </dd></dl>

</div>
</div>
<a class="anchor" id="af0ed081bf6c17e965bfac0d207cd6c28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int prism::lastIndexOf </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af8e36230e6cb92a41aaca282772a9e6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::make_heap </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rearranges the elements in the range <em></em>[first,last] so that they satisfy the order conditions of a heap.<br />
The range searched is <em></em>[first,last), which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. </p>

</div>
</div>
<a class="anchor" id="a567b63d0d3fa2bc8bdba883f152848be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::make_heap_aux </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rearranges the elements in the range <em></em>[first,last] so that they satisfy the order conditions of a heap.<br />
The range searched is <em></em>[first,last), which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. </p>

</div>
</div>
<a class="anchor" id="a812456273adfa37979e79f07e731d412"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; prism::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the largest of <em>a</em> and <em>b</em>. If they are equivalent then <em>a</em> is returned. </p>

</div>
</div>
<a class="anchor" id="a9d5ae6f65d12dcb2e433ffdc95b733bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; prism::max_aux </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the largest of <em>a</em> and <em>b</em>. If they are equivalent then <em>a</em> is returned. </p>

</div>
</div>
<a class="anchor" id="aeb39a03321ba086c660e96bfa11d33c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt;T, T_Alloc&gt; prism::mid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a10aff0aca673fb1837069dd8967e4738"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; prism::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the smallest of <em>a</em> and <em>b</em>. If they are equivalent then <em>a</em> is returned. </p>

</div>
</div>
<a class="anchor" id="a5ded05d282e95b0ab21c6aeaca2e8794"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; prism::min_aux </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the smallest of <em>a</em> and <em>b</em>. If they are equivalent then <em>a</em> is returned. </p>

</div>
</div>
<a class="anchor" id="a10c83b433c7f98fd4513f1b68c6db594"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::none_of </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <em>pred</em> returns false for all the elements in the range <em></em>[first,last] or if the range is empty, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a4333d241a3ee0f8bce307db84c7eba23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool prism::none_of_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <em>pred</em> returns false for all the elements in the range <em></em>[first,last] or if the range is empty, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a9df924e4deb059bf1200701c8235410a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the managed pointers of p1 and p2 do not point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="ad6391c124e006b0e3a3ec67f55e208b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the managed pointer of p1 and the raw pointer p2 do not point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a249b6933154570d808cdd405ab1fd89b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the chars <em>c1</em> and <em>c2</em> are not equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8792dbd5cac5678390843bacdb69daa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the raw pointer p1 and the managed pointer of p2 do not point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="ae010d5880eb7bcf5119f006e26bf473f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if x or y of p1 and p2 are not equal, false if not </p>

</div>
</div>
<a class="anchor" id="a63ab3c18ecc73e21e7281dbe180e07e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the widths are equal and the heights are not equal of both <a class="el" href="classprism_1_1_size.html">Size</a> objects. </p>

</div>
</div>
<a class="anchor" id="aea72179b12983e614f72acd2b3cbf0e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if /em f1 does not equal /em f2 in value, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a75cab41d882d24ca064927f2390ef3a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if x or y of p1 and p2 are not equal, false if not </p>

</div>
</div>
<a class="anchor" id="a7e9d0b027a9e7d9e313affe5af91dabc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the vectors and returns true if a and b are not equal, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a1ffa413af039c2bff07202dcfce55f05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the vectors and returns true if a and b are not equal, false otherwise. </p>

</div>
</div>
<a class="anchor" id="aa752c5d0210902dece31c2fcfc98a824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the vectors and returns true if a and b are not equal, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a9e32551f997ae19dc52df146482405c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares q1 and q2 and returns true if they are not equal, false otherwise. </p>

</div>
</div>
<a class="anchor" id="aca663878d61686ef365f3e51efddc4b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>bv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>bv2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the two Bitvectors are not equal to each other, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a58cbf7ef406800002b446a0f1e917745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if both circles are not equal, false otherwsie. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9f46c5ebd3cec844925173aaacbed9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the rectangles <em>r1</em> and <em>r2</em> are not equal, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a4d184994eec61a1511fc936a9facb69a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the elements of the two matrices and returns true if they don't contain the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a5c2215edf9ab445c3c1791217d131b15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7410d6cd07f48e8495d2ac7196b2e609"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, T_Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a26b2b2b5b2c5f305badd964c24625b36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> prism::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>bv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>bv2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a bitwise AND on <em>bv1</em> and <em>bv2</em>. </p><dl class="section return"><dt>Returns</dt><dd>Returns a new <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> with the result of <em></em>(bv1 &amp; bv2). </dd></dl>

</div>
</div>
<a class="anchor" id="ac4f48e3429a86bafcc7c21a2bd6a7ae1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_fraction.html">Fraction</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies /em f1 and /em f2 together and returns a new <a class="el" href="classprism_1_1_fraction.html">Fraction</a>. <a class="el" href="classprism_1_1_fraction.html">Fraction</a> multiplication is the easiest arithmetical operation. Simply multiply the two numerators together to form the new numerator and multiply the two denominators together to form the new denominator. e.g. 2 8 2x8 16 4 &mdash; x &mdash; = &mdash; = &mdash; = &mdash; 5 4 5x4 20 5 </p>

</div>
</div>
<a class="anchor" id="a1f5007702b28b447f62c3b9df62f2aa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_fraction.html">Fraction</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies the <a class="el" href="classprism_1_1_fraction.html">Fraction</a> /em fraction by the whole number /em i. Returns a new <a class="el" href="classprism_1_1_fraction.html">Fraction</a>. </p>

</div>
</div>
<a class="anchor" id="ade1984e58679ef4d8fcdd37726ee6483"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_pointf.html">Pointf</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_pointf.html">Pointf</a> object that is formed by multiplying the components of p by the float factor </p>

</div>
</div>
<a class="anchor" id="a409aa6b61b79f029d78f6d4c3aba2df5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_pointf.html">Pointf</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af1ff5871f65565a84b886c5013bcd50a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_fraction.html">Fraction</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>fraction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies the whole number /em i by the <a class="el" href="classprism_1_1_fraction.html">Fraction</a> /em fraction. Returns a new <a class="el" href="classprism_1_1_fraction.html">Fraction</a>. </p>

</div>
</div>
<a class="anchor" id="a40976ce143923309d4c737bb8288d9e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> object that is formed by multiplying the components of p by the int factor </p>

</div>
</div>
<a class="anchor" id="a96e41c0858ff4149eafa1bc878dabb7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> object that is formed by multiplying the components of p by the float factor Note: the x and y components are rounded to the nearest integer as they are stored as ints internally. Use <a class="el" href="classprism_1_1_pointf.html">Pointf</a> for floating point accuracy instead. </p>

</div>
</div>
<a class="anchor" id="aa46a547ddc48425588986b0840d026a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> object that is formed by multiplying the components of p by the int factor </p>

</div>
</div>
<a class="anchor" id="a1ec2671f1e6c155a79740a8556baecc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> object that is formed by multiplying the components of p by the float factor Note: the x and y components are rounded to the nearest integer as they are stored as ints internally. Use <a class="el" href="classprism_1_1_pointf.html">Pointf</a> for floating point accuracy instead. </p>

</div>
</div>
<a class="anchor" id="a3d8e53ee3208e09e8736a77be3f485c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_size.html">Size</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies <em>size</em> by <em>factor</em> and returns a new <a class="el" href="classprism_1_1_size.html">Size</a> object. </p>

</div>
</div>
<a class="anchor" id="acd79758984cccce0dddfb459af65f6e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_size.html">Size</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies <em>size</em> by <em>factor</em> and returns a new <a class="el" href="classprism_1_1_size.html">Size</a> object. </p>

</div>
</div>
<a class="anchor" id="a6528ec4496096e8ccde186bb01fbeed3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector2.html">Vector2</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector2.html">Vector2</a> that has had each vector component of v multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="a1de3bc1dbc3fd33f26d580bce3520854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector2.html">Vector2</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector2.html">Vector2</a> that has had each vector component of v multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="a74c3eeec91c3a178711b6f05a5487d70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> that is the product of q1 and q2. Note: quaternion multiplication is associative so a(bc) = (ab)c but is not commutitive so q1q2 does not always equal q2q1. Order matters! </p>

</div>
</div>
<a class="anchor" id="aa652a61fe96302693aa0279e832360c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> that has had each vector component of v multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="ab3b4a59d9247143b49db3c2778838895"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> that has had each vector component of v multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="a429cccc5eee454ba019045afb4a01e93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> that has had each vector component of v multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="aa1f2f6de8bf1b584cbb82062a607e167"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> that has had each vector component of v multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="a45806b1a58ec5aae0db87d399d4d832b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> that is the result of multiplying each component of q by factor. </p>

</div>
</div>
<a class="anchor" id="ad9f03413053b1efa6851344eb39a5982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> that is the result of multiplying each component of q by factor. </p>

</div>
</div>
<a class="anchor" id="a8aebd3615ba448915f37140515a37b05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies a quaternion and vector3 together and returns a quaternion as a result. The vector is just transformed into a quaternion (setting w = 0) and then the two quaternions are multiplied. </p>

</div>
</div>
<a class="anchor" id="a2c4c5e120d8c4de9891f2261a50f100e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies a quaternion and <a class="el" href="classprism_1_1_vector4.html">Vector4</a> together and returns a quaternion as a result. The vector is just transformed into a quaternion and then the two quaternions are multiplied. </p>

</div>
</div>
<a class="anchor" id="a9ae44fb46bb709a5c8f4d592baf65522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> that is the product of m1 and m2 i.e. m1m2 </p>

</div>
</div>
<a class="anchor" id="ab3639f7bd46a54726522dfe406841ea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> where each component of m is multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="a4073983f089695c40b6fd20d892175f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> where each component of m is multiplied by factor. </p>

</div>
</div>
<a class="anchor" id="aa2859acb8e8dd6fea8678e14249e561d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> that is the result of multiplying a <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> with a float array. </p>

</div>
</div>
<a class="anchor" id="a5e83bcd69595728106bed838aeb32f70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> that is the result of multiplying a <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> with a float array. </p>

</div>
</div>
<a class="anchor" id="a95ceb3342a808c88d0bb7c1f7e0ef82b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> which has been transformed by the matrix M in the order of vM. </p>

</div>
</div>
<a class="anchor" id="a04f1e6e0f84169fce23b236e0312d6a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> which has been transformed by the matrix M in the order of Mv. </p>

</div>
</div>
<a class="anchor" id="a5a10d8ea1e63b19d02bd294e4ebabb1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> which has been transformed by the matrix M in the order of vM. </p>

</div>
</div>
<a class="anchor" id="ad125bd8304d577b6f879fb973f774eb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> which has been transformed by the matrix M in the order of Mv. </p>

</div>
</div>
<a class="anchor" id="a44373b8bda7131a90d04eef7e455ea6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> which has been transformed by the matrix m in the order of pM </p>

</div>
</div>
<a class="anchor" id="a82522932359d2381607cf1fe0c898011"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> which has been transformed by the matrix M in the order of Mp </p>

</div>
</div>
<a class="anchor" id="ac1b5b2765c314b2baa2dba5c57419829"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_fraction.html">Fraction</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the fractions /em f1 and /em f2 together and returns a new <a class="el" href="classprism_1_1_fraction.html">Fraction</a>. If the two denominators are the same then the two numerators are added together to form the new numerator and the original denominator is kept the same. e.g. 1 1 2 &mdash; + &mdash; = &mdash; 4 4 4 If the denominators are different then we alter the fractions in order to make both denominators the same value. We make a whole fraction out of the second fraction's denominator and multiply it by the first fraction. Then make a whole fraction from the first fraction's denominator and multiply it by the second fraction. Now we can simply add together the two numerators and keep the denominator the same. 1 1 | 4 1 | | 1 2 | 4 2 6 3 &mdash; + &mdash; = |&mdash; x &mdash;| + |&mdash; x &mdash;| = &mdash; + &mdash; = &mdash; = &mdash; 2 4 | 4 2 | | 4 2 | 8 8 8 4 </p>

</div>
</div>
<a class="anchor" id="a64243aa2d4cf6ddb70526aaeda396f82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_pointf.html">Pointf</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_pointf.html">Pointf</a> object that is the sum of the components of p1 and p2 </p>

</div>
</div>
<a class="anchor" id="a49e983b5c32c93114583309eda19dc2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> object that is the sum of the components of p1 and p2 </p>

</div>
</div>
<a class="anchor" id="a7141aeb35db81548155e44d60c05530e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_size.html">Size</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds <em>s1</em> and <em>s2</em> together and returns a new <a class="el" href="classprism_1_1_size.html">Size</a> object. </p>

</div>
</div>
<a class="anchor" id="ae482804c32b466401a9ecdf26bc1e6de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector2.html">Vector2</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector2.html">Vector2</a> that is the result of adding the components of vector a and vector b. </p>

</div>
</div>
<a class="anchor" id="afd483f03b731881b25da5612b1213e5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_time.html">Time</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_time.html">Time</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_time.html">Time</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the two <a class="el" href="classprism_1_1_time.html">Time</a> objects together to produce a new <a class="el" href="classprism_1_1_time.html">Time</a> object. If the new time would be later than midnight then the time wraps round. </p><div class="fragment"><div class="line">Time time(20,0); <span class="comment">// 8pm</span></div><div class="line">Time offset1 = <a class="code" href="classprism_1_1_time.html#a380242e03982df8bf4af3eaa2296c808">Time::hour</a>(2);</div><div class="line">Time offset2 = <a class="code" href="classprism_1_1_time.html#a380242e03982df8bf4af3eaa2296c808">Time::hour</a>(5);</div><div class="line"></div><div class="line">Time result;</div><div class="line"></div><div class="line">result = time+offset1; <span class="comment">// Time object set to 22:00:00:000</span></div><div class="line">result = time+offset2; <span class="comment">// Time object set to 01:00:00:000</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad81bceaddc25922e571b4bf427ffe296"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> that is the sum of q1 and q2 i.e. each component of q1 is added to the corresponding component of q2. </p>

</div>
</div>
<a class="anchor" id="a4ac9ebc0ce1449793eb8f521c64929a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> that is the result of adding the components of vector a and vector b. </p>

</div>
</div>
<a class="anchor" id="a7ac90b31f235390d6feb818e3f88ecf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> that is the result of adding the components of vector a and vector b. </p>

</div>
</div>
<a class="anchor" id="a33537d30f01f996f8a05fc5b1b49ba3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> which is the sum of m1 and m2. </p>

</div>
</div>
<a class="anchor" id="a433f7afd310d95a93cf8c03d1f831812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classprism_1_1_string.html">String</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a50879e9455a36b7762514951ca0f47f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classprism_1_1_string.html">String</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7d59729f69eafd3bc9f4d30ad9dd06b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classprism_1_1_string.html">String</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa0fce6a8b93050fcb6db327e68b701e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classprism_1_1_string.html">String</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8ae68ccc6eb3a47a748671c1a7af88ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classprism_1_1_string.html">String</a> prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a769b9ece349795edbfeb8e33cbf276e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt;T, Alloc&gt; prism::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1619579754dfe66f3fe3559f2e4495e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt;T, Alloc&gt;&amp; prism::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2daf470e5f35f8450447deb2634c22c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_fraction.html">Fraction</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtracts the fractions /em f1 and /em f2 and returns a new <a class="el" href="classprism_1_1_fraction.html">Fraction</a>. If the two denominators are the same then the two numerators are subtracted to form the new numerator and the original denominator is kept the same. e.g. 3 1 2 &mdash; - &mdash; = &mdash; 4 4 4 If the denominators are different then we alter the fractions in order to make both denominators the same value. We make a whole fraction out of the second fraction's denominator and multiply it by the first fraction. Then make a whole fraction from the first fraction's denominator and multiply it by the second fraction. Now we can simply subtract the two numerators and keep the denominator the same. 3 1 | 2 3 | | 1 4 | 6 4 2 1 &mdash; - &mdash; = |&mdash; x &mdash;| - |&mdash; x &mdash;| = &mdash; - &mdash; = &mdash; = &mdash; 4 2 | 2 4 | | 2 4 | 8 8 8 4 </p>

</div>
</div>
<a class="anchor" id="a435d5c45d873875f2c5092d102eddb78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_pointf.html">Pointf</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_pointf.html">Pointf</a> object that is formed by subtracting the components of p2 from p1 </p>

</div>
</div>
<a class="anchor" id="a505cbd94f024ad80136afe0b751da08a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> object that is formed by subtracting the components of p2 from p1 </p>

</div>
</div>
<a class="anchor" id="ab170e3ca42d85a6766cbc7950ddfb0c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_size.html">Size</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtracts <em>s2</em> from <em>s1</em> and returns a new <a class="el" href="classprism_1_1_size.html">Size</a> object. </p>

</div>
</div>
<a class="anchor" id="a86359a88dc5245847de48575a1f969e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector2.html">Vector2</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector2.html">Vector2</a> that is the result of subtracting the components of vector b from vector a. Note: vector subtraction is not commutitive so a-b does not always equal b-a </p>

</div>
</div>
<a class="anchor" id="a124f1081b3a9bbc441dac9927f8a0fc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector2.html">Vector2</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector2.html">Vector2</a> object where each vector component of v has been negated. </p>

</div>
</div>
<a class="anchor" id="aa18009df22007fbbde08ab44b16a9a31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_time.html">Time</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_time.html">Time</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_time.html">Time</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtracts the <a class="el" href="classprism_1_1_time.html">Time</a> object <em>t2</em> from <em>t1</em> to produce a new <a class="el" href="classprism_1_1_time.html">Time</a> object. If the new time would be before midnight then the time wraps round. </p><div class="fragment"><div class="line">Time time(5,0); <span class="comment">// 5am</span></div><div class="line">Time offset1 = <a class="code" href="classprism_1_1_time.html#a380242e03982df8bf4af3eaa2296c808">Time::hour</a>(2);</div><div class="line">Time offset2 = <a class="code" href="classprism_1_1_time.html#a380242e03982df8bf4af3eaa2296c808">Time::hour</a>(7);</div><div class="line"></div><div class="line">Time result;</div><div class="line"></div><div class="line">result = time-offset1; <span class="comment">// Time object set to 03:00:00:000 (3am)</span></div><div class="line">result = time-offset2; <span class="comment">// Time object set to 22:00:00:000 (10pm)</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a5eae37b5dc73c544572686f215cea89d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> that is the result of subtracting q2 from q1 i.e. each component of q2 is subtracted from the corresponding component of q1. </p>

</div>
</div>
<a class="anchor" id="a038a64f530d1c50bf72cf1a23886ecca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> that is the result of subtracting the components of vector b from vector a. Note: vector subtraction is not commutitive so a-b does not always equal b-a </p>

</div>
</div>
<a class="anchor" id="ae04c2e5eae2242c58a967086ecad8ff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> which has had each component of q negated. </p>

</div>
</div>
<a class="anchor" id="a147712ae50c37618cbc61f20efe6729f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> object where each vector component of v has been negated. </p>

</div>
</div>
<a class="anchor" id="a3beb56b334423e027f1ab185785695f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> that is the result of subtracting the components of vector b from vector a. Note: vector subtraction is not commutitive so a-b does not always equal b-a </p>

</div>
</div>
<a class="anchor" id="a8f7cf835ff415e187e6881169803f502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> object where each vector component of v has been negated. </p>

</div>
</div>
<a class="anchor" id="a34a2f64f209065f753bed62a880b75b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> which is the result of subtracting m2 from m1. </p>

</div>
</div>
<a class="anchor" id="a879d3410d690b5722a9af17297f38fbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> where each component of matrix m has been negated (multiplyed by -1). </p>

</div>
</div>
<a class="anchor" id="a71504f6dd299e8bc788e07d11d29dc5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_pointf.html">Pointf</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_pointf.html">Pointf</a> object that is formed by dividing the components of p by divisor </p>

</div>
</div>
<a class="anchor" id="a7ba7b5cc9750f0d6cda50f0cb874da6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_fraction.html">Fraction</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divides /em f1 by /em f2 and returns a new <a class="el" href="classprism_1_1_fraction.html">Fraction</a>. <a class="el" href="classprism_1_1_fraction.html">Fraction</a> division is achieved by taking the reciprocal of the second fraction and multiplying it against the first fraction. See /em <a class="el" href="classprism_1_1_fraction.html#aab12f13967ca16e8956618f9d0641c31">Fraction::reciprocal()</a> for more information. 3 2 3 7 21 &mdash; / &mdash; = &mdash; * &mdash; = &mdash; 4 7 4 2 8 </p>

</div>
</div>
<a class="anchor" id="a5f73aee33931e5b9977da32e50d47c0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_point.html">Point</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_point.html">Point</a> object that is formed by dividing the components of p1 by the components of p2 </p>

</div>
</div>
<a class="anchor" id="ad7e100bd6b1730deaab53d1218e29a67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_size.html">Size</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divides <em>size</em> by <em>factor</em> rounding to integer precision and returns a new <a class="el" href="classprism_1_1_size.html">Size</a> object. </p>

</div>
</div>
<a class="anchor" id="aea1ab02785c9d4d5ea560face252b75e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector2.html">Vector2</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector2.html">Vector2</a> where each component of vector v has been divided by divisor. If divisor is 0 then a zero vector is returned instead. </p>

</div>
</div>
<a class="anchor" id="a4aa2b9a75c3d5134fc80cc6afc1be443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector4.html">Vector4</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector4.html">Vector4</a> where each component of vector v has been divided by divisor. If divisor is 0 then a zero vector is returned instead. </p>

</div>
</div>
<a class="anchor" id="a87e022748076586917c38e83430df284"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_vector3.html">Vector3</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_vector3.html">Vector3</a> where each component of vector v has been divided by divisor. If divisor is 0 then a zero vector is returned instead. </p>

</div>
</div>
<a class="anchor" id="aec648937a53338bcd9879670877d0425"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> that is the result of dividing each component of q by divisor. If divisor is 0 then a identity quaternion is returned instead. </p>

</div>
</div>
<a class="anchor" id="a517b4bc9b0ccc23f79b744d93b540fa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> prism::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> where each component of matrix m is divided by divisor. If divisor is 0 a new <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> is returned set to the identity matrix instead. </p>

</div>
</div>
<a class="anchor" id="a2fc3e64ba36a16f24cb0ae387c83f35f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the unicode value of <em>c1</em> is less than <em>c2</em>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a105ac9995ade66ebb2a039ef90751c7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if /em f1 is less than /em f2, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a8e662d15b162ca76912c491798caefd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if <em>c1</em> has a smaller radius than <em>c2</em>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acad408bf2576dfc62a573cb44aa895fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an ostream object that allows this object to printed with std::cout </p>

</div>
</div>
<a class="anchor" id="acb9fe7ab8ef5f1ee0338e3b057624393"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an ostream object that allows this object to printed with std::cout </p>

</div>
</div>
<a class="anchor" id="aa67ea1154a35dabe9c2c232aff65e930"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_char.html">Char</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="a9c2d182a77a92e6cba7917dbd58f9d87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_fraction.html">Fraction</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="ad6335168e27f481d86ae42da444006d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_size.html">Size</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="a7c24ead13d51c13dcadde1b6df4a4967"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_time.html">Time</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_time.html">Time</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="a4616180b97f4288a3b3e28304efee020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_vector2.html">Vector2</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="aeb86919d9ba71747d21fbd6e28671692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_vector4.html">Vector4</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="aa7b9367a483153af865552ba486f1196"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_vector3.html">Vector3</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="ad2beaed7a837821f0abc608cf6ac6c0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to a stream which allows an instance of <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> to be written to the stream. </p>

</div>
</div>
<a class="anchor" id="a403ca8f79c481a89132691c0fd8c3a06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b98ff0fee78022242292f24158ad1f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>bv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="aa63d3d39d3fad8fa5c5966cc4f306324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_circle.html">Circle</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="a52fd2a97b66b06ba6e451e1890136ff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_rect.html">Rect</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="a50da64555d454821545fe0311fde6a62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_list.html">List</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outputs a human-friendly summary of <em>list</em> to the stream <em>out</em>. </p>

</div>
</div>
<a class="anchor" id="ab65e15b3e601e0570beb49a11610c671"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of Matrx4x4 to be written to the ostream out and returns a reference to the ostream. i.e. std::cout &lt;&lt; matrix &lt;&lt; std::endl; </p>

</div>
</div>
<a class="anchor" id="a0a166bbf645cc854542cc0fc50324670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows an instance of <a class="el" href="classprism_1_1_string.html">String</a> to be written to the ostream and returns a reference to the ostream. </p>

</div>
</div>
<a class="anchor" id="a602c194731bf182cf114b7d297bbff51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt;T, T_Alloc&gt;&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, T_Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a40203d2e776fe0acf317a98ef08f8be7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt;T, T_Alloc&gt;&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a554e40f4cee7980e001683ea75b16cd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend std::ostream&amp; prism::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, T_Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a87d86e9266469c8a40537e12a560b066"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the unicode value of <em>c1</em> is less than or equal to <em>c2</em>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5a3ba3d60ef11974d02f7941fa9a263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt;T, T_Alloc&gt;&amp; prism::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, T_Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1ba68b64a6cfdcff9e144b8c2476cddb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the chars <em>c1</em> and <em>c2</em> are equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a13ab889958edc08eea9a5bea056cd9c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_pointf.html">Pointf</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if x and y of p1 and p2 are equal, false if not </p>

</div>
</div>
<a class="anchor" id="a2a7baeb09cd2ee29251667ad18a2bd00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>========================================================== </p><h1>Related non-members </h1>
<p>Returns true if the widths are equal and the heights are equal of both <a class="el" href="classprism_1_1_size.html">Size</a> objects. </p>

</div>
</div>
<a class="anchor" id="ae53d52e8a36ec7ca58ea1731cc18f1d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the managed pointers of p1 and p2 point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a2b73e87f080646696ed6b595a3900119"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the managed pointer of p1 and the raw pointer p2 point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a5b9e84008b9eaa99d29d4b74cd150cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if /em f1 and /em f2 are equal in value. </p>

</div>
</div>
<a class="anchor" id="a1f29b22985dc0ec1fc548a551ce313ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_shared_pointer.html">SharedPointer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the raw pointer p1 and the managed pointer of p2 point to the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a739baa4e75c1ca83624d486eec1d45e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if x and y of p1 and p2 are equal, false if not </p>

</div>
</div>
<a class="anchor" id="a311fc983ec89876189643e840d781974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the two vectors and if each of the corresponding components are equal in value then true is returned, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a80bdef743a64c754bf1a2b217c82f60a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the two vectors and if each of the corresponding components are equal in value then true is returned, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a2fc2a483f2e3ec622ad2c0ac9699fbcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the two vectors and if each of the corresponding components are equal in value then true is returned, false otherwise. </p>

</div>
</div>
<a class="anchor" id="ac4ae112433b9ab32c801cccc9c3f74f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares q1 and q2 and returns true if they are equal, false otherwise. </p>

</div>
</div>
<a class="anchor" id="aca036c7f0f8a5aaf98b46b4879189bcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>bv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>bv2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the two Bitvectors are equal to each other, false otherwise. The Bitvectors are considered equal if they are the same size and each corresponding bit is set to the same value. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ce1ad6e6392618212d5ab3bebb8e585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if both circles have the same radius and (x,y) centre point, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abe409fa2ef458a2d477ed7845cf4b6a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>===================================================================== </p><h1>Related non-members </h1>
<p>Returns true if the rectangles <em>r1</em> and <em>r2</em> are equal, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a8804ec2ab8dda9441d64e947f05e293c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the elements of the two matrices and returns true if they contain the same data, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a0e7bfee93ae735b5af7e566ddd8c4f65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a47eb78b48fe05bc2087a1c5e70f4c373"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceprism.html#a8e77ed12f9b3a35d81935362d3050d0c">Deque</a>&lt; T, T_Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab8a312729c4c9ae72836d0034a6f0758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the unicode value of <em>c1</em> is greater than <em>c2</em>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7122a7ff43fc6aba9cef9d31fe8c7559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_fraction.html">Fraction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if /em f1 is less than /em f2, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a671739ac8567654dba563c34af92213f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_circle.html">Circle</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if <em>c1</em> has a greater radius than <em>c2</em>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aad049ddef9beb3fec3e7057a7f651280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_char.html">Char</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns true if the unicode value of <em>c1</em> is greater than or equal to <em>c2</em>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5cdc796ecf7df67ce6377bfe9eadb7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_reference prism::operator[] </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the element at index <em>i</em>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Note that no bounds checking is performed on <em>i</em>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a const reference to the element at index <em>i</em>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Note that no bounds checking is performed on <em>i</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a18ff84f30ae8056d6807056a24ef14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> prism::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>bv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>bv2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a bitwise XOR on <em>bv1</em> and <em>bv2</em>. </p><dl class="section return"><dt>Returns</dt><dd>Returns a new <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> with the result of <em></em>(bv1 ^ bv2). </dd></dl>

</div>
</div>
<a class="anchor" id="a145d1e196c14cdbdc4eccb01c60c9275"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> prism::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>bv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>bv2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a bitwise OR on <em>bv1</em> and <em>bv2</em>. </p><dl class="section return"><dt>Returns</dt><dd>Returns a new <a class="el" href="classprism_1_1_bitvector.html">Bitvector</a> with the result of <em></em>(bv1 | bv2). </dd></dl>

</div>
</div>
<a class="anchor" id="a5f2c83ae0d89a6581d1c42ba6fd79de0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::p_heapify </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a95d95c728950cef3542d8b1dd27eb344"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::p_heapify_aux </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Private recursive function called by <a class="el" href="namespaceprism.html#a567b63d0d3fa2bc8bdba883f152848be">make_heap_aux()</a>. Compares a node with its two children (if it has any) and ensures that the largest of the three nodes is the parent node. </p>

</div>
</div>
<a class="anchor" id="a682dc15d5493595804b4cf818b16281d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a407f71f548b4930e7880b44cd695b33d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac5a9a7c94d57bb61f25a61ef10d74b80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::prepend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aae03a861ef55e15b5a64c5cb2a727667"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a451a8db591d6c4fc315b05f9bff515"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::push_front </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeddd21943bcf811c56f7d9d1bd4784f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator prism::remove </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms the range <em></em>[first,last] into a range with all the elements that compare equal to <em>value</em> removed, and returns an iterator to the new end of that range. </p>

</div>
</div>
<a class="anchor" id="a5b180b06c92cd65b70d2e565878e5d06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::remove </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2a67eb6dd63f426b2837aebb07940b0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::remove </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acb7d8d4b86592081686e15ee7a18f856"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator prism::remove_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms the range <em></em>[first,last] into a range with all the elements that compare equal to <em>value</em> removed, and returns an iterator to the new end of that range. </p>

</div>
</div>
<a class="anchor" id="ab7b6fb407340e51749169560b48fb20c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::remove_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] to the range beginning at <em>otherFirst</em>, except those elements that compare equal to <em>value</em>. </p>

</div>
</div>
<a class="anchor" id="ae3f41bf6d9ab98a87d693fba69f138dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::remove_copy_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] to the range beginning at <em>otherFirst</em>, except those elements that compare equal to <em>value</em>. </p>

</div>
</div>
<a class="anchor" id="abfc7da1f951e480a26d58fc098b78844"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::remove_copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] to the range beginning at <em>otherFirst</em>, except those elements for which <em>pred</em> returns true. </p>

</div>
</div>
<a class="anchor" id="a198b599ea535deb9fdf28c46c8658bd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::remove_copy_if_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] to the range beginning at <em>otherFirst</em>, except those elements for which <em>pred</em> returns true. </p>

</div>
</div>
<a class="anchor" id="a2e9d25191ed83ea0a193f16d9c0a00b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator prism::remove_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms the range <em></em>[first,last] into a range with all the elements for which <em>pred</em> returns true removed, and returns an iterator to the new end of that range. </p>

</div>
</div>
<a class="anchor" id="a95e9f5186670e27472aa7d8cd02397eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator prism::remove_if_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms the range <em></em>[first,last] into a range with all the elements for which <em>pred</em> returns true removed, and returns an iterator to the new end of that range. </p>

</div>
</div>
<a class="anchor" id="a91a96073d835746d48ba0a145c33b29e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::removeAll </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a32a0d96bc03a45529e399cd39c48cb66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::removeFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7dd774edd9e5b7398334440070da6bdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::removeLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6156070b98de7130b8c912ae3a6d333f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::replace </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>oldValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns <em>newValue</em> to all the elements in the range <em></em>[first,last] that compare equal to <em>oldValue</em>. </p>

</div>
</div>
<a class="anchor" id="acac76605957b60675b2859cef694c61f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::replace </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad053e45daef65797bc1cff18dfcd8dc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::replace_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>oldValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns <em>newValue</em> to all the elements in the range <em></em>[first,last] that compare equal to <em>oldValue</em>. </p>

</div>
</div>
<a class="anchor" id="a16d85ecb70d2f216714a0146a057a105"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::replace_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>oldValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] to the range beginning at <em>otherFirst</em>, replacing the appearances of <em>oldValue</em> by <em>newValue</em>. </p>

</div>
</div>
<a class="anchor" id="a7055d91bb6279fa78b8b498297a11eab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::replace_copy_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>oldValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] to the range beginning at <em>otherFirst</em>, replacing the appearances of <em>oldValue</em> by <em>newValue</em>. </p>

</div>
</div>
<a class="anchor" id="a55d702599739f7137516dcd095119f15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class Predicate , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::replace_copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] to the range beginning at <em>otherFirst</em>, replacing those for which <em>pred</em> returns true by newValue. </p>

</div>
</div>
<a class="anchor" id="a1e660997b10ccb0985b35999c84a9bbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class Predicate , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator prism::replace_copy_if_aux </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements in the range <em></em>[first,last] to the range beginning at <em>otherFirst</em>, replacing those for which <em>pred</em> returns true by newValue. </p>

</div>
</div>
<a class="anchor" id="af118c19f6b5448319eb3aaf2d556ac54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class Predicate , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::replace_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns <em>newValue</em> to all the elements in the range <em></em>[first,last] for which <em>pred</em> returns true. </p>

</div>
</div>
<a class="anchor" id="ad23d44d30470aed0ee16e931514bd727"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class Predicate , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::replace_if_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns <em>newValue</em> to all the elements in the range <em></em>[first,last] for which <em>pred</em> returns true. </p>

</div>
</div>
<a class="anchor" id="a7236cdb4e2661bd63c2fe4ee5c3452f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prism::resize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a03dbb806369b062fd90909fd826c2ee4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator1 prism::search </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>otherLast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the range [first1,last1] for the first occurrence of the sequence defined by [first2,last2], and returns an iterator to its first element, or last1 if no occurrences are found. The range used is [first1,last1], which contains all the elements between first1 and last1, including the element pointed by first1 but not the element pointed by last1. </p>

</div>
</div>
<a class="anchor" id="ab6f8ed8b450ff281e02218e10d5643a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator1 prism::search_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the range [first1,last1] for the first occurrence of the sequence defined by [first2,last2], and returns an iterator to its first element, or last1 if no occurrences are found. The range used is [first1,last1], which contains all the elements between first1 and last1, including the element pointed by first1 but not the element pointed by last1. </p>

</div>
</div>
<a class="anchor" id="acd3c0f96adf158a29387191d79c4d874"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int prism::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns the number of elements currently in the Deque. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bf397cad0a67b67fbd1ecddf40d405e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the elements in the range <em></em>[first,last] in ascending order using the quicksort algorithm. The range used is [first1,last1], which contains all the elements between first1 and last1, including the element pointed by first1 but not the element pointed by last1. <br />
Currently <em><a class="el" href="namespaceprism.html#a9bf397cad0a67b67fbd1ecddf40d405e">sort()</a></em> is implemented using the quicksort algorithm which averages a reasonable O(n log(n)) complexity. </p>

</div>
</div>
<a class="anchor" id="a9e7b2f97895db323cbefbc4af311ccb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the elements in the range <em></em>[first,last] in ascending order using the quicksort algorithm. The range used is [first1,last1], which contains all the elements between first1 and last1, including the element pointed by first1 but not the element pointed by last1. <br />
Currently <em><a class="el" href="namespaceprism.html#a9bf397cad0a67b67fbd1ecddf40d405e">sort()</a></em> is implemented using the quicksort algorithm which averages a reasonable O(n log(n)) complexity. </p>

</div>
</div>
<a class="anchor" id="aa597d262eb2f9ef80703c883a2d18d1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort_bubble </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the elements in the range <em></em>[first, last] in ascending order using the Bubble Sort algorithm. <br />
The range used is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. </p><dl class="section note"><dt>Note</dt><dd>The objects being sorted must support <a class="el" href="namespaceprism.html#ab8a312729c4c9ae72836d0034a6f0758">operator&gt;()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="af3a66e1051c4c7874f305ad2a5f0b37e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort_bubble_aux </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the elements in the range <em></em>[first, last] in ascending order using the Bubble Sort algorithm. <br />
The range used is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. <br />
</p><dl class="section note"><dt>Note</dt><dd>The objects being sorted must support <a class="el" href="namespaceprism.html#ab8a312729c4c9ae72836d0034a6f0758">operator&gt;()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e9fe74c5dcee70bf5dd5c89f1234a02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort_heap </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the elements in the range <em></em>[first,last] using the heapsort algorithm. <br />
The elements are first rearranged so that they satisfy the ordering of a heap (by a call to <a class="el" href="namespaceprism.html#af8e36230e6cb92a41aaca282772a9e6e">make_heap()</a>).<br />
The range used is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. </p>

</div>
</div>
<a class="anchor" id="ab289bdf7cde130b0aeea21a9711770f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort_heap_aux </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the elements in the range <em></em>[first,last] using the heapsort algorithm. <br />
The elements are first rearranged so that they satisfy the ordering of a heap (by a call to <a class="el" href="namespaceprism.html#af8e36230e6cb92a41aaca282772a9e6e">make_heap()</a>).<br />
The range used is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. </p>

</div>
</div>
<a class="anchor" id="a720fbbcb3f399b006969bb00a66686f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort_quicksort </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the elements in the range <em></em>[first, last] in ascending order using the Quicksort algorithm. <br />
The range used is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. </p><dl class="section note"><dt>Note</dt><dd>The objects being sorted must support <a class="el" href="namespaceprism.html#a87d86e9266469c8a40537e12a560b066">operator&lt;=()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a46e0e235fa71938e5ebf29387b917057"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::sort_quicksort_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the elements in the range <em></em>[first, last] in ascending order using the Quicksort algorithm. <br />
The range used is <em></em>[first,last], which contains all the elements between <em>first</em> and <em>last</em>, including the element pointed by <em>first</em> but not the element pointed by <em>last</em>. </p><dl class="section note"><dt>Note</dt><dd>The objects being sorted must support <a class="el" href="namespaceprism.html#a87d86e9266469c8a40537e12a560b066">operator&lt;=()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a92e90ca54b9fa627213076f93d44ca2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool prism::startsWith </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6430516ab4f2e2a7f43323acb6b559d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exchanges the values of <em>a</em> and <em>b</em>. </p>

</div>
</div>
<a class="anchor" id="a6d3a7129cc6ab5d9a80301436e4d2e48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::swap_aux </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exchanges the values of <em>a</em> and <em>b</em>. </p>

</div>
</div>
<a class="anchor" id="a4661f2c0c4dca098c137179b4d93f3dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator2 prism::swap_ranges </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exchanges the values of each of the elements in the range <em></em>[first1,last1] with those of their respective elements in the range beginning at <em>otherFirst</em>. </p>

</div>
</div>
<a class="anchor" id="a7ca4ae3ad4c2e21d6fe48b6fae6930c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator2 prism::swap_ranges_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exchanges the values of each of the elements in the range <em></em>[first1,last1] with those of their respective elements in the range beginning at <em>otherFirst</em>. </p>

</div>
</div>
<a class="anchor" id="a07654e91e7474a3ccdcd95bb5e57baea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprism_1_1_list.html">List</a>&lt;T&gt; prism::toList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a770640a1fe99095d96e9295b225ac93d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;T&gt; prism::toStdDeque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ff56f151fea6e709350a0e9fbdb70a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator2 prism::uninitialized_copy </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The range [first,last] represents a block of memory that has been allocated but not initialized i.e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the <a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45">prism::fill</a> algorithm). This algorithm takes that memory block and initializes each element by copy-constructing each element in place. This algorithm differs from <a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45">prism::fill</a> because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn't. It copy-constructs in place instead. </p>

</div>
</div>
<a class="anchor" id="a6ef07b731fbaecb8abe1ad8faabaab1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator2 prism::uninitialized_copy_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The range [first,last] represents a block of memory that has been allocated but not initialized i.e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the <a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45">prism::fill</a> algorithm). This algorithm takes that memory block and initializes each element by copy-constructing each element in place. This algorithm differs from <a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45">prism::fill</a> because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn't. It copy-constructs in place instead. </p>

</div>
</div>
<a class="anchor" id="ad1c7d8eb38174ba66d98321b68047e6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator2 prism::uninitialized_copy_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The range [first,last] represents a block of memory that has been allocated but not initialized i.e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the <a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45">prism::fill</a> algorithm). This algorithm takes that memory block and initializes each element by copy-constructing each element in place. This algorithm differs from <a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45">prism::fill</a> because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn't. It copy-constructs in place instead. </p>

</div>
</div>
<a class="anchor" id="a85d1fe2d10e98f9de7aec30799f2eec0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator1 , class ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator2 prism::uninitialized_copy_n_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>otherFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The range [first,last] represents a block of memory that has been allocated but not initialized i.e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the <a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45">prism::fill</a> algorithm). This algorithm takes that memory block and initializes each element by copy-constructing each element in place. This algorithm differs from <a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45">prism::fill</a> because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn't. It copy-constructs in place instead. </p>

</div>
</div>
<a class="anchor" id="a8234c2c7917f750db94bb068d6fd554e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::uninitialized_fill </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The range [first,last] represents a block of memory that has been allocated but not initialized i.e. no elements have been constructed. This algorithm takes that memory block and initializes each element by copy-constructing each element in place. </p>

</div>
</div>
<a class="anchor" id="aaa8fcd4a3943bfa624f77fc8f3af5916"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::uninitialized_fill_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The range [first,last] represents a block of memory that has been allocated but not initialized i.e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the <a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45">prism::fill</a> algorithm). This algorithm takes that memory block and initializes each element by copy-constructing each element in place. This algorithm differs from <a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45">prism::fill</a> because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn't. It copy-constructs in place instead. </p>

</div>
</div>
<a class="anchor" id="a5485ae7bad862f6ff0ab363ed4697b61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::uninitialized_fill_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The range [first,last] represents a block of memory that has been allocated but not initialized i.e. no elements have been constructed. This algorithm takes that memory block and initializes each element by copy-constructing each element in place. </p>

</div>
</div>
<a class="anchor" id="aa02596d3361c57f312168ffac621e421"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prism::uninitialized_fill_n_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The range [first,last] represents a block of memory that has been allocated but not initialized i.e. no elements have been constructed yet. This means that the allocated memory cannot be dereferenced yet through an iterator (as in the <a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45">prism::fill</a> algorithm). This algorithm takes that memory block and initializes each element by copy-constructing each element in place. This algorithm differs from <a class="el" href="namespaceprism.html#a7c33653a5b4a07b31f5bde15e9085b45">prism::fill</a> because that algorithm dereferences the iterator to assign the new value whereas this algorithm doesn't. It copy-constructs in place instead. </p>

</div>
</div>
<a class="anchor" id="a331c22c8877ca45c3f9504b1fbfb711c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">prism::~Deque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys this Deque. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceprism.html">prism</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
